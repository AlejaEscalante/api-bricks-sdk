/*
CoinAPI Market Data REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: support@apibricks.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TradesAPIService TradesAPI service
type TradesAPIService service

type ApiV1TradesLatestGetRequest struct {
	ctx context.Context
	ApiService *TradesAPIService
	filterSymbolId *string
	includeId *bool
	limit *int32
}

// Comma or semicolon delimited parts of symbol identifier used to filter response. (optional)
func (r ApiV1TradesLatestGetRequest) FilterSymbolId(filterSymbolId string) ApiV1TradesLatestGetRequest {
	r.filterSymbolId = &filterSymbolId
	return r
}

// Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers.
func (r ApiV1TradesLatestGetRequest) IncludeId(includeId bool) ApiV1TradesLatestGetRequest {
	r.includeId = &includeId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1TradesLatestGetRequest) Limit(limit int32) ApiV1TradesLatestGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1TradesLatestGetRequest) Execute() ([]V1Trade, *http.Response, error) {
	return r.ApiService.V1TradesLatestGetExecute(r)
}

/*
V1TradesLatestGet Latest data

Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TradesLatestGetRequest
*/
func (a *TradesAPIService) V1TradesLatestGet(ctx context.Context) ApiV1TradesLatestGetRequest {
	return ApiV1TradesLatestGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1Trade
func (a *TradesAPIService) V1TradesLatestGetExecute(r ApiV1TradesLatestGetRequest) ([]V1Trade, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1Trade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradesAPIService.V1TradesLatestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trades/latest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterSymbolId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_symbol_id", r.filterSymbolId, "form", "")
	}
	if r.includeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_id", r.includeId, "form", "")
	} else {
		var defaultValue bool = false
		r.includeId = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TradesSymbolIdHistoryGetRequest struct {
	ctx context.Context
	ApiService *TradesAPIService
	symbolId string
	date *string
	timeStart *string
	timeEnd *string
	limit *int32
	includeId *bool
}

// Date in ISO 8601, returned data is for the whole given day (required if &#39;time_start&#39; is not provided)
func (r ApiV1TradesSymbolIdHistoryGetRequest) Date(date string) ApiV1TradesSymbolIdHistoryGetRequest {
	r.date = &date
	return r
}

// Starting time in ISO 8601
func (r ApiV1TradesSymbolIdHistoryGetRequest) TimeStart(timeStart string) ApiV1TradesSymbolIdHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Timeseries ending time in ISO 8601
func (r ApiV1TradesSymbolIdHistoryGetRequest) TimeEnd(timeEnd string) ApiV1TradesSymbolIdHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1TradesSymbolIdHistoryGetRequest) Limit(limit int32) ApiV1TradesSymbolIdHistoryGetRequest {
	r.limit = &limit
	return r
}

// Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers.
func (r ApiV1TradesSymbolIdHistoryGetRequest) IncludeId(includeId bool) ApiV1TradesSymbolIdHistoryGetRequest {
	r.includeId = &includeId
	return r
}

func (r ApiV1TradesSymbolIdHistoryGetRequest) Execute() ([]V1Trade, *http.Response, error) {
	return r.ApiService.V1TradesSymbolIdHistoryGetExecute(r)
}

/*
V1TradesSymbolIdHistoryGet Historical data

Get history transactions from specific symbol, returned in time ascending order.

:::warning
The 'time_start' and 'time_end' parameters must be from the same day as this endpoint provides intraday data only for specific day.
Please use the 'date' parameter instead for querying data for a specific day without filter.
:::

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbolId Symbol identifier for requested timeseries (from the Metadata -> Symbols)
 @return ApiV1TradesSymbolIdHistoryGetRequest
*/
func (a *TradesAPIService) V1TradesSymbolIdHistoryGet(ctx context.Context, symbolId string) ApiV1TradesSymbolIdHistoryGetRequest {
	return ApiV1TradesSymbolIdHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
		symbolId: symbolId,
	}
}

// Execute executes the request
//  @return []V1Trade
func (a *TradesAPIService) V1TradesSymbolIdHistoryGetExecute(r ApiV1TradesSymbolIdHistoryGetRequest) ([]V1Trade, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1Trade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradesAPIService.V1TradesSymbolIdHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trades/{symbol_id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol_id"+"}", url.PathEscape(parameterValueToString(r.symbolId, "symbolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.includeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_id", r.includeId, "form", "")
	} else {
		var defaultValue bool = false
		r.includeId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TradesSymbolIdLatestGetRequest struct {
	ctx context.Context
	ApiService *TradesAPIService
	symbolId string
	limit *int32
	includeId *bool
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1TradesSymbolIdLatestGetRequest) Limit(limit int32) ApiV1TradesSymbolIdLatestGetRequest {
	r.limit = &limit
	return r
}

// Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers.
func (r ApiV1TradesSymbolIdLatestGetRequest) IncludeId(includeId bool) ApiV1TradesSymbolIdLatestGetRequest {
	r.includeId = &includeId
	return r
}

func (r ApiV1TradesSymbolIdLatestGetRequest) Execute() ([]V1Trade, *http.Response, error) {
	return r.ApiService.V1TradesSymbolIdLatestGetExecute(r)
}

/*
V1TradesSymbolIdLatestGet Latest data by symbol_id

Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbolId Symbol identifier for requested timeseries (from the Metadata -> Symbols)
 @return ApiV1TradesSymbolIdLatestGetRequest
*/
func (a *TradesAPIService) V1TradesSymbolIdLatestGet(ctx context.Context, symbolId string) ApiV1TradesSymbolIdLatestGetRequest {
	return ApiV1TradesSymbolIdLatestGetRequest{
		ApiService: a,
		ctx: ctx,
		symbolId: symbolId,
	}
}

// Execute executes the request
//  @return []V1Trade
func (a *TradesAPIService) V1TradesSymbolIdLatestGetExecute(r ApiV1TradesSymbolIdLatestGetRequest) ([]V1Trade, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1Trade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradesAPIService.V1TradesSymbolIdLatestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/trades/{symbol_id}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol_id"+"}", url.PathEscape(parameterValueToString(r.symbolId, "symbolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.includeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_id", r.includeId, "form", "")
	} else {
		var defaultValue bool = false
		r.includeId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
