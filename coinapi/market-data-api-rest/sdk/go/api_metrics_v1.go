/*
CoinAPI Market Data REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: support@apibricks.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)


// MetricsV1APIService MetricsV1API service
type MetricsV1APIService service

type ApiV1MetricsAssetCurrentGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
	metricId *string
	assetId *string
	assetIdExternal *string
	exchangeId *string
}

// Metric identifier (from the Metrics -&gt; Listing)
func (r ApiV1MetricsAssetCurrentGetRequest) MetricId(metricId string) ApiV1MetricsAssetCurrentGetRequest {
	r.metricId = &metricId
	return r
}

// Asset identifier (from the Metadata -&gt; Assets)
func (r ApiV1MetricsAssetCurrentGetRequest) AssetId(assetId string) ApiV1MetricsAssetCurrentGetRequest {
	r.assetId = &assetId
	return r
}

// Exchange asset identifier
func (r ApiV1MetricsAssetCurrentGetRequest) AssetIdExternal(assetIdExternal string) ApiV1MetricsAssetCurrentGetRequest {
	r.assetIdExternal = &assetIdExternal
	return r
}

// Exchange identifier (from the Metadata -&gt; Exchanges)
func (r ApiV1MetricsAssetCurrentGetRequest) ExchangeId(exchangeId string) ApiV1MetricsAssetCurrentGetRequest {
	r.exchangeId = &exchangeId
	return r
}

func (r ApiV1MetricsAssetCurrentGetRequest) Execute() ([]V1GeneralData, *http.Response, error) {
	return r.ApiService.V1MetricsAssetCurrentGetExecute(r)
}

/*
V1MetricsAssetCurrentGet Current metrics for given asset

Get current asset metrics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsAssetCurrentGetRequest
*/
func (a *MetricsV1APIService) V1MetricsAssetCurrentGet(ctx context.Context) ApiV1MetricsAssetCurrentGetRequest {
	return ApiV1MetricsAssetCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1GeneralData
func (a *MetricsV1APIService) V1MetricsAssetCurrentGetExecute(r ApiV1MetricsAssetCurrentGetRequest) ([]V1GeneralData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1GeneralData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsAssetCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/asset/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metricId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id", r.assetId, "form", "")
	}
	if r.assetIdExternal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id_external", r.assetIdExternal, "form", "")
	}
	if r.exchangeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MetricsAssetHistoryGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
	metricId *string
	exchangeId *string
	assetId *string
	assetIdExternal *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (from the Metrics -&gt; Listing)
func (r ApiV1MetricsAssetHistoryGetRequest) MetricId(metricId string) ApiV1MetricsAssetHistoryGetRequest {
	r.metricId = &metricId
	return r
}

// Exchange identifier (from the Metadata -&gt; Exchanges)
func (r ApiV1MetricsAssetHistoryGetRequest) ExchangeId(exchangeId string) ApiV1MetricsAssetHistoryGetRequest {
	r.exchangeId = &exchangeId
	return r
}

// Asset identifier (from the Metadata -&gt; Assets)
func (r ApiV1MetricsAssetHistoryGetRequest) AssetId(assetId string) ApiV1MetricsAssetHistoryGetRequest {
	r.assetId = &assetId
	return r
}

// Exchange asset identifier
func (r ApiV1MetricsAssetHistoryGetRequest) AssetIdExternal(assetIdExternal string) ApiV1MetricsAssetHistoryGetRequest {
	r.assetIdExternal = &assetIdExternal
	return r
}

// Starting time in ISO 8601
func (r ApiV1MetricsAssetHistoryGetRequest) TimeStart(timeStart time.Time) ApiV1MetricsAssetHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiV1MetricsAssetHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV1MetricsAssetHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiV1MetricsAssetHistoryGetRequest) TimeFormat(timeFormat string) ApiV1MetricsAssetHistoryGetRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;
func (r ApiV1MetricsAssetHistoryGetRequest) PeriodId(periodId string) ApiV1MetricsAssetHistoryGetRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1MetricsAssetHistoryGetRequest) Limit(limit int32) ApiV1MetricsAssetHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1MetricsAssetHistoryGetRequest) Execute() ([]V1MetricData, *http.Response, error) {
	return r.ApiService.V1MetricsAssetHistoryGetExecute(r)
}

/*
V1MetricsAssetHistoryGet Historical metrics for asset

Get asset metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsAssetHistoryGetRequest
*/
func (a *MetricsV1APIService) V1MetricsAssetHistoryGet(ctx context.Context) ApiV1MetricsAssetHistoryGetRequest {
	return ApiV1MetricsAssetHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricData
func (a *MetricsV1APIService) V1MetricsAssetHistoryGetExecute(r ApiV1MetricsAssetHistoryGetRequest) ([]V1MetricData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsAssetHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/asset/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id", r.assetId, "form", "")
	}
	if r.assetIdExternal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id_external", r.assetIdExternal, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MetricsAssetListingGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
	metricId *string
	exchangeId *string
	chainId *string
	networkId *string
	assetId *string
	assetIdExternal *string
}

// Metric identifier (from the Metrics -&gt; Listing)
func (r ApiV1MetricsAssetListingGetRequest) MetricId(metricId string) ApiV1MetricsAssetListingGetRequest {
	r.metricId = &metricId
	return r
}

// Exchange identifier (from the Metadata -&gt; Exchanges)
func (r ApiV1MetricsAssetListingGetRequest) ExchangeId(exchangeId string) ApiV1MetricsAssetListingGetRequest {
	r.exchangeId = &exchangeId
	return r
}

// Chain identifier
func (r ApiV1MetricsAssetListingGetRequest) ChainId(chainId string) ApiV1MetricsAssetListingGetRequest {
	r.chainId = &chainId
	return r
}

// Network identifier
func (r ApiV1MetricsAssetListingGetRequest) NetworkId(networkId string) ApiV1MetricsAssetListingGetRequest {
	r.networkId = &networkId
	return r
}

// Asset identifier (from the Metadata -&gt; Assets)
func (r ApiV1MetricsAssetListingGetRequest) AssetId(assetId string) ApiV1MetricsAssetListingGetRequest {
	r.assetId = &assetId
	return r
}

// The asset external identifier
func (r ApiV1MetricsAssetListingGetRequest) AssetIdExternal(assetIdExternal string) ApiV1MetricsAssetListingGetRequest {
	r.assetIdExternal = &assetIdExternal
	return r
}

func (r ApiV1MetricsAssetListingGetRequest) Execute() ([]V1ListingItem, *http.Response, error) {
	return r.ApiService.V1MetricsAssetListingGetExecute(r)
}

/*
V1MetricsAssetListingGet Listing of all supported metrics for asset

Get data metrics for asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsAssetListingGetRequest
*/
func (a *MetricsV1APIService) V1MetricsAssetListingGet(ctx context.Context) ApiV1MetricsAssetListingGetRequest {
	return ApiV1MetricsAssetListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1ListingItem
func (a *MetricsV1APIService) V1MetricsAssetListingGetExecute(r ApiV1MetricsAssetListingGetRequest) ([]V1ListingItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1ListingItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsAssetListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/asset/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metricId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	}
	if r.exchangeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	}
	if r.chainId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chain_id", r.chainId, "form", "")
	}
	if r.networkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network_id", r.networkId, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id", r.assetId, "form", "")
	}
	if r.assetIdExternal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id_external", r.assetIdExternal, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MetricsExchangeCurrentGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
	exchangeId *string
	metricId *string
}

// The exchange identifier (from the Metadata -&gt; Exchanges)
func (r ApiV1MetricsExchangeCurrentGetRequest) ExchangeId(exchangeId string) ApiV1MetricsExchangeCurrentGetRequest {
	r.exchangeId = &exchangeId
	return r
}

// The metric identifier (from the Metrics -&gt; Listing)
func (r ApiV1MetricsExchangeCurrentGetRequest) MetricId(metricId string) ApiV1MetricsExchangeCurrentGetRequest {
	r.metricId = &metricId
	return r
}

func (r ApiV1MetricsExchangeCurrentGetRequest) Execute() ([]V1GeneralData, *http.Response, error) {
	return r.ApiService.V1MetricsExchangeCurrentGetExecute(r)
}

/*
V1MetricsExchangeCurrentGet Current metrics for given exchange

Get current exchange metrics values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsExchangeCurrentGetRequest
*/
func (a *MetricsV1APIService) V1MetricsExchangeCurrentGet(ctx context.Context) ApiV1MetricsExchangeCurrentGetRequest {
	return ApiV1MetricsExchangeCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1GeneralData
func (a *MetricsV1APIService) V1MetricsExchangeCurrentGetExecute(r ApiV1MetricsExchangeCurrentGetRequest) ([]V1GeneralData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1GeneralData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsExchangeCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/exchange/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	if r.metricId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MetricsExchangeHistoryGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
	metricId *string
	exchangeId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (from the Metrics -&gt; Listing)
func (r ApiV1MetricsExchangeHistoryGetRequest) MetricId(metricId string) ApiV1MetricsExchangeHistoryGetRequest {
	r.metricId = &metricId
	return r
}

// Exchange identifier (from the Metadata -&gt; Exchanges)
func (r ApiV1MetricsExchangeHistoryGetRequest) ExchangeId(exchangeId string) ApiV1MetricsExchangeHistoryGetRequest {
	r.exchangeId = &exchangeId
	return r
}

// Starting time in ISO 8601
func (r ApiV1MetricsExchangeHistoryGetRequest) TimeStart(timeStart time.Time) ApiV1MetricsExchangeHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiV1MetricsExchangeHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV1MetricsExchangeHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiV1MetricsExchangeHistoryGetRequest) TimeFormat(timeFormat string) ApiV1MetricsExchangeHistoryGetRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;
func (r ApiV1MetricsExchangeHistoryGetRequest) PeriodId(periodId string) ApiV1MetricsExchangeHistoryGetRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1MetricsExchangeHistoryGetRequest) Limit(limit int32) ApiV1MetricsExchangeHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1MetricsExchangeHistoryGetRequest) Execute() ([]V1MetricData, *http.Response, error) {
	return r.ApiService.V1MetricsExchangeHistoryGetExecute(r)
}

/*
V1MetricsExchangeHistoryGet Historical metrics for the exchange

Get exchange metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsExchangeHistoryGetRequest
*/
func (a *MetricsV1APIService) V1MetricsExchangeHistoryGet(ctx context.Context) ApiV1MetricsExchangeHistoryGetRequest {
	return ApiV1MetricsExchangeHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricData
func (a *MetricsV1APIService) V1MetricsExchangeHistoryGetExecute(r ApiV1MetricsExchangeHistoryGetRequest) ([]V1MetricData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsExchangeHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/exchange/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MetricsExchangeListingGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
	exchangeId *string
	metricId *string
}

// The exchange identifier (from the Metadata -&gt; Exchanges)
func (r ApiV1MetricsExchangeListingGetRequest) ExchangeId(exchangeId string) ApiV1MetricsExchangeListingGetRequest {
	r.exchangeId = &exchangeId
	return r
}

// The metric identifier (from the Metrics -&gt; Listing)
func (r ApiV1MetricsExchangeListingGetRequest) MetricId(metricId string) ApiV1MetricsExchangeListingGetRequest {
	r.metricId = &metricId
	return r
}

func (r ApiV1MetricsExchangeListingGetRequest) Execute() ([]V1ListingItem, *http.Response, error) {
	return r.ApiService.V1MetricsExchangeListingGetExecute(r)
}

/*
V1MetricsExchangeListingGet Listing of all supported exchange metrics

Get data metrics for exchange.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsExchangeListingGetRequest
*/
func (a *MetricsV1APIService) V1MetricsExchangeListingGet(ctx context.Context) ApiV1MetricsExchangeListingGetRequest {
	return ApiV1MetricsExchangeListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1ListingItem
func (a *MetricsV1APIService) V1MetricsExchangeListingGetExecute(r ApiV1MetricsExchangeListingGetRequest) ([]V1ListingItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1ListingItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsExchangeListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/exchange/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	if r.metricId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MetricsListingGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
}

func (r ApiV1MetricsListingGetRequest) Execute() ([]V1Metric, *http.Response, error) {
	return r.ApiService.V1MetricsListingGetExecute(r)
}

/*
V1MetricsListingGet Listing of all supported metrics by CoinAPI

Get all data metrics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsListingGetRequest
*/
func (a *MetricsV1APIService) V1MetricsListingGet(ctx context.Context) ApiV1MetricsListingGetRequest {
	return ApiV1MetricsListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1Metric
func (a *MetricsV1APIService) V1MetricsListingGetExecute(r ApiV1MetricsListingGetRequest) ([]V1Metric, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1Metric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MetricsSymbolCurrentGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
	metricId *string
	symbolId *string
	exchangeId *string
}

// Metric identifier (from the Metrics -&gt; Listing)
func (r ApiV1MetricsSymbolCurrentGetRequest) MetricId(metricId string) ApiV1MetricsSymbolCurrentGetRequest {
	r.metricId = &metricId
	return r
}

// Symbol identifier (from the Metadata -&gt; Symbols)
func (r ApiV1MetricsSymbolCurrentGetRequest) SymbolId(symbolId string) ApiV1MetricsSymbolCurrentGetRequest {
	r.symbolId = &symbolId
	return r
}

// Exchange id (from the Metadata -&gt; Exchanges)
func (r ApiV1MetricsSymbolCurrentGetRequest) ExchangeId(exchangeId string) ApiV1MetricsSymbolCurrentGetRequest {
	r.exchangeId = &exchangeId
	return r
}

func (r ApiV1MetricsSymbolCurrentGetRequest) Execute() ([]V1GeneralData, *http.Response, error) {
	return r.ApiService.V1MetricsSymbolCurrentGetExecute(r)
}

/*
V1MetricsSymbolCurrentGet Current metrics for given symbol

Get current symbol metrics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsSymbolCurrentGetRequest
*/
func (a *MetricsV1APIService) V1MetricsSymbolCurrentGet(ctx context.Context) ApiV1MetricsSymbolCurrentGetRequest {
	return ApiV1MetricsSymbolCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1GeneralData
func (a *MetricsV1APIService) V1MetricsSymbolCurrentGetExecute(r ApiV1MetricsSymbolCurrentGetRequest) ([]V1GeneralData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1GeneralData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsSymbolCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/symbol/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metricId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	}
	if r.symbolId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol_id", r.symbolId, "form", "")
	}
	if r.exchangeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MetricsSymbolHistoryGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
	metricId *string
	symbolId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (from the Metrics -&gt; Listing)
func (r ApiV1MetricsSymbolHistoryGetRequest) MetricId(metricId string) ApiV1MetricsSymbolHistoryGetRequest {
	r.metricId = &metricId
	return r
}

// Symbol identifier (from the Metadata -&gt; Symbols)
func (r ApiV1MetricsSymbolHistoryGetRequest) SymbolId(symbolId string) ApiV1MetricsSymbolHistoryGetRequest {
	r.symbolId = &symbolId
	return r
}

// Starting time in ISO 8601
func (r ApiV1MetricsSymbolHistoryGetRequest) TimeStart(timeStart time.Time) ApiV1MetricsSymbolHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiV1MetricsSymbolHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV1MetricsSymbolHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiV1MetricsSymbolHistoryGetRequest) TimeFormat(timeFormat string) ApiV1MetricsSymbolHistoryGetRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;
func (r ApiV1MetricsSymbolHistoryGetRequest) PeriodId(periodId string) ApiV1MetricsSymbolHistoryGetRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1MetricsSymbolHistoryGetRequest) Limit(limit int32) ApiV1MetricsSymbolHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1MetricsSymbolHistoryGetRequest) Execute() ([]V1MetricData, *http.Response, error) {
	return r.ApiService.V1MetricsSymbolHistoryGetExecute(r)
}

/*
V1MetricsSymbolHistoryGet Historical metrics for symbol

Get symbol metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsSymbolHistoryGetRequest
*/
func (a *MetricsV1APIService) V1MetricsSymbolHistoryGet(ctx context.Context) ApiV1MetricsSymbolHistoryGetRequest {
	return ApiV1MetricsSymbolHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricData
func (a *MetricsV1APIService) V1MetricsSymbolHistoryGetExecute(r ApiV1MetricsSymbolHistoryGetRequest) ([]V1MetricData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsSymbolHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/symbol/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.symbolId == nil {
		return localVarReturnValue, nil, reportError("symbolId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol_id", r.symbolId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MetricsSymbolListingGetRequest struct {
	ctx context.Context
	ApiService *MetricsV1APIService
	metricId *string
	exchangeId *string
	symbolId *string
}

// Metric identifier (from the Metrics -&gt; Listing)
func (r ApiV1MetricsSymbolListingGetRequest) MetricId(metricId string) ApiV1MetricsSymbolListingGetRequest {
	r.metricId = &metricId
	return r
}

// Exchange identifier (from the Metadata -&gt; Exchanges)
func (r ApiV1MetricsSymbolListingGetRequest) ExchangeId(exchangeId string) ApiV1MetricsSymbolListingGetRequest {
	r.exchangeId = &exchangeId
	return r
}

// Symbol identifier (from the Metadata -&gt; Symbols)
func (r ApiV1MetricsSymbolListingGetRequest) SymbolId(symbolId string) ApiV1MetricsSymbolListingGetRequest {
	r.symbolId = &symbolId
	return r
}

func (r ApiV1MetricsSymbolListingGetRequest) Execute() ([]V1ListingItem, *http.Response, error) {
	return r.ApiService.V1MetricsSymbolListingGetExecute(r)
}

/*
V1MetricsSymbolListingGet Listing of all supported metrics for symbol

Get data metrics for symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MetricsSymbolListingGetRequest
*/
func (a *MetricsV1APIService) V1MetricsSymbolListingGet(ctx context.Context) ApiV1MetricsSymbolListingGetRequest {
	return ApiV1MetricsSymbolListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1ListingItem
func (a *MetricsV1APIService) V1MetricsSymbolListingGetExecute(r ApiV1MetricsSymbolListingGetRequest) ([]V1ListingItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1ListingItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV1APIService.V1MetricsSymbolListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/symbol/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metricId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	}
	if r.exchangeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	}
	if r.symbolId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol_id", r.symbolId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
