/*
CoinAPI Market Data REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: support@apibricks.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OrderBookAPIService OrderBookAPI service
type OrderBookAPIService service

type ApiV1OrderbooksSymbolIdCurrentGetRequest struct {
	ctx context.Context
	ApiService *OrderBookAPIService
	symbolId string
	limitLevels *int32
}

// The maximum number of levels to include in the response.
func (r ApiV1OrderbooksSymbolIdCurrentGetRequest) LimitLevels(limitLevels int32) ApiV1OrderbooksSymbolIdCurrentGetRequest {
	r.limitLevels = &limitLevels
	return r
}

func (r ApiV1OrderbooksSymbolIdCurrentGetRequest) Execute() (*V1OrderBookBase, *http.Response, error) {
	return r.ApiService.V1OrderbooksSymbolIdCurrentGetExecute(r)
}

/*
V1OrderbooksSymbolIdCurrentGet Get current order book

Retrieves the current order book for the specified symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbolId The symbol ID (from the Metadata -> Symbols)
 @return ApiV1OrderbooksSymbolIdCurrentGetRequest
*/
func (a *OrderBookAPIService) V1OrderbooksSymbolIdCurrentGet(ctx context.Context, symbolId string) ApiV1OrderbooksSymbolIdCurrentGetRequest {
	return ApiV1OrderbooksSymbolIdCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		symbolId: symbolId,
	}
}

// Execute executes the request
//  @return V1OrderBookBase
func (a *OrderBookAPIService) V1OrderbooksSymbolIdCurrentGetExecute(r ApiV1OrderbooksSymbolIdCurrentGetRequest) (*V1OrderBookBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1OrderBookBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderBookAPIService.V1OrderbooksSymbolIdCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/orderbooks/{symbol_id}/current"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol_id"+"}", url.PathEscape(parameterValueToString(r.symbolId, "symbolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limitLevels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit_levels", r.limitLevels, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OrderbooksSymbolIdDepthCurrentGetRequest struct {
	ctx context.Context
	ApiService *OrderBookAPIService
	symbolId string
	limitLevels *int32
}

// The maximum number of levels to include in the response.
func (r ApiV1OrderbooksSymbolIdDepthCurrentGetRequest) LimitLevels(limitLevels int32) ApiV1OrderbooksSymbolIdDepthCurrentGetRequest {
	r.limitLevels = &limitLevels
	return r
}

func (r ApiV1OrderbooksSymbolIdDepthCurrentGetRequest) Execute() (*V1OrderBookDepth, *http.Response, error) {
	return r.ApiService.V1OrderbooksSymbolIdDepthCurrentGetExecute(r)
}

/*
V1OrderbooksSymbolIdDepthCurrentGet Current depth of the order book

Retrieves the current depth of the order book for the specified symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbolId The symbol ID (from the Metadata -> Symbols)
 @return ApiV1OrderbooksSymbolIdDepthCurrentGetRequest
*/
func (a *OrderBookAPIService) V1OrderbooksSymbolIdDepthCurrentGet(ctx context.Context, symbolId string) ApiV1OrderbooksSymbolIdDepthCurrentGetRequest {
	return ApiV1OrderbooksSymbolIdDepthCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		symbolId: symbolId,
	}
}

// Execute executes the request
//  @return V1OrderBookDepth
func (a *OrderBookAPIService) V1OrderbooksSymbolIdDepthCurrentGetExecute(r ApiV1OrderbooksSymbolIdDepthCurrentGetRequest) (*V1OrderBookDepth, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1OrderBookDepth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderBookAPIService.V1OrderbooksSymbolIdDepthCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/orderbooks/{symbol_id}/depth/current"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol_id"+"}", url.PathEscape(parameterValueToString(r.symbolId, "symbolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limitLevels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit_levels", r.limitLevels, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OrderbooksSymbolIdHistoryGetRequest struct {
	ctx context.Context
	ApiService *OrderBookAPIService
	symbolId string
	date *string
	timeStart *string
	timeEnd *string
	limit *int32
	limitLevels *int32
}

// Date in ISO 8601, returned data is for the whole given day (preferred method, required if &#39;time_start&#39; is not provided)
func (r ApiV1OrderbooksSymbolIdHistoryGetRequest) Date(date string) ApiV1OrderbooksSymbolIdHistoryGetRequest {
	r.date = &date
	return r
}

// Starting time in ISO 8601 (deprecated, use &#39;date&#39; instead)
func (r ApiV1OrderbooksSymbolIdHistoryGetRequest) TimeStart(timeStart string) ApiV1OrderbooksSymbolIdHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Timeseries ending time in ISO 8601 (deprecated, use &#39;date&#39; instead)
func (r ApiV1OrderbooksSymbolIdHistoryGetRequest) TimeEnd(timeEnd string) ApiV1OrderbooksSymbolIdHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1OrderbooksSymbolIdHistoryGetRequest) Limit(limit int32) ApiV1OrderbooksSymbolIdHistoryGetRequest {
	r.limit = &limit
	return r
}

// Maximum amount of levels from each side of the book to include in response (optional)
func (r ApiV1OrderbooksSymbolIdHistoryGetRequest) LimitLevels(limitLevels int32) ApiV1OrderbooksSymbolIdHistoryGetRequest {
	r.limitLevels = &limitLevels
	return r
}

func (r ApiV1OrderbooksSymbolIdHistoryGetRequest) Execute() ([]V1OrderBook, *http.Response, error) {
	return r.ApiService.V1OrderbooksSymbolIdHistoryGetExecute(r)
}

/*
V1OrderbooksSymbolIdHistoryGet Historical data

Get historical order book snapshots for a specific symbol within time range, returned in time ascending order.
            
:::info
The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels.
:::

:::warning
The 'time_start' and 'time_end' parameters must be from the same day as this endpoint provides intraday data only for specific day.
Please use the 'date' parameter instead for querying data for a specific day without filter.
:::

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbolId Symbol identifier for requested timeseries (from the Metadata -> Symbols)
 @return ApiV1OrderbooksSymbolIdHistoryGetRequest
*/
func (a *OrderBookAPIService) V1OrderbooksSymbolIdHistoryGet(ctx context.Context, symbolId string) ApiV1OrderbooksSymbolIdHistoryGetRequest {
	return ApiV1OrderbooksSymbolIdHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
		symbolId: symbolId,
	}
}

// Execute executes the request
//  @return []V1OrderBook
func (a *OrderBookAPIService) V1OrderbooksSymbolIdHistoryGetExecute(r ApiV1OrderbooksSymbolIdHistoryGetRequest) ([]V1OrderBook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1OrderBook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderBookAPIService.V1OrderbooksSymbolIdHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/orderbooks/{symbol_id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol_id"+"}", url.PathEscape(parameterValueToString(r.symbolId, "symbolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.limitLevels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit_levels", r.limitLevels, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OrderbooksSymbolIdLatestGetRequest struct {
	ctx context.Context
	ApiService *OrderBookAPIService
	symbolId string
	limit *int32
	limitLevels *int32
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1OrderbooksSymbolIdLatestGetRequest) Limit(limit int32) ApiV1OrderbooksSymbolIdLatestGetRequest {
	r.limit = &limit
	return r
}

// Maximum amount of levels from each side of the book to include in response (optional)
func (r ApiV1OrderbooksSymbolIdLatestGetRequest) LimitLevels(limitLevels int32) ApiV1OrderbooksSymbolIdLatestGetRequest {
	r.limitLevels = &limitLevels
	return r
}

func (r ApiV1OrderbooksSymbolIdLatestGetRequest) Execute() ([]V1OrderBook, *http.Response, error) {
	return r.ApiService.V1OrderbooksSymbolIdLatestGetExecute(r)
}

/*
V1OrderbooksSymbolIdLatestGet Latest data

Get latest order book snapshots for a specific symbol, returned in time descending order.
            
:::info
The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels.
:::

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbolId Symbol identifier of requested timeseries (from the Metadata -> Symbols)
 @return ApiV1OrderbooksSymbolIdLatestGetRequest
*/
func (a *OrderBookAPIService) V1OrderbooksSymbolIdLatestGet(ctx context.Context, symbolId string) ApiV1OrderbooksSymbolIdLatestGetRequest {
	return ApiV1OrderbooksSymbolIdLatestGetRequest{
		ApiService: a,
		ctx: ctx,
		symbolId: symbolId,
	}
}

// Execute executes the request
//  @return []V1OrderBook
func (a *OrderBookAPIService) V1OrderbooksSymbolIdLatestGetExecute(r ApiV1OrderbooksSymbolIdLatestGetRequest) ([]V1OrderBook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1OrderBook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderBookAPIService.V1OrderbooksSymbolIdLatestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/orderbooks/{symbol_id}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol_id"+"}", url.PathEscape(parameterValueToString(r.symbolId, "symbolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.limitLevels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit_levels", r.limitLevels, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
