/*
REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: support@apibricks.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// QuotesAPIService QuotesAPI service
type QuotesAPIService service

type ApiV1QuotesCurrentGetRequest struct {
	ctx context.Context
	ApiService *QuotesAPIService
	filterSymbolId *string
}

// Comma or semicolon delimited parts of symbol identifier used to filter response. (optional)
func (r ApiV1QuotesCurrentGetRequest) FilterSymbolId(filterSymbolId string) ApiV1QuotesCurrentGetRequest {
	r.filterSymbolId = &filterSymbolId
	return r
}

func (r ApiV1QuotesCurrentGetRequest) Execute() ([]V1QuoteTrade, *http.Response, error) {
	return r.ApiService.V1QuotesCurrentGetExecute(r)
}

/*
V1QuotesCurrentGet Current data

Get current quotes for all symbols or for a specific symbol.
            
:::info
When requesting current data for a specific symbol, output is not encapsulated into JSON array as only one item is returned.
:::

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1QuotesCurrentGetRequest
*/
func (a *QuotesAPIService) V1QuotesCurrentGet(ctx context.Context) ApiV1QuotesCurrentGetRequest {
	return ApiV1QuotesCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1QuoteTrade
func (a *QuotesAPIService) V1QuotesCurrentGetExecute(r ApiV1QuotesCurrentGetRequest) ([]V1QuoteTrade, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1QuoteTrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QuotesAPIService.V1QuotesCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/quotes/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterSymbolId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_symbol_id", r.filterSymbolId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1QuotesLatestGetRequest struct {
	ctx context.Context
	ApiService *QuotesAPIService
	filterSymbolId *string
	limit *int32
}

// Comma or semicolon delimited parts of symbol identifier used to filter response. (optional)
func (r ApiV1QuotesLatestGetRequest) FilterSymbolId(filterSymbolId string) ApiV1QuotesLatestGetRequest {
	r.filterSymbolId = &filterSymbolId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1QuotesLatestGetRequest) Limit(limit int32) ApiV1QuotesLatestGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1QuotesLatestGetRequest) Execute() ([]V1Quote, *http.Response, error) {
	return r.ApiService.V1QuotesLatestGetExecute(r)
}

/*
V1QuotesLatestGet Latest data

Get latest updates of the quotes up to 1 minute ago. Latest data is always returned in time descending order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1QuotesLatestGetRequest
*/
func (a *QuotesAPIService) V1QuotesLatestGet(ctx context.Context) ApiV1QuotesLatestGetRequest {
	return ApiV1QuotesLatestGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1Quote
func (a *QuotesAPIService) V1QuotesLatestGetExecute(r ApiV1QuotesLatestGetRequest) ([]V1Quote, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1Quote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QuotesAPIService.V1QuotesLatestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/quotes/latest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterSymbolId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_symbol_id", r.filterSymbolId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1QuotesSymbolIdCurrentGetRequest struct {
	ctx context.Context
	ApiService *QuotesAPIService
	symbolId string
}

func (r ApiV1QuotesSymbolIdCurrentGetRequest) Execute() (*V1QuoteTrade, *http.Response, error) {
	return r.ApiService.V1QuotesSymbolIdCurrentGetExecute(r)
}

/*
V1QuotesSymbolIdCurrentGet Current quotes for a specific symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbolId The symbol identifier (from the Metadata -> Symbols)
 @return ApiV1QuotesSymbolIdCurrentGetRequest
*/
func (a *QuotesAPIService) V1QuotesSymbolIdCurrentGet(ctx context.Context, symbolId string) ApiV1QuotesSymbolIdCurrentGetRequest {
	return ApiV1QuotesSymbolIdCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		symbolId: symbolId,
	}
}

// Execute executes the request
//  @return V1QuoteTrade
func (a *QuotesAPIService) V1QuotesSymbolIdCurrentGetExecute(r ApiV1QuotesSymbolIdCurrentGetRequest) (*V1QuoteTrade, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1QuoteTrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QuotesAPIService.V1QuotesSymbolIdCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/quotes/{symbol_id}/current"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol_id"+"}", url.PathEscape(parameterValueToString(r.symbolId, "symbolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1QuotesSymbolIdHistoryGetRequest struct {
	ctx context.Context
	ApiService *QuotesAPIService
	symbolId string
	date *string
	timeStart *string
	timeEnd *string
	limit *int32
}

// Date in ISO 8601, returned data is for the whole given day (preferred method, required if &#39;time_start&#39; is not provided)
func (r ApiV1QuotesSymbolIdHistoryGetRequest) Date(date string) ApiV1QuotesSymbolIdHistoryGetRequest {
	r.date = &date
	return r
}

// Starting time in ISO 8601
func (r ApiV1QuotesSymbolIdHistoryGetRequest) TimeStart(timeStart string) ApiV1QuotesSymbolIdHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Timeseries ending time in ISO 8601
func (r ApiV1QuotesSymbolIdHistoryGetRequest) TimeEnd(timeEnd string) ApiV1QuotesSymbolIdHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1QuotesSymbolIdHistoryGetRequest) Limit(limit int32) ApiV1QuotesSymbolIdHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1QuotesSymbolIdHistoryGetRequest) Execute() ([]V1Quote, *http.Response, error) {
	return r.ApiService.V1QuotesSymbolIdHistoryGetExecute(r)
}

/*
V1QuotesSymbolIdHistoryGet Historical data

Get historical quote updates within requested time range, returned in time ascending order.

:::warning
The 'time_start' and 'time_end' parameters must be from the same day as this endpoint provides intraday data only for specific day.
Please use the 'date' parameter instead for querying data for a specific day without filter.
:::

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbolId Symbol identifier for requested timeseries (from the Metadata -> Symbols)
 @return ApiV1QuotesSymbolIdHistoryGetRequest
*/
func (a *QuotesAPIService) V1QuotesSymbolIdHistoryGet(ctx context.Context, symbolId string) ApiV1QuotesSymbolIdHistoryGetRequest {
	return ApiV1QuotesSymbolIdHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
		symbolId: symbolId,
	}
}

// Execute executes the request
//  @return []V1Quote
func (a *QuotesAPIService) V1QuotesSymbolIdHistoryGetExecute(r ApiV1QuotesSymbolIdHistoryGetRequest) ([]V1Quote, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1Quote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QuotesAPIService.V1QuotesSymbolIdHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/quotes/{symbol_id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol_id"+"}", url.PathEscape(parameterValueToString(r.symbolId, "symbolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1QuotesSymbolIdLatestGetRequest struct {
	ctx context.Context
	ApiService *QuotesAPIService
	symbolId string
	limit *int32
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1QuotesSymbolIdLatestGetRequest) Limit(limit int32) ApiV1QuotesSymbolIdLatestGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1QuotesSymbolIdLatestGetRequest) Execute() ([]V1Quote, *http.Response, error) {
	return r.ApiService.V1QuotesSymbolIdLatestGetExecute(r)
}

/*
V1QuotesSymbolIdLatestGet Latest quote updates for a specific symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbolId Symbol identifier of requested timeseries (from the Metadata -> Symbols)
 @return ApiV1QuotesSymbolIdLatestGetRequest
*/
func (a *QuotesAPIService) V1QuotesSymbolIdLatestGet(ctx context.Context, symbolId string) ApiV1QuotesSymbolIdLatestGetRequest {
	return ApiV1QuotesSymbolIdLatestGetRequest{
		ApiService: a,
		ctx: ctx,
		symbolId: symbolId,
	}
}

// Execute executes the request
//  @return []V1Quote
func (a *QuotesAPIService) V1QuotesSymbolIdLatestGetExecute(r ApiV1QuotesSymbolIdLatestGetRequest) ([]V1Quote, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1Quote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QuotesAPIService.V1QuotesSymbolIdLatestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/quotes/{symbol_id}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol_id"+"}", url.PathEscape(parameterValueToString(r.symbolId, "symbolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
