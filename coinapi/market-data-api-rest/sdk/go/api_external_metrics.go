/*
CoinAPI Market Data REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: support@apibricks.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)


// ExternalMetricsAPIService ExternalMetricsAPI service
type ExternalMetricsAPIService service

type ApiV1ExternalmetricsAssetHistoryGetRequest struct {
	ctx context.Context
	ApiService *ExternalMetricsAPIService
	metricId *string
	assetId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
func (r ApiV1ExternalmetricsAssetHistoryGetRequest) MetricId(metricId string) ApiV1ExternalmetricsAssetHistoryGetRequest {
	r.metricId = &metricId
	return r
}

// Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
func (r ApiV1ExternalmetricsAssetHistoryGetRequest) AssetId(assetId string) ApiV1ExternalmetricsAssetHistoryGetRequest {
	r.assetId = &assetId
	return r
}

// Starting time in ISO 8601
func (r ApiV1ExternalmetricsAssetHistoryGetRequest) TimeStart(timeStart time.Time) ApiV1ExternalmetricsAssetHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiV1ExternalmetricsAssetHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV1ExternalmetricsAssetHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiV1ExternalmetricsAssetHistoryGetRequest) TimeFormat(timeFormat string) ApiV1ExternalmetricsAssetHistoryGetRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
func (r ApiV1ExternalmetricsAssetHistoryGetRequest) PeriodId(periodId string) ApiV1ExternalmetricsAssetHistoryGetRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1ExternalmetricsAssetHistoryGetRequest) Limit(limit int32) ApiV1ExternalmetricsAssetHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1ExternalmetricsAssetHistoryGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExternalmetricsAssetHistoryGetExecute(r)
}

/*
V1ExternalmetricsAssetHistoryGet Historical metrics for the asset

Get asset metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExternalmetricsAssetHistoryGetRequest
*/
func (a *ExternalMetricsAPIService) V1ExternalmetricsAssetHistoryGet(ctx context.Context) ApiV1ExternalmetricsAssetHistoryGetRequest {
	return ApiV1ExternalmetricsAssetHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ExternalMetricsAPIService) V1ExternalmetricsAssetHistoryGetExecute(r ApiV1ExternalmetricsAssetHistoryGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalMetricsAPIService.V1ExternalmetricsAssetHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/externalmetrics/asset/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id", r.assetId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExternalmetricsAssetListingGetRequest struct {
	ctx context.Context
	ApiService *ExternalMetricsAPIService
	assetId *string
}

// Asset identifier (e.g., USDC, USDT)
func (r ApiV1ExternalmetricsAssetListingGetRequest) AssetId(assetId string) ApiV1ExternalmetricsAssetListingGetRequest {
	r.assetId = &assetId
	return r
}

func (r ApiV1ExternalmetricsAssetListingGetRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.V1ExternalmetricsAssetListingGetExecute(r)
}

/*
V1ExternalmetricsAssetListingGet Listing of metrics available for specific asset

Get all metrics that are actually available for the specified asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExternalmetricsAssetListingGetRequest
*/
func (a *ExternalMetricsAPIService) V1ExternalmetricsAssetListingGet(ctx context.Context) ApiV1ExternalmetricsAssetListingGetRequest {
	return ApiV1ExternalmetricsAssetListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *ExternalMetricsAPIService) V1ExternalmetricsAssetListingGetExecute(r ApiV1ExternalmetricsAssetListingGetRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalMetricsAPIService.V1ExternalmetricsAssetListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/externalmetrics/asset/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id", r.assetId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExternalmetricsChainHistoryGetRequest struct {
	ctx context.Context
	ApiService *ExternalMetricsAPIService
	metricId *string
	chainId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
func (r ApiV1ExternalmetricsChainHistoryGetRequest) MetricId(metricId string) ApiV1ExternalmetricsChainHistoryGetRequest {
	r.metricId = &metricId
	return r
}

// Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
func (r ApiV1ExternalmetricsChainHistoryGetRequest) ChainId(chainId string) ApiV1ExternalmetricsChainHistoryGetRequest {
	r.chainId = &chainId
	return r
}

// Starting time in ISO 8601
func (r ApiV1ExternalmetricsChainHistoryGetRequest) TimeStart(timeStart time.Time) ApiV1ExternalmetricsChainHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiV1ExternalmetricsChainHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV1ExternalmetricsChainHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiV1ExternalmetricsChainHistoryGetRequest) TimeFormat(timeFormat string) ApiV1ExternalmetricsChainHistoryGetRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
func (r ApiV1ExternalmetricsChainHistoryGetRequest) PeriodId(periodId string) ApiV1ExternalmetricsChainHistoryGetRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1ExternalmetricsChainHistoryGetRequest) Limit(limit int32) ApiV1ExternalmetricsChainHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1ExternalmetricsChainHistoryGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExternalmetricsChainHistoryGetExecute(r)
}

/*
V1ExternalmetricsChainHistoryGet Historical metrics for the chain

Get chain metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExternalmetricsChainHistoryGetRequest
*/
func (a *ExternalMetricsAPIService) V1ExternalmetricsChainHistoryGet(ctx context.Context) ApiV1ExternalmetricsChainHistoryGetRequest {
	return ApiV1ExternalmetricsChainHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ExternalMetricsAPIService) V1ExternalmetricsChainHistoryGetExecute(r ApiV1ExternalmetricsChainHistoryGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalMetricsAPIService.V1ExternalmetricsChainHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/externalmetrics/chain/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.chainId == nil {
		return localVarReturnValue, nil, reportError("chainId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "chain_id", r.chainId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExternalmetricsChainListingGetRequest struct {
	ctx context.Context
	ApiService *ExternalMetricsAPIService
	chainId *string
}

// Chain identifier (e.g., ETHEREUM, ARBITRUM)
func (r ApiV1ExternalmetricsChainListingGetRequest) ChainId(chainId string) ApiV1ExternalmetricsChainListingGetRequest {
	r.chainId = &chainId
	return r
}

func (r ApiV1ExternalmetricsChainListingGetRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.V1ExternalmetricsChainListingGetExecute(r)
}

/*
V1ExternalmetricsChainListingGet Listing of metrics available for specific chain

Get all metrics that are actually available for the specified blockchain chain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExternalmetricsChainListingGetRequest
*/
func (a *ExternalMetricsAPIService) V1ExternalmetricsChainListingGet(ctx context.Context) ApiV1ExternalmetricsChainListingGetRequest {
	return ApiV1ExternalmetricsChainListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *ExternalMetricsAPIService) V1ExternalmetricsChainListingGetExecute(r ApiV1ExternalmetricsChainListingGetRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalMetricsAPIService.V1ExternalmetricsChainListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/externalmetrics/chain/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chainId == nil {
		return localVarReturnValue, nil, reportError("chainId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chain_id", r.chainId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExternalmetricsExchangeHistoryGetRequest struct {
	ctx context.Context
	ApiService *ExternalMetricsAPIService
	metricId *string
	exchangeId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
func (r ApiV1ExternalmetricsExchangeHistoryGetRequest) MetricId(metricId string) ApiV1ExternalmetricsExchangeHistoryGetRequest {
	r.metricId = &metricId
	return r
}

// Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
func (r ApiV1ExternalmetricsExchangeHistoryGetRequest) ExchangeId(exchangeId string) ApiV1ExternalmetricsExchangeHistoryGetRequest {
	r.exchangeId = &exchangeId
	return r
}

// Starting time in ISO 8601
func (r ApiV1ExternalmetricsExchangeHistoryGetRequest) TimeStart(timeStart time.Time) ApiV1ExternalmetricsExchangeHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiV1ExternalmetricsExchangeHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV1ExternalmetricsExchangeHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiV1ExternalmetricsExchangeHistoryGetRequest) TimeFormat(timeFormat string) ApiV1ExternalmetricsExchangeHistoryGetRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
func (r ApiV1ExternalmetricsExchangeHistoryGetRequest) PeriodId(periodId string) ApiV1ExternalmetricsExchangeHistoryGetRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1ExternalmetricsExchangeHistoryGetRequest) Limit(limit int32) ApiV1ExternalmetricsExchangeHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1ExternalmetricsExchangeHistoryGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExternalmetricsExchangeHistoryGetExecute(r)
}

/*
V1ExternalmetricsExchangeHistoryGet Historical metrics for the exchange

Get exchange metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExternalmetricsExchangeHistoryGetRequest
*/
func (a *ExternalMetricsAPIService) V1ExternalmetricsExchangeHistoryGet(ctx context.Context) ApiV1ExternalmetricsExchangeHistoryGetRequest {
	return ApiV1ExternalmetricsExchangeHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ExternalMetricsAPIService) V1ExternalmetricsExchangeHistoryGetExecute(r ApiV1ExternalmetricsExchangeHistoryGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalMetricsAPIService.V1ExternalmetricsExchangeHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/externalmetrics/exchange/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExternalmetricsExchangeListingGetRequest struct {
	ctx context.Context
	ApiService *ExternalMetricsAPIService
	exchangeId *string
}

// Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
func (r ApiV1ExternalmetricsExchangeListingGetRequest) ExchangeId(exchangeId string) ApiV1ExternalmetricsExchangeListingGetRequest {
	r.exchangeId = &exchangeId
	return r
}

func (r ApiV1ExternalmetricsExchangeListingGetRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.V1ExternalmetricsExchangeListingGetExecute(r)
}

/*
V1ExternalmetricsExchangeListingGet Listing of metrics available for specific exchange

Get all metrics that are actually available for the specified exchange.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExternalmetricsExchangeListingGetRequest
*/
func (a *ExternalMetricsAPIService) V1ExternalmetricsExchangeListingGet(ctx context.Context) ApiV1ExternalmetricsExchangeListingGetRequest {
	return ApiV1ExternalmetricsExchangeListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *ExternalMetricsAPIService) V1ExternalmetricsExchangeListingGetExecute(r ApiV1ExternalmetricsExchangeListingGetRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalMetricsAPIService.V1ExternalmetricsExchangeListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/externalmetrics/exchange/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExternalmetricsListingGetRequest struct {
	ctx context.Context
	ApiService *ExternalMetricsAPIService
}

func (r ApiV1ExternalmetricsListingGetRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.V1ExternalmetricsListingGetExecute(r)
}

/*
V1ExternalmetricsListingGet Listing of all supported metrics

Get all metrics available in the system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExternalmetricsListingGetRequest
*/
func (a *ExternalMetricsAPIService) V1ExternalmetricsListingGet(ctx context.Context) ApiV1ExternalmetricsListingGetRequest {
	return ApiV1ExternalmetricsListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *ExternalMetricsAPIService) V1ExternalmetricsListingGetExecute(r ApiV1ExternalmetricsListingGetRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalMetricsAPIService.V1ExternalmetricsListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/externalmetrics/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
