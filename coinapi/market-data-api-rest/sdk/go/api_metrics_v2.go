/*
CoinAPI Market Data REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: support@apibricks.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)


// MetricsV2APIService MetricsV2API service
type MetricsV2APIService service

type ApiV2MetricsAssetHistoryGetRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	metricId *string
	assetId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
func (r ApiV2MetricsAssetHistoryGetRequest) MetricId(metricId string) ApiV2MetricsAssetHistoryGetRequest {
	r.metricId = &metricId
	return r
}

// Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
func (r ApiV2MetricsAssetHistoryGetRequest) AssetId(assetId string) ApiV2MetricsAssetHistoryGetRequest {
	r.assetId = &assetId
	return r
}

// Starting time in ISO 8601
func (r ApiV2MetricsAssetHistoryGetRequest) TimeStart(timeStart time.Time) ApiV2MetricsAssetHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiV2MetricsAssetHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV2MetricsAssetHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiV2MetricsAssetHistoryGetRequest) TimeFormat(timeFormat string) ApiV2MetricsAssetHistoryGetRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
func (r ApiV2MetricsAssetHistoryGetRequest) PeriodId(periodId string) ApiV2MetricsAssetHistoryGetRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV2MetricsAssetHistoryGetRequest) Limit(limit int32) ApiV2MetricsAssetHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2MetricsAssetHistoryGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2MetricsAssetHistoryGetExecute(r)
}

/*
V2MetricsAssetHistoryGet Historical metrics for the asset

Get asset metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MetricsAssetHistoryGetRequest
*/
func (a *MetricsV2APIService) V2MetricsAssetHistoryGet(ctx context.Context) ApiV2MetricsAssetHistoryGetRequest {
	return ApiV2MetricsAssetHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MetricsV2APIService) V2MetricsAssetHistoryGetExecute(r ApiV2MetricsAssetHistoryGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.V2MetricsAssetHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/asset/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id", r.assetId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MetricsAssetListingGetRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	assetId *string
}

// Asset identifier (e.g., USDC, USDT)
func (r ApiV2MetricsAssetListingGetRequest) AssetId(assetId string) ApiV2MetricsAssetListingGetRequest {
	r.assetId = &assetId
	return r
}

func (r ApiV2MetricsAssetListingGetRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.V2MetricsAssetListingGetExecute(r)
}

/*
V2MetricsAssetListingGet Listing of metrics available for specific asset

Get all metrics that are actually available for the specified asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MetricsAssetListingGetRequest
*/
func (a *MetricsV2APIService) V2MetricsAssetListingGet(ctx context.Context) ApiV2MetricsAssetListingGetRequest {
	return ApiV2MetricsAssetListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *MetricsV2APIService) V2MetricsAssetListingGetExecute(r ApiV2MetricsAssetListingGetRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.V2MetricsAssetListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/asset/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset_id", r.assetId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MetricsChainHistoryGetRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	metricId *string
	chainId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
func (r ApiV2MetricsChainHistoryGetRequest) MetricId(metricId string) ApiV2MetricsChainHistoryGetRequest {
	r.metricId = &metricId
	return r
}

// Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
func (r ApiV2MetricsChainHistoryGetRequest) ChainId(chainId string) ApiV2MetricsChainHistoryGetRequest {
	r.chainId = &chainId
	return r
}

// Starting time in ISO 8601
func (r ApiV2MetricsChainHistoryGetRequest) TimeStart(timeStart time.Time) ApiV2MetricsChainHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiV2MetricsChainHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV2MetricsChainHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiV2MetricsChainHistoryGetRequest) TimeFormat(timeFormat string) ApiV2MetricsChainHistoryGetRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
func (r ApiV2MetricsChainHistoryGetRequest) PeriodId(periodId string) ApiV2MetricsChainHistoryGetRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV2MetricsChainHistoryGetRequest) Limit(limit int32) ApiV2MetricsChainHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2MetricsChainHistoryGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2MetricsChainHistoryGetExecute(r)
}

/*
V2MetricsChainHistoryGet Historical metrics for the chain

Get chain metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MetricsChainHistoryGetRequest
*/
func (a *MetricsV2APIService) V2MetricsChainHistoryGet(ctx context.Context) ApiV2MetricsChainHistoryGetRequest {
	return ApiV2MetricsChainHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MetricsV2APIService) V2MetricsChainHistoryGetExecute(r ApiV2MetricsChainHistoryGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.V2MetricsChainHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/chain/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.chainId == nil {
		return localVarReturnValue, nil, reportError("chainId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "chain_id", r.chainId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MetricsChainListingGetRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	chainId *string
}

// Chain identifier (e.g., ETHEREUM, ARBITRUM)
func (r ApiV2MetricsChainListingGetRequest) ChainId(chainId string) ApiV2MetricsChainListingGetRequest {
	r.chainId = &chainId
	return r
}

func (r ApiV2MetricsChainListingGetRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.V2MetricsChainListingGetExecute(r)
}

/*
V2MetricsChainListingGet Listing of metrics available for specific chain

Get all metrics that are actually available for the specified blockchain chain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MetricsChainListingGetRequest
*/
func (a *MetricsV2APIService) V2MetricsChainListingGet(ctx context.Context) ApiV2MetricsChainListingGetRequest {
	return ApiV2MetricsChainListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *MetricsV2APIService) V2MetricsChainListingGetExecute(r ApiV2MetricsChainListingGetRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.V2MetricsChainListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/chain/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chainId == nil {
		return localVarReturnValue, nil, reportError("chainId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chain_id", r.chainId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MetricsExchangeHistoryGetRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	metricId *string
	exchangeId *string
	timeStart *time.Time
	timeEnd *time.Time
	timeFormat *string
	periodId *string
	limit *int32
}

// Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
func (r ApiV2MetricsExchangeHistoryGetRequest) MetricId(metricId string) ApiV2MetricsExchangeHistoryGetRequest {
	r.metricId = &metricId
	return r
}

// Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
func (r ApiV2MetricsExchangeHistoryGetRequest) ExchangeId(exchangeId string) ApiV2MetricsExchangeHistoryGetRequest {
	r.exchangeId = &exchangeId
	return r
}

// Starting time in ISO 8601
func (r ApiV2MetricsExchangeHistoryGetRequest) TimeStart(timeStart time.Time) ApiV2MetricsExchangeHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

// Ending time in ISO 8601
func (r ApiV2MetricsExchangeHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV2MetricsExchangeHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
func (r ApiV2MetricsExchangeHistoryGetRequest) TimeFormat(timeFormat string) ApiV2MetricsExchangeHistoryGetRequest {
	r.timeFormat = &timeFormat
	return r
}

// Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
func (r ApiV2MetricsExchangeHistoryGetRequest) PeriodId(periodId string) ApiV2MetricsExchangeHistoryGetRequest {
	r.periodId = &periodId
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV2MetricsExchangeHistoryGetRequest) Limit(limit int32) ApiV2MetricsExchangeHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2MetricsExchangeHistoryGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2MetricsExchangeHistoryGetExecute(r)
}

/*
V2MetricsExchangeHistoryGet Historical metrics for the exchange

Get exchange metrics history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MetricsExchangeHistoryGetRequest
*/
func (a *MetricsV2APIService) V2MetricsExchangeHistoryGet(ctx context.Context) ApiV2MetricsExchangeHistoryGetRequest {
	return ApiV2MetricsExchangeHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MetricsV2APIService) V2MetricsExchangeHistoryGetExecute(r ApiV2MetricsExchangeHistoryGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.V2MetricsExchangeHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/exchange/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricId == nil {
		return localVarReturnValue, nil, reportError("metricId is required and must be specified")
	}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "metric_id", r.metricId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_format", r.timeFormat, "form", "")
	}
	if r.periodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MetricsExchangeListingGetRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
	exchangeId *string
}

// Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
func (r ApiV2MetricsExchangeListingGetRequest) ExchangeId(exchangeId string) ApiV2MetricsExchangeListingGetRequest {
	r.exchangeId = &exchangeId
	return r
}

func (r ApiV2MetricsExchangeListingGetRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.V2MetricsExchangeListingGetExecute(r)
}

/*
V2MetricsExchangeListingGet Listing of metrics available for specific exchange

Get all metrics that are actually available for the specified exchange.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MetricsExchangeListingGetRequest
*/
func (a *MetricsV2APIService) V2MetricsExchangeListingGet(ctx context.Context) ApiV2MetricsExchangeListingGetRequest {
	return ApiV2MetricsExchangeListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *MetricsV2APIService) V2MetricsExchangeListingGetExecute(r ApiV2MetricsExchangeListingGetRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.V2MetricsExchangeListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/exchange/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exchangeId == nil {
		return localVarReturnValue, nil, reportError("exchangeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange_id", r.exchangeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MetricsListingGetRequest struct {
	ctx context.Context
	ApiService *MetricsV2APIService
}

func (r ApiV2MetricsListingGetRequest) Execute() ([]V1MetricInfo, *http.Response, error) {
	return r.ApiService.V2MetricsListingGetExecute(r)
}

/*
V2MetricsListingGet Listing of all supported metrics

Get all metrics available in the system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MetricsListingGetRequest
*/
func (a *MetricsV2APIService) V2MetricsListingGet(ctx context.Context) ApiV2MetricsListingGetRequest {
	return ApiV2MetricsListingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1MetricInfo
func (a *MetricsV2APIService) V2MetricsListingGetExecute(r ApiV2MetricsListingGetRequest) ([]V1MetricInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1MetricInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsV2APIService.V2MetricsListingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/metrics/listing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
