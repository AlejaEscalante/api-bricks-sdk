/**
 * @fileoverview AUTOMATICALLY GENERATED service for API.Client.MetricsV2Api.
 * Do not edit this file by hand or your changes will be lost next time it is
 * generated.
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 * Version: v1
* Generator version: 7.13.0
 * Generated by: org.openapitools.codegen.languages.JavascriptClosureAngularClientCodegen
 */
/**
 * @license MIT License
 * https://github.com/api-bricks/api-bricks-sdk/blob/master/LICENSE
 */

goog.provide('API.Client.MetricsV2Api');

goog.require('API.Client.v1.MetricInfo');

/**
 * @constructor
 * @param {!angular.$http} $http
 * @param {!Object} $httpParamSerializer
 * @param {!angular.$injector} $injector
 * @struct
 */
API.Client.MetricsV2Api = function($http, $httpParamSerializer, $injector) {
  /** @private {!string} */
  this.basePath_ = $injector.has('MetricsV2ApiBasePath') ?
                   /** @type {!string} */ ($injector.get('MetricsV2ApiBasePath')) :
                   'https://rest.coinapi.io';

  /** @private {!Object<string, string>} */
  this.defaultHeaders_ = $injector.has('MetricsV2ApiDefaultHeaders') ?
                   /** @type {!Object<string, string>} */ (
                       $injector.get('MetricsV2ApiDefaultHeaders')) :
                   {};

  /** @private {!angular.$http} */
  this.http_ = $http;

  /** @package {!Object} */
  this.httpParamSerializer = $injector.get('$httpParamSerializer');
}
API.Client.MetricsV2Api.$inject = ['$http', '$httpParamSerializer', '$injector'];

/**
 * Historical metrics for the asset
 * Get asset metrics history.
 * @param {!string} metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
 * @param {!string} assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
 * @param {!Date=} opt_timeStart Starting time in ISO 8601
 * @param {!Date=} opt_timeEnd Ending time in ISO 8601
 * @param {!string=} opt_timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
 * @param {!string=} opt_periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
 * @param {!number=} opt_limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
 * @param {!angular.$http.Config=} opt_extraHttpRequestParams Extra HTTP parameters to send.
 * @return {!angular.$q.Promise<!Array<!API.Client.Object>>}
 */
API.Client.MetricsV2Api.prototype.v2MetricsAssetHistoryGet = function(metricId, assetId, opt_timeStart, opt_timeEnd, opt_timeFormat, opt_periodId, opt_limit, opt_extraHttpRequestParams) {
  /** @const {string} */
  var path = this.basePath_ + '/v2/metrics/asset/history';

  /** @type {!Object} */
  var queryParameters = {};

  /** @type {!Object} */
  var headerParams = angular.extend({}, this.defaultHeaders_);
  // verify required parameter 'metricId' is set
  if (!metricId) {
    throw new Error('Missing required parameter metricId when calling v2MetricsAssetHistoryGet');
  }
  // verify required parameter 'assetId' is set
  if (!assetId) {
    throw new Error('Missing required parameter assetId when calling v2MetricsAssetHistoryGet');
  }
  if (metricId !== undefined) {
    queryParameters['metric_id'] = metricId;
  }

  if (assetId !== undefined) {
    queryParameters['asset_id'] = assetId;
  }

  if (opt_timeStart !== undefined) {
    queryParameters['time_start'] = opt_timeStart;
  }

  if (opt_timeEnd !== undefined) {
    queryParameters['time_end'] = opt_timeEnd;
  }

  if (opt_timeFormat !== undefined) {
    queryParameters['time_format'] = opt_timeFormat;
  }

  if (opt_periodId !== undefined) {
    queryParameters['period_id'] = opt_periodId;
  }

  if (opt_limit !== undefined) {
    queryParameters['limit'] = opt_limit;
  }

  /** @type {!Object} */
  var httpRequestParams = {
    method: 'GET',
    url: path,
    json: true,
            params: queryParameters,
    headers: headerParams
  };

  if (opt_extraHttpRequestParams) {
    httpRequestParams = angular.extend(httpRequestParams, opt_extraHttpRequestParams);
  }

  return (/** @type {?} */ (this.http_))(httpRequestParams);
}

/**
 * Listing of metrics available for specific asset
 * Get all metrics that are actually available for the specified asset.
 * @param {!string} assetId Asset identifier (e.g., USDC, USDT)
 * @param {!angular.$http.Config=} opt_extraHttpRequestParams Extra HTTP parameters to send.
 * @return {!angular.$q.Promise<!Array<!API.Client.v1.MetricInfo>>}
 */
API.Client.MetricsV2Api.prototype.v2MetricsAssetListingGet = function(assetId, opt_extraHttpRequestParams) {
  /** @const {string} */
  var path = this.basePath_ + '/v2/metrics/asset/listing';

  /** @type {!Object} */
  var queryParameters = {};

  /** @type {!Object} */
  var headerParams = angular.extend({}, this.defaultHeaders_);
  // verify required parameter 'assetId' is set
  if (!assetId) {
    throw new Error('Missing required parameter assetId when calling v2MetricsAssetListingGet');
  }
  if (assetId !== undefined) {
    queryParameters['asset_id'] = assetId;
  }

  /** @type {!Object} */
  var httpRequestParams = {
    method: 'GET',
    url: path,
    json: true,
            params: queryParameters,
    headers: headerParams
  };

  if (opt_extraHttpRequestParams) {
    httpRequestParams = angular.extend(httpRequestParams, opt_extraHttpRequestParams);
  }

  return (/** @type {?} */ (this.http_))(httpRequestParams);
}

/**
 * Historical metrics for the chain
 * Get chain metrics history.
 * @param {!string} metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
 * @param {!string} chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
 * @param {!Date=} opt_timeStart Starting time in ISO 8601
 * @param {!Date=} opt_timeEnd Ending time in ISO 8601
 * @param {!string=} opt_timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
 * @param {!string=} opt_periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
 * @param {!number=} opt_limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
 * @param {!angular.$http.Config=} opt_extraHttpRequestParams Extra HTTP parameters to send.
 * @return {!angular.$q.Promise<!Array<!API.Client.Object>>}
 */
API.Client.MetricsV2Api.prototype.v2MetricsChainHistoryGet = function(metricId, chainId, opt_timeStart, opt_timeEnd, opt_timeFormat, opt_periodId, opt_limit, opt_extraHttpRequestParams) {
  /** @const {string} */
  var path = this.basePath_ + '/v2/metrics/chain/history';

  /** @type {!Object} */
  var queryParameters = {};

  /** @type {!Object} */
  var headerParams = angular.extend({}, this.defaultHeaders_);
  // verify required parameter 'metricId' is set
  if (!metricId) {
    throw new Error('Missing required parameter metricId when calling v2MetricsChainHistoryGet');
  }
  // verify required parameter 'chainId' is set
  if (!chainId) {
    throw new Error('Missing required parameter chainId when calling v2MetricsChainHistoryGet');
  }
  if (metricId !== undefined) {
    queryParameters['metric_id'] = metricId;
  }

  if (chainId !== undefined) {
    queryParameters['chain_id'] = chainId;
  }

  if (opt_timeStart !== undefined) {
    queryParameters['time_start'] = opt_timeStart;
  }

  if (opt_timeEnd !== undefined) {
    queryParameters['time_end'] = opt_timeEnd;
  }

  if (opt_timeFormat !== undefined) {
    queryParameters['time_format'] = opt_timeFormat;
  }

  if (opt_periodId !== undefined) {
    queryParameters['period_id'] = opt_periodId;
  }

  if (opt_limit !== undefined) {
    queryParameters['limit'] = opt_limit;
  }

  /** @type {!Object} */
  var httpRequestParams = {
    method: 'GET',
    url: path,
    json: true,
            params: queryParameters,
    headers: headerParams
  };

  if (opt_extraHttpRequestParams) {
    httpRequestParams = angular.extend(httpRequestParams, opt_extraHttpRequestParams);
  }

  return (/** @type {?} */ (this.http_))(httpRequestParams);
}

/**
 * Listing of metrics available for specific chain
 * Get all metrics that are actually available for the specified blockchain chain.
 * @param {!string} chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
 * @param {!angular.$http.Config=} opt_extraHttpRequestParams Extra HTTP parameters to send.
 * @return {!angular.$q.Promise<!Array<!API.Client.v1.MetricInfo>>}
 */
API.Client.MetricsV2Api.prototype.v2MetricsChainListingGet = function(chainId, opt_extraHttpRequestParams) {
  /** @const {string} */
  var path = this.basePath_ + '/v2/metrics/chain/listing';

  /** @type {!Object} */
  var queryParameters = {};

  /** @type {!Object} */
  var headerParams = angular.extend({}, this.defaultHeaders_);
  // verify required parameter 'chainId' is set
  if (!chainId) {
    throw new Error('Missing required parameter chainId when calling v2MetricsChainListingGet');
  }
  if (chainId !== undefined) {
    queryParameters['chain_id'] = chainId;
  }

  /** @type {!Object} */
  var httpRequestParams = {
    method: 'GET',
    url: path,
    json: true,
            params: queryParameters,
    headers: headerParams
  };

  if (opt_extraHttpRequestParams) {
    httpRequestParams = angular.extend(httpRequestParams, opt_extraHttpRequestParams);
  }

  return (/** @type {?} */ (this.http_))(httpRequestParams);
}

/**
 * Historical metrics for the exchange
 * Get exchange metrics history.
 * @param {!string} metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
 * @param {!string} exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
 * @param {!Date=} opt_timeStart Starting time in ISO 8601
 * @param {!Date=} opt_timeEnd Ending time in ISO 8601
 * @param {!string=} opt_timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
 * @param {!string=} opt_periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
 * @param {!number=} opt_limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
 * @param {!angular.$http.Config=} opt_extraHttpRequestParams Extra HTTP parameters to send.
 * @return {!angular.$q.Promise<!Array<!API.Client.Object>>}
 */
API.Client.MetricsV2Api.prototype.v2MetricsExchangeHistoryGet = function(metricId, exchangeId, opt_timeStart, opt_timeEnd, opt_timeFormat, opt_periodId, opt_limit, opt_extraHttpRequestParams) {
  /** @const {string} */
  var path = this.basePath_ + '/v2/metrics/exchange/history';

  /** @type {!Object} */
  var queryParameters = {};

  /** @type {!Object} */
  var headerParams = angular.extend({}, this.defaultHeaders_);
  // verify required parameter 'metricId' is set
  if (!metricId) {
    throw new Error('Missing required parameter metricId when calling v2MetricsExchangeHistoryGet');
  }
  // verify required parameter 'exchangeId' is set
  if (!exchangeId) {
    throw new Error('Missing required parameter exchangeId when calling v2MetricsExchangeHistoryGet');
  }
  if (metricId !== undefined) {
    queryParameters['metric_id'] = metricId;
  }

  if (exchangeId !== undefined) {
    queryParameters['exchange_id'] = exchangeId;
  }

  if (opt_timeStart !== undefined) {
    queryParameters['time_start'] = opt_timeStart;
  }

  if (opt_timeEnd !== undefined) {
    queryParameters['time_end'] = opt_timeEnd;
  }

  if (opt_timeFormat !== undefined) {
    queryParameters['time_format'] = opt_timeFormat;
  }

  if (opt_periodId !== undefined) {
    queryParameters['period_id'] = opt_periodId;
  }

  if (opt_limit !== undefined) {
    queryParameters['limit'] = opt_limit;
  }

  /** @type {!Object} */
  var httpRequestParams = {
    method: 'GET',
    url: path,
    json: true,
            params: queryParameters,
    headers: headerParams
  };

  if (opt_extraHttpRequestParams) {
    httpRequestParams = angular.extend(httpRequestParams, opt_extraHttpRequestParams);
  }

  return (/** @type {?} */ (this.http_))(httpRequestParams);
}

/**
 * Listing of metrics available for specific exchange
 * Get all metrics that are actually available for the specified exchange.
 * @param {!string} exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
 * @param {!angular.$http.Config=} opt_extraHttpRequestParams Extra HTTP parameters to send.
 * @return {!angular.$q.Promise<!Array<!API.Client.v1.MetricInfo>>}
 */
API.Client.MetricsV2Api.prototype.v2MetricsExchangeListingGet = function(exchangeId, opt_extraHttpRequestParams) {
  /** @const {string} */
  var path = this.basePath_ + '/v2/metrics/exchange/listing';

  /** @type {!Object} */
  var queryParameters = {};

  /** @type {!Object} */
  var headerParams = angular.extend({}, this.defaultHeaders_);
  // verify required parameter 'exchangeId' is set
  if (!exchangeId) {
    throw new Error('Missing required parameter exchangeId when calling v2MetricsExchangeListingGet');
  }
  if (exchangeId !== undefined) {
    queryParameters['exchange_id'] = exchangeId;
  }

  /** @type {!Object} */
  var httpRequestParams = {
    method: 'GET',
    url: path,
    json: true,
            params: queryParameters,
    headers: headerParams
  };

  if (opt_extraHttpRequestParams) {
    httpRequestParams = angular.extend(httpRequestParams, opt_extraHttpRequestParams);
  }

  return (/** @type {?} */ (this.http_))(httpRequestParams);
}

/**
 * Listing of all supported metrics
 * Get all metrics available in the system.
 * @param {!angular.$http.Config=} opt_extraHttpRequestParams Extra HTTP parameters to send.
 * @return {!angular.$q.Promise<!Array<!API.Client.v1.MetricInfo>>}
 */
API.Client.MetricsV2Api.prototype.v2MetricsListingGet = function(opt_extraHttpRequestParams) {
  /** @const {string} */
  var path = this.basePath_ + '/v2/metrics/listing';

  /** @type {!Object} */
  var queryParameters = {};

  /** @type {!Object} */
  var headerParams = angular.extend({}, this.defaultHeaders_);
  /** @type {!Object} */
  var httpRequestParams = {
    method: 'GET',
    url: path,
    json: true,
            params: queryParameters,
    headers: headerParams
  };

  if (opt_extraHttpRequestParams) {
    httpRequestParams = angular.extend(httpRequestParams, opt_extraHttpRequestParams);
  }

  return (/** @type {?} */ (this.http_))(httpRequestParams);
}
