/**
 * CoinAPI Market Data REST API
 *
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { V1GeneralData } from '../model/v1GeneralData';
// @ts-ignore
import { V1ListingItem } from '../model/v1ListingItem';
// @ts-ignore
import { V1Metric } from '../model/v1Metric';
// @ts-ignore
import { V1MetricData } from '../model/v1MetricData';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class MetricsService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Current metrics for given asset
     * Get current asset metrics.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets)
     * @param assetIdExternal Exchange asset identifier
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsAssetCurrentGet(metricId?: string, assetId?: string, assetIdExternal?: string, exchangeId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1GeneralData>>;
    public v1MetricsAssetCurrentGet(metricId?: string, assetId?: string, assetIdExternal?: string, exchangeId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1GeneralData>>>;
    public v1MetricsAssetCurrentGet(metricId?: string, assetId?: string, assetIdExternal?: string, exchangeId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1GeneralData>>>;
    public v1MetricsAssetCurrentGet(metricId?: string, assetId?: string, assetIdExternal?: string, exchangeId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>metricId, 'metric_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>assetId, 'asset_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>assetIdExternal, 'asset_id_external');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>exchangeId, 'exchange_id');

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/asset/current`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1GeneralData>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Historical metrics for asset
     * Get asset metrics history.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets)
     * @param assetIdExternal Exchange asset identifier
     * @param timeStart Starting time in ISO 8601
     * @param timeEnd Ending time in ISO 8601
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsAssetHistoryGet(metricId: string, exchangeId: string, assetId?: string, assetIdExternal?: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1MetricData>>;
    public v1MetricsAssetHistoryGet(metricId: string, exchangeId: string, assetId?: string, assetIdExternal?: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1MetricData>>>;
    public v1MetricsAssetHistoryGet(metricId: string, exchangeId: string, assetId?: string, assetIdExternal?: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1MetricData>>>;
    public v1MetricsAssetHistoryGet(metricId: string, exchangeId: string, assetId?: string, assetIdExternal?: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (metricId === null || metricId === undefined) {
            throw new Error('Required parameter metricId was null or undefined when calling v1MetricsAssetHistoryGet.');
        }
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v1MetricsAssetHistoryGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>metricId, 'metric_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>assetId, 'asset_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>assetIdExternal, 'asset_id_external');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>exchangeId, 'exchange_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>timeStart, 'time_start');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>timeEnd, 'time_end');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>timeFormat, 'time_format');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>periodId, 'period_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/asset/history`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1MetricData>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Listing of all supported metrics for asset
     * Get data metrics for asset.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param chainId Chain identifier
     * @param networkId Network identifier
     * @param assetId Asset identifier (from the Metadata -&gt; Assets)
     * @param assetIdExternal The asset external identifier
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsAssetListingGet(metricId?: string, exchangeId?: string, chainId?: string, networkId?: string, assetId?: string, assetIdExternal?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1ListingItem>>;
    public v1MetricsAssetListingGet(metricId?: string, exchangeId?: string, chainId?: string, networkId?: string, assetId?: string, assetIdExternal?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1ListingItem>>>;
    public v1MetricsAssetListingGet(metricId?: string, exchangeId?: string, chainId?: string, networkId?: string, assetId?: string, assetIdExternal?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1ListingItem>>>;
    public v1MetricsAssetListingGet(metricId?: string, exchangeId?: string, chainId?: string, networkId?: string, assetId?: string, assetIdExternal?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>metricId, 'metric_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>exchangeId, 'exchange_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>chainId, 'chain_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>networkId, 'network_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>assetId, 'asset_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>assetIdExternal, 'asset_id_external');

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/asset/listing`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1ListingItem>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Current metrics for given exchange
     * Get current exchange metrics values.
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsExchangeCurrentGet(exchangeId: string, metricId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1GeneralData>>;
    public v1MetricsExchangeCurrentGet(exchangeId: string, metricId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1GeneralData>>>;
    public v1MetricsExchangeCurrentGet(exchangeId: string, metricId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1GeneralData>>>;
    public v1MetricsExchangeCurrentGet(exchangeId: string, metricId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v1MetricsExchangeCurrentGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>metricId, 'metric_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>exchangeId, 'exchange_id');

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/exchange/current`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1GeneralData>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Historical metrics for the exchange
     * Get exchange metrics history.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param timeStart Starting time in ISO 8601
     * @param timeEnd Ending time in ISO 8601
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1MetricData>>;
    public v1MetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1MetricData>>>;
    public v1MetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1MetricData>>>;
    public v1MetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (metricId === null || metricId === undefined) {
            throw new Error('Required parameter metricId was null or undefined when calling v1MetricsExchangeHistoryGet.');
        }
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v1MetricsExchangeHistoryGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>metricId, 'metric_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>exchangeId, 'exchange_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>timeStart, 'time_start');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>timeEnd, 'time_end');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>timeFormat, 'time_format');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>periodId, 'period_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/exchange/history`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1MetricData>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Listing of all supported exchange metrics
     * Get data metrics for exchange.
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsExchangeListingGet(exchangeId: string, metricId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1ListingItem>>;
    public v1MetricsExchangeListingGet(exchangeId: string, metricId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1ListingItem>>>;
    public v1MetricsExchangeListingGet(exchangeId: string, metricId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1ListingItem>>>;
    public v1MetricsExchangeListingGet(exchangeId: string, metricId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v1MetricsExchangeListingGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>metricId, 'metric_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>exchangeId, 'exchange_id');

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/exchange/listing`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1ListingItem>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Listing of all supported metrics by CoinAPI
     * Get all data metrics.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsListingGet(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1Metric>>;
    public v1MetricsListingGet(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1Metric>>>;
    public v1MetricsListingGet(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1Metric>>>;
    public v1MetricsListingGet(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/listing`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1Metric>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Current metrics for given symbol
     * Get current symbol metrics.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols)
     * @param exchangeId Exchange id (from the Metadata -&gt; Exchanges)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsSymbolCurrentGet(metricId?: string, symbolId?: string, exchangeId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1GeneralData>>;
    public v1MetricsSymbolCurrentGet(metricId?: string, symbolId?: string, exchangeId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1GeneralData>>>;
    public v1MetricsSymbolCurrentGet(metricId?: string, symbolId?: string, exchangeId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1GeneralData>>>;
    public v1MetricsSymbolCurrentGet(metricId?: string, symbolId?: string, exchangeId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>metricId, 'metric_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>symbolId, 'symbol_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>exchangeId, 'exchange_id');

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/symbol/current`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1GeneralData>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Historical metrics for symbol
     * Get symbol metrics history.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols)
     * @param timeStart Starting time in ISO 8601
     * @param timeEnd Ending time in ISO 8601
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsSymbolHistoryGet(metricId: string, symbolId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1MetricData>>;
    public v1MetricsSymbolHistoryGet(metricId: string, symbolId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1MetricData>>>;
    public v1MetricsSymbolHistoryGet(metricId: string, symbolId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1MetricData>>>;
    public v1MetricsSymbolHistoryGet(metricId: string, symbolId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (metricId === null || metricId === undefined) {
            throw new Error('Required parameter metricId was null or undefined when calling v1MetricsSymbolHistoryGet.');
        }
        if (symbolId === null || symbolId === undefined) {
            throw new Error('Required parameter symbolId was null or undefined when calling v1MetricsSymbolHistoryGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>metricId, 'metric_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>symbolId, 'symbol_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>timeStart, 'time_start');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>timeEnd, 'time_end');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>timeFormat, 'time_format');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>periodId, 'period_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/symbol/history`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1MetricData>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Listing of all supported metrics for symbol
     * Get data metrics for symbol.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public v1MetricsSymbolListingGet(metricId?: string, exchangeId?: string, symbolId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<Array<V1ListingItem>>;
    public v1MetricsSymbolListingGet(metricId?: string, exchangeId?: string, symbolId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<V1ListingItem>>>;
    public v1MetricsSymbolListingGet(metricId?: string, exchangeId?: string, symbolId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<V1ListingItem>>>;
    public v1MetricsSymbolListingGet(metricId?: string, exchangeId?: string, symbolId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain' | 'application/json' | 'text/json' | 'application/x-msgpack', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>metricId, 'metric_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>exchangeId, 'exchange_id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>symbolId, 'symbol_id');

        let localVarHeaders = this.defaultHeaders;

        // authentication (APIKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('APIKey', 'Authorization', localVarHeaders);

        // authentication (JWT) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWT', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain',
            'application/json',
            'text/json',
            'application/x-msgpack'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/v1/metrics/symbol/listing`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<V1ListingItem>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
