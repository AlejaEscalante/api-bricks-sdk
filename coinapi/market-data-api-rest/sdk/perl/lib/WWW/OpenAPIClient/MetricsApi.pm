=begin comment

CoinAPI Market Data REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: v1
Contact: support@apibricks.io
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::MetricsApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# v1_metrics_asset_current_get
#
# Current metrics for given asset
#
# @param string $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
# @param string $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
# @param string $asset_id_external Exchange asset identifier (optional)
# @param string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (from the Metrics -&gt; Listing)',
        required => '0',
    },
    'asset_id' => {
        data_type => 'string',
        description => 'Asset identifier (from the Metadata -&gt; Assets)',
        required => '0',
    },
    'asset_id_external' => {
        data_type => 'string',
        description => 'Exchange asset identifier',
        required => '0',
    },
    'exchange_id' => {
        data_type => 'string',
        description => 'Exchange identifier (from the Metadata -&gt; Exchanges)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_asset_current_get' } = {
        summary => 'Current metrics for given asset',
        params => $params,
        returns => 'ARRAY[V1GeneralData]',
        };
}
# @return ARRAY[V1GeneralData]
#
sub v1_metrics_asset_current_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/metrics/asset/current';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'asset_id'}) {
        $query_params->{'asset_id'} = $self->{api_client}->to_query_value($args{'asset_id'});
    }

    # query params
    if ( exists $args{'asset_id_external'}) {
        $query_params->{'asset_id_external'} = $self->{api_client}->to_query_value($args{'asset_id_external'});
    }

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1GeneralData]', $response);
    return $_response_object;
}

#
# v1_metrics_asset_history_get
#
# Historical metrics for asset
#
# @param string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
# @param string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
# @param string $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
# @param string $asset_id_external Exchange asset identifier (optional)
# @param DATE_TIME $time_start Starting time in ISO 8601 (optional)
# @param DATE_TIME $time_end Ending time in ISO 8601 (optional)
# @param string $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
# @param string $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
# @param int $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (from the Metrics -&gt; Listing)',
        required => '1',
    },
    'exchange_id' => {
        data_type => 'string',
        description => 'Exchange identifier (from the Metadata -&gt; Exchanges)',
        required => '1',
    },
    'asset_id' => {
        data_type => 'string',
        description => 'Asset identifier (from the Metadata -&gt; Assets)',
        required => '0',
    },
    'asset_id_external' => {
        data_type => 'string',
        description => 'Exchange asset identifier',
        required => '0',
    },
    'time_start' => {
        data_type => 'DATE_TIME',
        description => 'Starting time in ISO 8601',
        required => '0',
    },
    'time_end' => {
        data_type => 'DATE_TIME',
        description => 'Ending time in ISO 8601',
        required => '0',
    },
    'time_format' => {
        data_type => 'string',
        description => 'If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)',
        required => '0',
    },
    'period_id' => {
        data_type => 'string',
        description => 'Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_asset_history_get' } = {
        summary => 'Historical metrics for asset',
        params => $params,
        returns => 'ARRAY[V1MetricData]',
        };
}
# @return ARRAY[V1MetricData]
#
sub v1_metrics_asset_history_get {
    my ($self, %args) = @_;

    # verify the required parameter 'metric_id' is set
    unless (exists $args{'metric_id'}) {
      croak("Missing the required parameter 'metric_id' when calling v1_metrics_asset_history_get");
    }

    # verify the required parameter 'exchange_id' is set
    unless (exists $args{'exchange_id'}) {
      croak("Missing the required parameter 'exchange_id' when calling v1_metrics_asset_history_get");
    }

    # parse inputs
    my $_resource_path = '/v1/metrics/asset/history';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'asset_id'}) {
        $query_params->{'asset_id'} = $self->{api_client}->to_query_value($args{'asset_id'});
    }

    # query params
    if ( exists $args{'asset_id_external'}) {
        $query_params->{'asset_id_external'} = $self->{api_client}->to_query_value($args{'asset_id_external'});
    }

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    # query params
    if ( exists $args{'time_start'}) {
        $query_params->{'time_start'} = $self->{api_client}->to_query_value($args{'time_start'});
    }

    # query params
    if ( exists $args{'time_end'}) {
        $query_params->{'time_end'} = $self->{api_client}->to_query_value($args{'time_end'});
    }

    # query params
    if ( exists $args{'time_format'}) {
        $query_params->{'time_format'} = $self->{api_client}->to_query_value($args{'time_format'});
    }

    # query params
    if ( exists $args{'period_id'}) {
        $query_params->{'period_id'} = $self->{api_client}->to_query_value($args{'period_id'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1MetricData]', $response);
    return $_response_object;
}

#
# v1_metrics_asset_listing_get
#
# Listing of all supported metrics for asset
#
# @param string $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
# @param string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
# @param string $chain_id Chain identifier (optional)
# @param string $network_id Network identifier (optional)
# @param string $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
# @param string $asset_id_external The asset external identifier (optional)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (from the Metrics -&gt; Listing)',
        required => '0',
    },
    'exchange_id' => {
        data_type => 'string',
        description => 'Exchange identifier (from the Metadata -&gt; Exchanges)',
        required => '0',
    },
    'chain_id' => {
        data_type => 'string',
        description => 'Chain identifier',
        required => '0',
    },
    'network_id' => {
        data_type => 'string',
        description => 'Network identifier',
        required => '0',
    },
    'asset_id' => {
        data_type => 'string',
        description => 'Asset identifier (from the Metadata -&gt; Assets)',
        required => '0',
    },
    'asset_id_external' => {
        data_type => 'string',
        description => 'The asset external identifier',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_asset_listing_get' } = {
        summary => 'Listing of all supported metrics for asset',
        params => $params,
        returns => 'ARRAY[V1ListingItem]',
        };
}
# @return ARRAY[V1ListingItem]
#
sub v1_metrics_asset_listing_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/metrics/asset/listing';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    # query params
    if ( exists $args{'chain_id'}) {
        $query_params->{'chain_id'} = $self->{api_client}->to_query_value($args{'chain_id'});
    }

    # query params
    if ( exists $args{'network_id'}) {
        $query_params->{'network_id'} = $self->{api_client}->to_query_value($args{'network_id'});
    }

    # query params
    if ( exists $args{'asset_id'}) {
        $query_params->{'asset_id'} = $self->{api_client}->to_query_value($args{'asset_id'});
    }

    # query params
    if ( exists $args{'asset_id_external'}) {
        $query_params->{'asset_id_external'} = $self->{api_client}->to_query_value($args{'asset_id_external'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1ListingItem]', $response);
    return $_response_object;
}

#
# v1_metrics_exchange_current_get
#
# Current metrics for given exchange
#
# @param string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
# @param string $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
{
    my $params = {
    'exchange_id' => {
        data_type => 'string',
        description => 'The exchange identifier (from the Metadata -&gt; Exchanges)',
        required => '1',
    },
    'metric_id' => {
        data_type => 'string',
        description => 'The metric identifier (from the Metrics -&gt; Listing)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_exchange_current_get' } = {
        summary => 'Current metrics for given exchange',
        params => $params,
        returns => 'ARRAY[V1GeneralData]',
        };
}
# @return ARRAY[V1GeneralData]
#
sub v1_metrics_exchange_current_get {
    my ($self, %args) = @_;

    # verify the required parameter 'exchange_id' is set
    unless (exists $args{'exchange_id'}) {
      croak("Missing the required parameter 'exchange_id' when calling v1_metrics_exchange_current_get");
    }

    # parse inputs
    my $_resource_path = '/v1/metrics/exchange/current';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1GeneralData]', $response);
    return $_response_object;
}

#
# v1_metrics_exchange_history_get
#
# Historical metrics for the exchange
#
# @param string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
# @param string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
# @param DATE_TIME $time_start Starting time in ISO 8601 (optional)
# @param DATE_TIME $time_end Ending time in ISO 8601 (optional)
# @param string $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
# @param string $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
# @param int $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (from the Metrics -&gt; Listing)',
        required => '1',
    },
    'exchange_id' => {
        data_type => 'string',
        description => 'Exchange identifier (from the Metadata -&gt; Exchanges)',
        required => '1',
    },
    'time_start' => {
        data_type => 'DATE_TIME',
        description => 'Starting time in ISO 8601',
        required => '0',
    },
    'time_end' => {
        data_type => 'DATE_TIME',
        description => 'Ending time in ISO 8601',
        required => '0',
    },
    'time_format' => {
        data_type => 'string',
        description => 'If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)',
        required => '0',
    },
    'period_id' => {
        data_type => 'string',
        description => 'Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_exchange_history_get' } = {
        summary => 'Historical metrics for the exchange',
        params => $params,
        returns => 'ARRAY[V1MetricData]',
        };
}
# @return ARRAY[V1MetricData]
#
sub v1_metrics_exchange_history_get {
    my ($self, %args) = @_;

    # verify the required parameter 'metric_id' is set
    unless (exists $args{'metric_id'}) {
      croak("Missing the required parameter 'metric_id' when calling v1_metrics_exchange_history_get");
    }

    # verify the required parameter 'exchange_id' is set
    unless (exists $args{'exchange_id'}) {
      croak("Missing the required parameter 'exchange_id' when calling v1_metrics_exchange_history_get");
    }

    # parse inputs
    my $_resource_path = '/v1/metrics/exchange/history';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    # query params
    if ( exists $args{'time_start'}) {
        $query_params->{'time_start'} = $self->{api_client}->to_query_value($args{'time_start'});
    }

    # query params
    if ( exists $args{'time_end'}) {
        $query_params->{'time_end'} = $self->{api_client}->to_query_value($args{'time_end'});
    }

    # query params
    if ( exists $args{'time_format'}) {
        $query_params->{'time_format'} = $self->{api_client}->to_query_value($args{'time_format'});
    }

    # query params
    if ( exists $args{'period_id'}) {
        $query_params->{'period_id'} = $self->{api_client}->to_query_value($args{'period_id'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1MetricData]', $response);
    return $_response_object;
}

#
# v1_metrics_exchange_listing_get
#
# Listing of all supported exchange metrics
#
# @param string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
# @param string $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
{
    my $params = {
    'exchange_id' => {
        data_type => 'string',
        description => 'The exchange identifier (from the Metadata -&gt; Exchanges)',
        required => '1',
    },
    'metric_id' => {
        data_type => 'string',
        description => 'The metric identifier (from the Metrics -&gt; Listing)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_exchange_listing_get' } = {
        summary => 'Listing of all supported exchange metrics',
        params => $params,
        returns => 'ARRAY[V1ListingItem]',
        };
}
# @return ARRAY[V1ListingItem]
#
sub v1_metrics_exchange_listing_get {
    my ($self, %args) = @_;

    # verify the required parameter 'exchange_id' is set
    unless (exists $args{'exchange_id'}) {
      croak("Missing the required parameter 'exchange_id' when calling v1_metrics_exchange_listing_get");
    }

    # parse inputs
    my $_resource_path = '/v1/metrics/exchange/listing';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1ListingItem]', $response);
    return $_response_object;
}

#
# v1_metrics_listing_get
#
# Listing of all supported metrics by CoinAPI
#
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_listing_get' } = {
        summary => 'Listing of all supported metrics by CoinAPI',
        params => $params,
        returns => 'ARRAY[V1Metric]',
        };
}
# @return ARRAY[V1Metric]
#
sub v1_metrics_listing_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/metrics/listing';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1Metric]', $response);
    return $_response_object;
}

#
# v1_metrics_symbol_current_get
#
# Current metrics for given symbol
#
# @param string $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
# @param string $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
# @param string $exchange_id Exchange id (from the Metadata -&gt; Exchanges) (optional)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (from the Metrics -&gt; Listing)',
        required => '0',
    },
    'symbol_id' => {
        data_type => 'string',
        description => 'Symbol identifier (from the Metadata -&gt; Symbols)',
        required => '0',
    },
    'exchange_id' => {
        data_type => 'string',
        description => 'Exchange id (from the Metadata -&gt; Exchanges)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_symbol_current_get' } = {
        summary => 'Current metrics for given symbol',
        params => $params,
        returns => 'ARRAY[V1GeneralData]',
        };
}
# @return ARRAY[V1GeneralData]
#
sub v1_metrics_symbol_current_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/metrics/symbol/current';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'symbol_id'}) {
        $query_params->{'symbol_id'} = $self->{api_client}->to_query_value($args{'symbol_id'});
    }

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1GeneralData]', $response);
    return $_response_object;
}

#
# v1_metrics_symbol_history_get
#
# Historical metrics for symbol
#
# @param string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
# @param string $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (required)
# @param DATE_TIME $time_start Starting time in ISO 8601 (optional)
# @param DATE_TIME $time_end Ending time in ISO 8601 (optional)
# @param string $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
# @param string $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
# @param int $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (from the Metrics -&gt; Listing)',
        required => '1',
    },
    'symbol_id' => {
        data_type => 'string',
        description => 'Symbol identifier (from the Metadata -&gt; Symbols)',
        required => '1',
    },
    'time_start' => {
        data_type => 'DATE_TIME',
        description => 'Starting time in ISO 8601',
        required => '0',
    },
    'time_end' => {
        data_type => 'DATE_TIME',
        description => 'Ending time in ISO 8601',
        required => '0',
    },
    'time_format' => {
        data_type => 'string',
        description => 'If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)',
        required => '0',
    },
    'period_id' => {
        data_type => 'string',
        description => 'Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_symbol_history_get' } = {
        summary => 'Historical metrics for symbol',
        params => $params,
        returns => 'ARRAY[V1MetricData]',
        };
}
# @return ARRAY[V1MetricData]
#
sub v1_metrics_symbol_history_get {
    my ($self, %args) = @_;

    # verify the required parameter 'metric_id' is set
    unless (exists $args{'metric_id'}) {
      croak("Missing the required parameter 'metric_id' when calling v1_metrics_symbol_history_get");
    }

    # verify the required parameter 'symbol_id' is set
    unless (exists $args{'symbol_id'}) {
      croak("Missing the required parameter 'symbol_id' when calling v1_metrics_symbol_history_get");
    }

    # parse inputs
    my $_resource_path = '/v1/metrics/symbol/history';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'symbol_id'}) {
        $query_params->{'symbol_id'} = $self->{api_client}->to_query_value($args{'symbol_id'});
    }

    # query params
    if ( exists $args{'time_start'}) {
        $query_params->{'time_start'} = $self->{api_client}->to_query_value($args{'time_start'});
    }

    # query params
    if ( exists $args{'time_end'}) {
        $query_params->{'time_end'} = $self->{api_client}->to_query_value($args{'time_end'});
    }

    # query params
    if ( exists $args{'time_format'}) {
        $query_params->{'time_format'} = $self->{api_client}->to_query_value($args{'time_format'});
    }

    # query params
    if ( exists $args{'period_id'}) {
        $query_params->{'period_id'} = $self->{api_client}->to_query_value($args{'period_id'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1MetricData]', $response);
    return $_response_object;
}

#
# v1_metrics_symbol_listing_get
#
# Listing of all supported metrics for symbol
#
# @param string $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
# @param string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
# @param string $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (from the Metrics -&gt; Listing)',
        required => '0',
    },
    'exchange_id' => {
        data_type => 'string',
        description => 'Exchange identifier (from the Metadata -&gt; Exchanges)',
        required => '0',
    },
    'symbol_id' => {
        data_type => 'string',
        description => 'Symbol identifier (from the Metadata -&gt; Symbols)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_metrics_symbol_listing_get' } = {
        summary => 'Listing of all supported metrics for symbol',
        params => $params,
        returns => 'ARRAY[V1ListingItem]',
        };
}
# @return ARRAY[V1ListingItem]
#
sub v1_metrics_symbol_listing_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/metrics/symbol/listing';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    # query params
    if ( exists $args{'symbol_id'}) {
        $query_params->{'symbol_id'} = $self->{api_client}->to_query_value($args{'symbol_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(APIKey JWT )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1ListingItem]', $response);
    return $_response_object;
}

1;
