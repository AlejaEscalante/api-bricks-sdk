=begin comment

REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: v1
Contact: support@apibricks.io
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::ExternalMetricsApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# v1_externalmetrics_asset_history_get
#
# Historical metrics for the asset from external sources
#
# @param string $metric_id Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key) (required)
# @param string $asset_id Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60; - from supported assets list) (required)
# @param DATE_TIME $time_start Starting time in ISO 8601 (optional)
# @param DATE_TIME $time_end Ending time in ISO 8601 (optional)
# @param string $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
# @param string $period_id Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
# @param int $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)',
        required => '1',
    },
    'asset_id' => {
        data_type => 'string',
        description => 'Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60; - from supported assets list)',
        required => '1',
    },
    'time_start' => {
        data_type => 'DATE_TIME',
        description => 'Starting time in ISO 8601',
        required => '0',
    },
    'time_end' => {
        data_type => 'DATE_TIME',
        description => 'Ending time in ISO 8601',
        required => '0',
    },
    'time_format' => {
        data_type => 'string',
        description => 'If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)',
        required => '0',
    },
    'period_id' => {
        data_type => 'string',
        description => 'Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_asset_history_get' } = {
        summary => 'Historical metrics for the asset from external sources',
        params => $params,
        returns => 'ARRAY[object]',
        };
}
# @return ARRAY[object]
#
sub v1_externalmetrics_asset_history_get {
    my ($self, %args) = @_;

    # verify the required parameter 'metric_id' is set
    unless (exists $args{'metric_id'}) {
      croak("Missing the required parameter 'metric_id' when calling v1_externalmetrics_asset_history_get");
    }

    # verify the required parameter 'asset_id' is set
    unless (exists $args{'asset_id'}) {
      croak("Missing the required parameter 'asset_id' when calling v1_externalmetrics_asset_history_get");
    }

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/asset/history';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'asset_id'}) {
        $query_params->{'asset_id'} = $self->{api_client}->to_query_value($args{'asset_id'});
    }

    # query params
    if ( exists $args{'time_start'}) {
        $query_params->{'time_start'} = $self->{api_client}->to_query_value($args{'time_start'});
    }

    # query params
    if ( exists $args{'time_end'}) {
        $query_params->{'time_end'} = $self->{api_client}->to_query_value($args{'time_end'});
    }

    # query params
    if ( exists $args{'time_format'}) {
        $query_params->{'time_format'} = $self->{api_client}->to_query_value($args{'time_format'});
    }

    # query params
    if ( exists $args{'period_id'}) {
        $query_params->{'period_id'} = $self->{api_client}->to_query_value($args{'period_id'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[object]', $response);
    return $_response_object;
}

#
# v1_externalmetrics_asset_listing_get
#
# Listing of metrics available for specific asset
#
# @param string $asset_id Asset identifier (e.g., USDC, USDT) (required)
{
    my $params = {
    'asset_id' => {
        data_type => 'string',
        description => 'Asset identifier (e.g., USDC, USDT)',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_asset_listing_get' } = {
        summary => 'Listing of metrics available for specific asset',
        params => $params,
        returns => 'ARRAY[V1MetricInfo]',
        };
}
# @return ARRAY[V1MetricInfo]
#
sub v1_externalmetrics_asset_listing_get {
    my ($self, %args) = @_;

    # verify the required parameter 'asset_id' is set
    unless (exists $args{'asset_id'}) {
      croak("Missing the required parameter 'asset_id' when calling v1_externalmetrics_asset_listing_get");
    }

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/asset/listing';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'asset_id'}) {
        $query_params->{'asset_id'} = $self->{api_client}->to_query_value($args{'asset_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1MetricInfo]', $response);
    return $_response_object;
}

#
# v1_externalmetrics_assets_get
#
# Listing of all supported external assets
#
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_assets_get' } = {
        summary => 'Listing of all supported external assets',
        params => $params,
        returns => 'ARRAY[V1ExternalAsset]',
        };
}
# @return ARRAY[V1ExternalAsset]
#
sub v1_externalmetrics_assets_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/assets';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1ExternalAsset]', $response);
    return $_response_object;
}

#
# v1_externalmetrics_chain_history_get
#
# Historical metrics for the chain from external sources
#
# @param string $metric_id Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key) (required)
# @param string $chain_id Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60; - from supported chains list) (required)
# @param DATE_TIME $time_start Starting time in ISO 8601 (optional)
# @param DATE_TIME $time_end Ending time in ISO 8601 (optional)
# @param string $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
# @param string $period_id Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
# @param int $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)',
        required => '1',
    },
    'chain_id' => {
        data_type => 'string',
        description => 'Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60; - from supported chains list)',
        required => '1',
    },
    'time_start' => {
        data_type => 'DATE_TIME',
        description => 'Starting time in ISO 8601',
        required => '0',
    },
    'time_end' => {
        data_type => 'DATE_TIME',
        description => 'Ending time in ISO 8601',
        required => '0',
    },
    'time_format' => {
        data_type => 'string',
        description => 'If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)',
        required => '0',
    },
    'period_id' => {
        data_type => 'string',
        description => 'Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_chain_history_get' } = {
        summary => 'Historical metrics for the chain from external sources',
        params => $params,
        returns => 'ARRAY[object]',
        };
}
# @return ARRAY[object]
#
sub v1_externalmetrics_chain_history_get {
    my ($self, %args) = @_;

    # verify the required parameter 'metric_id' is set
    unless (exists $args{'metric_id'}) {
      croak("Missing the required parameter 'metric_id' when calling v1_externalmetrics_chain_history_get");
    }

    # verify the required parameter 'chain_id' is set
    unless (exists $args{'chain_id'}) {
      croak("Missing the required parameter 'chain_id' when calling v1_externalmetrics_chain_history_get");
    }

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/chain/history';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'chain_id'}) {
        $query_params->{'chain_id'} = $self->{api_client}->to_query_value($args{'chain_id'});
    }

    # query params
    if ( exists $args{'time_start'}) {
        $query_params->{'time_start'} = $self->{api_client}->to_query_value($args{'time_start'});
    }

    # query params
    if ( exists $args{'time_end'}) {
        $query_params->{'time_end'} = $self->{api_client}->to_query_value($args{'time_end'});
    }

    # query params
    if ( exists $args{'time_format'}) {
        $query_params->{'time_format'} = $self->{api_client}->to_query_value($args{'time_format'});
    }

    # query params
    if ( exists $args{'period_id'}) {
        $query_params->{'period_id'} = $self->{api_client}->to_query_value($args{'period_id'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[object]', $response);
    return $_response_object;
}

#
# v1_externalmetrics_chain_listing_get
#
# Listing of metrics available for specific chain
#
# @param string $chain_id Chain identifier (e.g., ETHEREUM, ARBITRUM) (required)
{
    my $params = {
    'chain_id' => {
        data_type => 'string',
        description => 'Chain identifier (e.g., ETHEREUM, ARBITRUM)',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_chain_listing_get' } = {
        summary => 'Listing of metrics available for specific chain',
        params => $params,
        returns => 'ARRAY[V1MetricInfo]',
        };
}
# @return ARRAY[V1MetricInfo]
#
sub v1_externalmetrics_chain_listing_get {
    my ($self, %args) = @_;

    # verify the required parameter 'chain_id' is set
    unless (exists $args{'chain_id'}) {
      croak("Missing the required parameter 'chain_id' when calling v1_externalmetrics_chain_listing_get");
    }

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/chain/listing';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'chain_id'}) {
        $query_params->{'chain_id'} = $self->{api_client}->to_query_value($args{'chain_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1MetricInfo]', $response);
    return $_response_object;
}

#
# v1_externalmetrics_chains_get
#
# Listing of all supported external chains
#
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_chains_get' } = {
        summary => 'Listing of all supported external chains',
        params => $params,
        returns => 'ARRAY[V1Chain]',
        };
}
# @return ARRAY[V1Chain]
#
sub v1_externalmetrics_chains_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/chains';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1Chain]', $response);
    return $_response_object;
}

#
# v1_externalmetrics_exchange_history_get
#
# Historical metrics for the exchange from both external and internal sources
#
# @param string $metric_id Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; for external, or generic metric IDs) (required)
# @param string $exchange_id Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;) (required)
# @param DATE_TIME $time_start Starting time in ISO 8601 (optional)
# @param DATE_TIME $time_end Ending time in ISO 8601 (optional)
# @param string $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
# @param string $period_id Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
# @param int $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
{
    my $params = {
    'metric_id' => {
        data_type => 'string',
        description => 'Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; for external, or generic metric IDs)',
        required => '1',
    },
    'exchange_id' => {
        data_type => 'string',
        description => 'Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)',
        required => '1',
    },
    'time_start' => {
        data_type => 'DATE_TIME',
        description => 'Starting time in ISO 8601',
        required => '0',
    },
    'time_end' => {
        data_type => 'DATE_TIME',
        description => 'Ending time in ISO 8601',
        required => '0',
    },
    'time_format' => {
        data_type => 'string',
        description => 'If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)',
        required => '0',
    },
    'period_id' => {
        data_type => 'string',
        description => 'Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_exchange_history_get' } = {
        summary => 'Historical metrics for the exchange from both external and internal sources',
        params => $params,
        returns => 'ARRAY[object]',
        };
}
# @return ARRAY[object]
#
sub v1_externalmetrics_exchange_history_get {
    my ($self, %args) = @_;

    # verify the required parameter 'metric_id' is set
    unless (exists $args{'metric_id'}) {
      croak("Missing the required parameter 'metric_id' when calling v1_externalmetrics_exchange_history_get");
    }

    # verify the required parameter 'exchange_id' is set
    unless (exists $args{'exchange_id'}) {
      croak("Missing the required parameter 'exchange_id' when calling v1_externalmetrics_exchange_history_get");
    }

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/exchange/history';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'metric_id'}) {
        $query_params->{'metric_id'} = $self->{api_client}->to_query_value($args{'metric_id'});
    }

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    # query params
    if ( exists $args{'time_start'}) {
        $query_params->{'time_start'} = $self->{api_client}->to_query_value($args{'time_start'});
    }

    # query params
    if ( exists $args{'time_end'}) {
        $query_params->{'time_end'} = $self->{api_client}->to_query_value($args{'time_end'});
    }

    # query params
    if ( exists $args{'time_format'}) {
        $query_params->{'time_format'} = $self->{api_client}->to_query_value($args{'time_format'});
    }

    # query params
    if ( exists $args{'period_id'}) {
        $query_params->{'period_id'} = $self->{api_client}->to_query_value($args{'period_id'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[object]', $response);
    return $_response_object;
}

#
# v1_externalmetrics_exchange_listing_get
#
# Listing of metrics available for specific exchange (both external and generic)
#
# @param string $exchange_id Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM) (required)
{
    my $params = {
    'exchange_id' => {
        data_type => 'string',
        description => 'Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_exchange_listing_get' } = {
        summary => 'Listing of metrics available for specific exchange (both external and generic)',
        params => $params,
        returns => 'ARRAY[V1MetricInfo]',
        };
}
# @return ARRAY[V1MetricInfo]
#
sub v1_externalmetrics_exchange_listing_get {
    my ($self, %args) = @_;

    # verify the required parameter 'exchange_id' is set
    unless (exists $args{'exchange_id'}) {
      croak("Missing the required parameter 'exchange_id' when calling v1_externalmetrics_exchange_listing_get");
    }

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/exchange/listing';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'exchange_id'}) {
        $query_params->{'exchange_id'} = $self->{api_client}->to_query_value($args{'exchange_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1MetricInfo]', $response);
    return $_response_object;
}

#
# v1_externalmetrics_exchanges_get
#
# Listing of all supported external exchanges
#
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_exchanges_get' } = {
        summary => 'Listing of all supported external exchanges',
        params => $params,
        returns => 'ARRAY[V1ExternalExchange]',
        };
}
# @return ARRAY[V1ExternalExchange]
#
sub v1_externalmetrics_exchanges_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/exchanges';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1ExternalExchange]', $response);
    return $_response_object;
}

#
# v1_externalmetrics_listing_get
#
# Listing of all supported metrics (both external and generic)
#
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'v1_externalmetrics_listing_get' } = {
        summary => 'Listing of all supported metrics (both external and generic)',
        params => $params,
        returns => 'ARRAY[V1MetricInfo]',
        };
}
# @return ARRAY[V1MetricInfo]
#
sub v1_externalmetrics_listing_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/externalmetrics/listing';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[V1MetricInfo]', $response);
    return $_response_object;
}

1;
