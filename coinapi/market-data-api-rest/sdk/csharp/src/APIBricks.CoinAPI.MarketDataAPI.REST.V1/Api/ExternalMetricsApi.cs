// <auto-generated>
/*
 * REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client;
using APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model;
using System.Diagnostics.CodeAnalysis;

namespace APIBricks.CoinAPI.MarketDataAPI.REST.V1.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IExternalMetricsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ExternalMetricsApiEvents Events { get; }

        /// <summary>
        /// Historical metrics for the asset from external sources
        /// </summary>
        /// <remarks>
        /// Get asset metrics history from external data providers. Data is typically aggregated daily.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)</param>
        /// <param name="assetId">Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60; - from supported assets list)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetHistoryGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsAssetHistoryGetApiResponse> V1ExternalmetricsAssetHistoryGetAsync(string metricId, string assetId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for the asset from external sources
        /// </summary>
        /// <remarks>
        /// Get asset metrics history from external data providers. Data is typically aggregated daily.
        /// </remarks>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)</param>
        /// <param name="assetId">Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60; - from supported assets list)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetHistoryGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsAssetHistoryGetApiResponse?> V1ExternalmetricsAssetHistoryGetOrDefaultAsync(string metricId, string assetId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of metrics available for specific asset
        /// </summary>
        /// <remarks>
        /// Get all metrics that are actually available for the specified asset from external providers.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Asset identifier (e.g., USDC, USDT)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetListingGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsAssetListingGetApiResponse> V1ExternalmetricsAssetListingGetAsync(string assetId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of metrics available for specific asset
        /// </summary>
        /// <remarks>
        /// Get all metrics that are actually available for the specified asset from external providers.
        /// </remarks>
        /// <param name="assetId">Asset identifier (e.g., USDC, USDT)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetListingGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsAssetListingGetApiResponse?> V1ExternalmetricsAssetListingGetOrDefaultAsync(string assetId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported external assets
        /// </summary>
        /// <remarks>
        /// Get all assets (primarily stablecoins) supported by external data providers.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetsGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsAssetsGetApiResponse> V1ExternalmetricsAssetsGetAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported external assets
        /// </summary>
        /// <remarks>
        /// Get all assets (primarily stablecoins) supported by external data providers.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetsGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsAssetsGetApiResponse?> V1ExternalmetricsAssetsGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for the chain from external sources
        /// </summary>
        /// <remarks>
        /// Get chain metrics history from external data providers. Data is typically aggregated daily.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)</param>
        /// <param name="chainId">Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60; - from supported chains list)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainHistoryGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsChainHistoryGetApiResponse> V1ExternalmetricsChainHistoryGetAsync(string metricId, string chainId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for the chain from external sources
        /// </summary>
        /// <remarks>
        /// Get chain metrics history from external data providers. Data is typically aggregated daily.
        /// </remarks>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)</param>
        /// <param name="chainId">Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60; - from supported chains list)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainHistoryGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsChainHistoryGetApiResponse?> V1ExternalmetricsChainHistoryGetOrDefaultAsync(string metricId, string chainId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of metrics available for specific chain
        /// </summary>
        /// <remarks>
        /// Get all metrics that are actually available for the specified blockchain chain from external providers.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainId">Chain identifier (e.g., ETHEREUM, ARBITRUM)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainListingGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsChainListingGetApiResponse> V1ExternalmetricsChainListingGetAsync(string chainId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of metrics available for specific chain
        /// </summary>
        /// <remarks>
        /// Get all metrics that are actually available for the specified blockchain chain from external providers.
        /// </remarks>
        /// <param name="chainId">Chain identifier (e.g., ETHEREUM, ARBITRUM)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainListingGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsChainListingGetApiResponse?> V1ExternalmetricsChainListingGetOrDefaultAsync(string chainId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported external chains
        /// </summary>
        /// <remarks>
        /// Get all blockchain chains supported by external data providers.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainsGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsChainsGetApiResponse> V1ExternalmetricsChainsGetAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported external chains
        /// </summary>
        /// <remarks>
        /// Get all blockchain chains supported by external data providers.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainsGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsChainsGetApiResponse?> V1ExternalmetricsChainsGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for the exchange from both external and internal sources
        /// </summary>
        /// <remarks>
        /// Get exchange metrics history from external data providers or internal sources based on metric type.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; for external, or generic metric IDs)</param>
        /// <param name="exchangeId">Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangeHistoryGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsExchangeHistoryGetApiResponse> V1ExternalmetricsExchangeHistoryGetAsync(string metricId, string exchangeId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for the exchange from both external and internal sources
        /// </summary>
        /// <remarks>
        /// Get exchange metrics history from external data providers or internal sources based on metric type.
        /// </remarks>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; for external, or generic metric IDs)</param>
        /// <param name="exchangeId">Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangeHistoryGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsExchangeHistoryGetApiResponse?> V1ExternalmetricsExchangeHistoryGetOrDefaultAsync(string metricId, string exchangeId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of metrics available for specific exchange (both external and generic)
        /// </summary>
        /// <remarks>
        /// Get all metrics that are actually available for the specified exchange from both external providers and internal sources.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangeListingGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsExchangeListingGetApiResponse> V1ExternalmetricsExchangeListingGetAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of metrics available for specific exchange (both external and generic)
        /// </summary>
        /// <remarks>
        /// Get all metrics that are actually available for the specified exchange from both external providers and internal sources.
        /// </remarks>
        /// <param name="exchangeId">Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangeListingGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsExchangeListingGetApiResponse?> V1ExternalmetricsExchangeListingGetOrDefaultAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported external exchanges
        /// </summary>
        /// <remarks>
        /// Get all exchanges that have mapping to external data providers for metrics that actually have sources.  Only returns exchanges that are properly mapped to external protocols for metrics with defined sources.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangesGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsExchangesGetApiResponse> V1ExternalmetricsExchangesGetAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported external exchanges
        /// </summary>
        /// <remarks>
        /// Get all exchanges that have mapping to external data providers for metrics that actually have sources.  Only returns exchanges that are properly mapped to external protocols for metrics with defined sources.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangesGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsExchangesGetApiResponse?> V1ExternalmetricsExchangesGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported metrics (both external and generic)
        /// </summary>
        /// <remarks>
        /// Get all metrics available from external data providers and internal generic metrics.  External metrics have detailed descriptions, while generic metrics are marked as such.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsListingGetApiResponse"/>&gt;</returns>
        Task<IV1ExternalmetricsListingGetApiResponse> V1ExternalmetricsListingGetAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported metrics (both external and generic)
        /// </summary>
        /// <remarks>
        /// Get all metrics available from external data providers and internal generic metrics.  External metrics have detailed descriptions, while generic metrics are marked as such.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsListingGetApiResponse"/>?&gt;</returns>
        Task<IV1ExternalmetricsListingGetApiResponse?> V1ExternalmetricsListingGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsAssetHistoryGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsAssetHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<Object>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsAssetListingGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsAssetListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1MetricInfo>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsAssetsGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsAssetsGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1ExternalAsset>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsChainHistoryGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsChainHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<Object>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsChainListingGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsChainListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1MetricInfo>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsChainsGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsChainsGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Chain>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsExchangeHistoryGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsExchangeHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<Object>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsExchangeListingGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsExchangeListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1MetricInfo>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsExchangesGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsExchangesGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1ExternalExchange>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExternalmetricsListingGetApiResponse"/>
    /// </summary>
    public interface IV1ExternalmetricsListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1MetricInfo>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ExternalMetricsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsAssetHistoryGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsAssetHistoryGet;

        internal void ExecuteOnV1ExternalmetricsAssetHistoryGet(ExternalMetricsApi.V1ExternalmetricsAssetHistoryGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsAssetHistoryGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsAssetHistoryGet(Exception exception)
        {
            OnErrorV1ExternalmetricsAssetHistoryGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsAssetListingGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsAssetListingGet;

        internal void ExecuteOnV1ExternalmetricsAssetListingGet(ExternalMetricsApi.V1ExternalmetricsAssetListingGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsAssetListingGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsAssetListingGet(Exception exception)
        {
            OnErrorV1ExternalmetricsAssetListingGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsAssetsGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsAssetsGet;

        internal void ExecuteOnV1ExternalmetricsAssetsGet(ExternalMetricsApi.V1ExternalmetricsAssetsGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsAssetsGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsAssetsGet(Exception exception)
        {
            OnErrorV1ExternalmetricsAssetsGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsChainHistoryGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsChainHistoryGet;

        internal void ExecuteOnV1ExternalmetricsChainHistoryGet(ExternalMetricsApi.V1ExternalmetricsChainHistoryGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsChainHistoryGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsChainHistoryGet(Exception exception)
        {
            OnErrorV1ExternalmetricsChainHistoryGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsChainListingGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsChainListingGet;

        internal void ExecuteOnV1ExternalmetricsChainListingGet(ExternalMetricsApi.V1ExternalmetricsChainListingGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsChainListingGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsChainListingGet(Exception exception)
        {
            OnErrorV1ExternalmetricsChainListingGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsChainsGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsChainsGet;

        internal void ExecuteOnV1ExternalmetricsChainsGet(ExternalMetricsApi.V1ExternalmetricsChainsGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsChainsGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsChainsGet(Exception exception)
        {
            OnErrorV1ExternalmetricsChainsGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsExchangeHistoryGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsExchangeHistoryGet;

        internal void ExecuteOnV1ExternalmetricsExchangeHistoryGet(ExternalMetricsApi.V1ExternalmetricsExchangeHistoryGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsExchangeHistoryGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsExchangeHistoryGet(Exception exception)
        {
            OnErrorV1ExternalmetricsExchangeHistoryGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsExchangeListingGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsExchangeListingGet;

        internal void ExecuteOnV1ExternalmetricsExchangeListingGet(ExternalMetricsApi.V1ExternalmetricsExchangeListingGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsExchangeListingGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsExchangeListingGet(Exception exception)
        {
            OnErrorV1ExternalmetricsExchangeListingGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsExchangesGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsExchangesGet;

        internal void ExecuteOnV1ExternalmetricsExchangesGet(ExternalMetricsApi.V1ExternalmetricsExchangesGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsExchangesGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsExchangesGet(Exception exception)
        {
            OnErrorV1ExternalmetricsExchangesGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExternalmetricsListingGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExternalmetricsListingGet;

        internal void ExecuteOnV1ExternalmetricsListingGet(ExternalMetricsApi.V1ExternalmetricsListingGetApiResponse apiResponse)
        {
            OnV1ExternalmetricsListingGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExternalmetricsListingGet(Exception exception)
        {
            OnErrorV1ExternalmetricsListingGet?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ExternalMetricsApi : IExternalMetricsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ExternalMetricsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ExternalMetricsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExternalMetricsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ExternalMetricsApi(ILogger<ExternalMetricsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ExternalMetricsApiEvents externalMetricsApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ExternalMetricsApi>();
            HttpClient = httpClient;
            Events = externalMetricsApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatV1ExternalmetricsAssetHistoryGet(ref string metricId, ref string assetId, ref Option<DateTime> timeStart, ref Option<DateTime> timeEnd, ref Option<string> timeFormat, ref Option<string> periodId, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <returns></returns>
        private void ValidateV1ExternalmetricsAssetHistoryGet(string metricId, string assetId, Option<string> timeFormat, Option<string> periodId)
        {
            if (metricId == null)
                throw new ArgumentNullException(nameof(metricId));

            if (assetId == null)
                throw new ArgumentNullException(nameof(assetId));

            if (timeFormat.IsSet && timeFormat.Value == null)
                throw new ArgumentNullException(nameof(timeFormat));

            if (periodId.IsSet && periodId.Value == null)
                throw new ArgumentNullException(nameof(periodId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void AfterV1ExternalmetricsAssetHistoryGetDefaultImplementation(IV1ExternalmetricsAssetHistoryGetApiResponse apiResponseLocalVar, string metricId, string assetId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsAssetHistoryGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, assetId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void AfterV1ExternalmetricsAssetHistoryGet(ref bool suppressDefaultLog, IV1ExternalmetricsAssetHistoryGetApiResponse apiResponseLocalVar, string metricId, string assetId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void OnErrorV1ExternalmetricsAssetHistoryGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string assetId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsAssetHistoryGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, assetId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void OnErrorV1ExternalmetricsAssetHistoryGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string assetId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Historical metrics for the asset from external sources Get asset metrics history from external data providers. Data is typically aggregated daily.
        /// </summary>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)</param>
        /// <param name="assetId">Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60; - from supported assets list)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsAssetHistoryGetApiResponse?> V1ExternalmetricsAssetHistoryGetOrDefaultAsync(string metricId, string assetId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsAssetHistoryGetAsync(metricId, assetId, timeStart, timeEnd, timeFormat, periodId, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Historical metrics for the asset from external sources Get asset metrics history from external data providers. Data is typically aggregated daily.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)</param>
        /// <param name="assetId">Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60; - from supported assets list)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsAssetHistoryGetApiResponse> V1ExternalmetricsAssetHistoryGetAsync(string metricId, string assetId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExternalmetricsAssetHistoryGet(metricId, assetId, timeFormat, periodId);

                FormatV1ExternalmetricsAssetHistoryGet(ref metricId, ref assetId, ref timeStart, ref timeEnd, ref timeFormat, ref periodId, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/asset/history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/asset/history");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId);
                    parseQueryStringLocalVar["asset_id"] = ClientUtils.ParameterToString(assetId);

                    if (timeStart.IsSet)
                        parseQueryStringLocalVar["time_start"] = ClientUtils.ParameterToString(timeStart.Value);

                    if (timeEnd.IsSet)
                        parseQueryStringLocalVar["time_end"] = ClientUtils.ParameterToString(timeEnd.Value);

                    if (timeFormat.IsSet)
                        parseQueryStringLocalVar["time_format"] = ClientUtils.ParameterToString(timeFormat.Value);

                    if (periodId.IsSet)
                        parseQueryStringLocalVar["period_id"] = ClientUtils.ParameterToString(periodId.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsAssetHistoryGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsAssetHistoryGetApiResponse>();

                        V1ExternalmetricsAssetHistoryGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/asset/history", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsAssetHistoryGetDefaultImplementation(apiResponseLocalVar, metricId, assetId, timeStart, timeEnd, timeFormat, periodId, limit);

                        Events.ExecuteOnV1ExternalmetricsAssetHistoryGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsAssetHistoryGetDefaultImplementation(e, "/v1/externalmetrics/asset/history", uriBuilderLocalVar.Path, metricId, assetId, timeStart, timeEnd, timeFormat, periodId, limit);
                Events.ExecuteOnErrorV1ExternalmetricsAssetHistoryGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsAssetHistoryGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsAssetHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsAssetHistoryGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsAssetHistoryGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsAssetHistoryGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsAssetHistoryGetApiResponse(ILogger<V1ExternalmetricsAssetHistoryGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Object>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Object>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Object>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExternalmetricsAssetListingGet(ref string assetId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assetId"></param>
        /// <returns></returns>
        private void ValidateV1ExternalmetricsAssetListingGet(string assetId)
        {
            if (assetId == null)
                throw new ArgumentNullException(nameof(assetId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetId"></param>
        private void AfterV1ExternalmetricsAssetListingGetDefaultImplementation(IV1ExternalmetricsAssetListingGetApiResponse apiResponseLocalVar, string assetId)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsAssetListingGet(ref suppressDefaultLog, apiResponseLocalVar, assetId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetId"></param>
        partial void AfterV1ExternalmetricsAssetListingGet(ref bool suppressDefaultLog, IV1ExternalmetricsAssetListingGetApiResponse apiResponseLocalVar, string assetId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetId"></param>
        private void OnErrorV1ExternalmetricsAssetListingGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsAssetListingGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assetId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetId"></param>
        partial void OnErrorV1ExternalmetricsAssetListingGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetId);

        /// <summary>
        /// Listing of metrics available for specific asset Get all metrics that are actually available for the specified asset from external providers.
        /// </summary>
        /// <param name="assetId">Asset identifier (e.g., USDC, USDT)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsAssetListingGetApiResponse?> V1ExternalmetricsAssetListingGetOrDefaultAsync(string assetId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsAssetListingGetAsync(assetId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of metrics available for specific asset Get all metrics that are actually available for the specified asset from external providers.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Asset identifier (e.g., USDC, USDT)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsAssetListingGetApiResponse> V1ExternalmetricsAssetListingGetAsync(string assetId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExternalmetricsAssetListingGet(assetId);

                FormatV1ExternalmetricsAssetListingGet(ref assetId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/asset/listing"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/asset/listing");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["asset_id"] = ClientUtils.ParameterToString(assetId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsAssetListingGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsAssetListingGetApiResponse>();

                        V1ExternalmetricsAssetListingGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/asset/listing", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsAssetListingGetDefaultImplementation(apiResponseLocalVar, assetId);

                        Events.ExecuteOnV1ExternalmetricsAssetListingGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsAssetListingGetDefaultImplementation(e, "/v1/externalmetrics/asset/listing", uriBuilderLocalVar.Path, assetId);
                Events.ExecuteOnErrorV1ExternalmetricsAssetListingGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsAssetListingGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsAssetListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsAssetListingGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsAssetListingGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsAssetListingGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsAssetListingGetApiResponse(ILogger<V1ExternalmetricsAssetListingGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1MetricInfo>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1MetricInfo>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1MetricInfo>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterV1ExternalmetricsAssetsGetDefaultImplementation(IV1ExternalmetricsAssetsGetApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsAssetsGet(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterV1ExternalmetricsAssetsGet(ref bool suppressDefaultLog, IV1ExternalmetricsAssetsGetApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorV1ExternalmetricsAssetsGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsAssetsGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorV1ExternalmetricsAssetsGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Listing of all supported external assets Get all assets (primarily stablecoins) supported by external data providers.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetsGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsAssetsGetApiResponse?> V1ExternalmetricsAssetsGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsAssetsGetAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of all supported external assets Get all assets (primarily stablecoins) supported by external data providers.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsAssetsGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsAssetsGetApiResponse> V1ExternalmetricsAssetsGetAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/assets"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/assets");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsAssetsGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsAssetsGetApiResponse>();

                        V1ExternalmetricsAssetsGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/assets", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsAssetsGetDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnV1ExternalmetricsAssetsGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsAssetsGetDefaultImplementation(e, "/v1/externalmetrics/assets", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorV1ExternalmetricsAssetsGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsAssetsGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsAssetsGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsAssetsGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsAssetsGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsAssetsGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsAssetsGetApiResponse(ILogger<V1ExternalmetricsAssetsGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1ExternalAsset>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1ExternalAsset>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1ExternalAsset>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExternalmetricsChainHistoryGet(ref string metricId, ref string chainId, ref Option<DateTime> timeStart, ref Option<DateTime> timeEnd, ref Option<string> timeFormat, ref Option<string> periodId, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="chainId"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <returns></returns>
        private void ValidateV1ExternalmetricsChainHistoryGet(string metricId, string chainId, Option<string> timeFormat, Option<string> periodId)
        {
            if (metricId == null)
                throw new ArgumentNullException(nameof(metricId));

            if (chainId == null)
                throw new ArgumentNullException(nameof(chainId));

            if (timeFormat.IsSet && timeFormat.Value == null)
                throw new ArgumentNullException(nameof(timeFormat));

            if (periodId.IsSet && periodId.Value == null)
                throw new ArgumentNullException(nameof(periodId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="chainId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void AfterV1ExternalmetricsChainHistoryGetDefaultImplementation(IV1ExternalmetricsChainHistoryGetApiResponse apiResponseLocalVar, string metricId, string chainId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsChainHistoryGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, chainId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="chainId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void AfterV1ExternalmetricsChainHistoryGet(ref bool suppressDefaultLog, IV1ExternalmetricsChainHistoryGetApiResponse apiResponseLocalVar, string metricId, string chainId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="chainId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void OnErrorV1ExternalmetricsChainHistoryGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string chainId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsChainHistoryGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, chainId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="chainId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void OnErrorV1ExternalmetricsChainHistoryGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string chainId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Historical metrics for the chain from external sources Get chain metrics history from external data providers. Data is typically aggregated daily.
        /// </summary>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)</param>
        /// <param name="chainId">Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60; - from supported chains list)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsChainHistoryGetApiResponse?> V1ExternalmetricsChainHistoryGetOrDefaultAsync(string metricId, string chainId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsChainHistoryGetAsync(metricId, chainId, timeStart, timeEnd, timeFormat, periodId, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Historical metrics for the chain from external sources Get chain metrics history from external data providers. Data is typically aggregated daily.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)</param>
        /// <param name="chainId">Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60; - from supported chains list)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsChainHistoryGetApiResponse> V1ExternalmetricsChainHistoryGetAsync(string metricId, string chainId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExternalmetricsChainHistoryGet(metricId, chainId, timeFormat, periodId);

                FormatV1ExternalmetricsChainHistoryGet(ref metricId, ref chainId, ref timeStart, ref timeEnd, ref timeFormat, ref periodId, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/chain/history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/chain/history");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId);
                    parseQueryStringLocalVar["chain_id"] = ClientUtils.ParameterToString(chainId);

                    if (timeStart.IsSet)
                        parseQueryStringLocalVar["time_start"] = ClientUtils.ParameterToString(timeStart.Value);

                    if (timeEnd.IsSet)
                        parseQueryStringLocalVar["time_end"] = ClientUtils.ParameterToString(timeEnd.Value);

                    if (timeFormat.IsSet)
                        parseQueryStringLocalVar["time_format"] = ClientUtils.ParameterToString(timeFormat.Value);

                    if (periodId.IsSet)
                        parseQueryStringLocalVar["period_id"] = ClientUtils.ParameterToString(periodId.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsChainHistoryGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsChainHistoryGetApiResponse>();

                        V1ExternalmetricsChainHistoryGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/chain/history", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsChainHistoryGetDefaultImplementation(apiResponseLocalVar, metricId, chainId, timeStart, timeEnd, timeFormat, periodId, limit);

                        Events.ExecuteOnV1ExternalmetricsChainHistoryGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsChainHistoryGetDefaultImplementation(e, "/v1/externalmetrics/chain/history", uriBuilderLocalVar.Path, metricId, chainId, timeStart, timeEnd, timeFormat, periodId, limit);
                Events.ExecuteOnErrorV1ExternalmetricsChainHistoryGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsChainHistoryGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsChainHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsChainHistoryGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsChainHistoryGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsChainHistoryGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsChainHistoryGetApiResponse(ILogger<V1ExternalmetricsChainHistoryGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Object>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Object>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Object>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExternalmetricsChainListingGet(ref string chainId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="chainId"></param>
        /// <returns></returns>
        private void ValidateV1ExternalmetricsChainListingGet(string chainId)
        {
            if (chainId == null)
                throw new ArgumentNullException(nameof(chainId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="chainId"></param>
        private void AfterV1ExternalmetricsChainListingGetDefaultImplementation(IV1ExternalmetricsChainListingGetApiResponse apiResponseLocalVar, string chainId)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsChainListingGet(ref suppressDefaultLog, apiResponseLocalVar, chainId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="chainId"></param>
        partial void AfterV1ExternalmetricsChainListingGet(ref bool suppressDefaultLog, IV1ExternalmetricsChainListingGetApiResponse apiResponseLocalVar, string chainId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="chainId"></param>
        private void OnErrorV1ExternalmetricsChainListingGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string chainId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsChainListingGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, chainId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="chainId"></param>
        partial void OnErrorV1ExternalmetricsChainListingGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string chainId);

        /// <summary>
        /// Listing of metrics available for specific chain Get all metrics that are actually available for the specified blockchain chain from external providers.
        /// </summary>
        /// <param name="chainId">Chain identifier (e.g., ETHEREUM, ARBITRUM)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsChainListingGetApiResponse?> V1ExternalmetricsChainListingGetOrDefaultAsync(string chainId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsChainListingGetAsync(chainId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of metrics available for specific chain Get all metrics that are actually available for the specified blockchain chain from external providers.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainId">Chain identifier (e.g., ETHEREUM, ARBITRUM)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsChainListingGetApiResponse> V1ExternalmetricsChainListingGetAsync(string chainId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExternalmetricsChainListingGet(chainId);

                FormatV1ExternalmetricsChainListingGet(ref chainId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/chain/listing"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/chain/listing");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["chain_id"] = ClientUtils.ParameterToString(chainId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsChainListingGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsChainListingGetApiResponse>();

                        V1ExternalmetricsChainListingGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/chain/listing", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsChainListingGetDefaultImplementation(apiResponseLocalVar, chainId);

                        Events.ExecuteOnV1ExternalmetricsChainListingGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsChainListingGetDefaultImplementation(e, "/v1/externalmetrics/chain/listing", uriBuilderLocalVar.Path, chainId);
                Events.ExecuteOnErrorV1ExternalmetricsChainListingGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsChainListingGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsChainListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsChainListingGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsChainListingGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsChainListingGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsChainListingGetApiResponse(ILogger<V1ExternalmetricsChainListingGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1MetricInfo>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1MetricInfo>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1MetricInfo>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterV1ExternalmetricsChainsGetDefaultImplementation(IV1ExternalmetricsChainsGetApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsChainsGet(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterV1ExternalmetricsChainsGet(ref bool suppressDefaultLog, IV1ExternalmetricsChainsGetApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorV1ExternalmetricsChainsGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsChainsGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorV1ExternalmetricsChainsGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Listing of all supported external chains Get all blockchain chains supported by external data providers.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainsGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsChainsGetApiResponse?> V1ExternalmetricsChainsGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsChainsGetAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of all supported external chains Get all blockchain chains supported by external data providers.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsChainsGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsChainsGetApiResponse> V1ExternalmetricsChainsGetAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/chains"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/chains");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsChainsGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsChainsGetApiResponse>();

                        V1ExternalmetricsChainsGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/chains", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsChainsGetDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnV1ExternalmetricsChainsGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsChainsGetDefaultImplementation(e, "/v1/externalmetrics/chains", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorV1ExternalmetricsChainsGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsChainsGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsChainsGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsChainsGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsChainsGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsChainsGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsChainsGetApiResponse(ILogger<V1ExternalmetricsChainsGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Chain>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Chain>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Chain>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExternalmetricsExchangeHistoryGet(ref string metricId, ref string exchangeId, ref Option<DateTime> timeStart, ref Option<DateTime> timeEnd, ref Option<string> timeFormat, ref Option<string> periodId, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <returns></returns>
        private void ValidateV1ExternalmetricsExchangeHistoryGet(string metricId, string exchangeId, Option<string> timeFormat, Option<string> periodId)
        {
            if (metricId == null)
                throw new ArgumentNullException(nameof(metricId));

            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));

            if (timeFormat.IsSet && timeFormat.Value == null)
                throw new ArgumentNullException(nameof(timeFormat));

            if (periodId.IsSet && periodId.Value == null)
                throw new ArgumentNullException(nameof(periodId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void AfterV1ExternalmetricsExchangeHistoryGetDefaultImplementation(IV1ExternalmetricsExchangeHistoryGetApiResponse apiResponseLocalVar, string metricId, string exchangeId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsExchangeHistoryGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void AfterV1ExternalmetricsExchangeHistoryGet(ref bool suppressDefaultLog, IV1ExternalmetricsExchangeHistoryGetApiResponse apiResponseLocalVar, string metricId, string exchangeId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void OnErrorV1ExternalmetricsExchangeHistoryGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string exchangeId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsExchangeHistoryGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void OnErrorV1ExternalmetricsExchangeHistoryGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string exchangeId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Historical metrics for the exchange from both external and internal sources Get exchange metrics history from external data providers or internal sources based on metric type.
        /// </summary>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; for external, or generic metric IDs)</param>
        /// <param name="exchangeId">Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangeHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsExchangeHistoryGetApiResponse?> V1ExternalmetricsExchangeHistoryGetOrDefaultAsync(string metricId, string exchangeId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsExchangeHistoryGetAsync(metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Historical metrics for the exchange from both external and internal sources Get exchange metrics history from external data providers or internal sources based on metric type.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; for external, or generic metric IDs)</param>
        /// <param name="exchangeId">Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangeHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsExchangeHistoryGetApiResponse> V1ExternalmetricsExchangeHistoryGetAsync(string metricId, string exchangeId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExternalmetricsExchangeHistoryGet(metricId, exchangeId, timeFormat, periodId);

                FormatV1ExternalmetricsExchangeHistoryGet(ref metricId, ref exchangeId, ref timeStart, ref timeEnd, ref timeFormat, ref periodId, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/exchange/history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/exchange/history");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId);
                    parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId);

                    if (timeStart.IsSet)
                        parseQueryStringLocalVar["time_start"] = ClientUtils.ParameterToString(timeStart.Value);

                    if (timeEnd.IsSet)
                        parseQueryStringLocalVar["time_end"] = ClientUtils.ParameterToString(timeEnd.Value);

                    if (timeFormat.IsSet)
                        parseQueryStringLocalVar["time_format"] = ClientUtils.ParameterToString(timeFormat.Value);

                    if (periodId.IsSet)
                        parseQueryStringLocalVar["period_id"] = ClientUtils.ParameterToString(periodId.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsExchangeHistoryGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsExchangeHistoryGetApiResponse>();

                        V1ExternalmetricsExchangeHistoryGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/exchange/history", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsExchangeHistoryGetDefaultImplementation(apiResponseLocalVar, metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit);

                        Events.ExecuteOnV1ExternalmetricsExchangeHistoryGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsExchangeHistoryGetDefaultImplementation(e, "/v1/externalmetrics/exchange/history", uriBuilderLocalVar.Path, metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit);
                Events.ExecuteOnErrorV1ExternalmetricsExchangeHistoryGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsExchangeHistoryGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsExchangeHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsExchangeHistoryGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsExchangeHistoryGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsExchangeHistoryGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsExchangeHistoryGetApiResponse(ILogger<V1ExternalmetricsExchangeHistoryGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Object>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Object>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Object>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExternalmetricsExchangeListingGet(ref string exchangeId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="exchangeId"></param>
        /// <returns></returns>
        private void ValidateV1ExternalmetricsExchangeListingGet(string exchangeId)
        {
            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        private void AfterV1ExternalmetricsExchangeListingGetDefaultImplementation(IV1ExternalmetricsExchangeListingGetApiResponse apiResponseLocalVar, string exchangeId)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsExchangeListingGet(ref suppressDefaultLog, apiResponseLocalVar, exchangeId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        partial void AfterV1ExternalmetricsExchangeListingGet(ref bool suppressDefaultLog, IV1ExternalmetricsExchangeListingGetApiResponse apiResponseLocalVar, string exchangeId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        private void OnErrorV1ExternalmetricsExchangeListingGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsExchangeListingGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, exchangeId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        partial void OnErrorV1ExternalmetricsExchangeListingGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId);

        /// <summary>
        /// Listing of metrics available for specific exchange (both external and generic) Get all metrics that are actually available for the specified exchange from both external providers and internal sources.
        /// </summary>
        /// <param name="exchangeId">Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangeListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsExchangeListingGetApiResponse?> V1ExternalmetricsExchangeListingGetOrDefaultAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsExchangeListingGetAsync(exchangeId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of metrics available for specific exchange (both external and generic) Get all metrics that are actually available for the specified exchange from both external providers and internal sources.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangeListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsExchangeListingGetApiResponse> V1ExternalmetricsExchangeListingGetAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExternalmetricsExchangeListingGet(exchangeId);

                FormatV1ExternalmetricsExchangeListingGet(ref exchangeId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/exchange/listing"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/exchange/listing");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsExchangeListingGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsExchangeListingGetApiResponse>();

                        V1ExternalmetricsExchangeListingGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/exchange/listing", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsExchangeListingGetDefaultImplementation(apiResponseLocalVar, exchangeId);

                        Events.ExecuteOnV1ExternalmetricsExchangeListingGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsExchangeListingGetDefaultImplementation(e, "/v1/externalmetrics/exchange/listing", uriBuilderLocalVar.Path, exchangeId);
                Events.ExecuteOnErrorV1ExternalmetricsExchangeListingGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsExchangeListingGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsExchangeListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsExchangeListingGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsExchangeListingGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsExchangeListingGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsExchangeListingGetApiResponse(ILogger<V1ExternalmetricsExchangeListingGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1MetricInfo>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1MetricInfo>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1MetricInfo>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterV1ExternalmetricsExchangesGetDefaultImplementation(IV1ExternalmetricsExchangesGetApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsExchangesGet(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterV1ExternalmetricsExchangesGet(ref bool suppressDefaultLog, IV1ExternalmetricsExchangesGetApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorV1ExternalmetricsExchangesGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsExchangesGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorV1ExternalmetricsExchangesGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Listing of all supported external exchanges Get all exchanges that have mapping to external data providers for metrics that actually have sources.  Only returns exchanges that are properly mapped to external protocols for metrics with defined sources.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangesGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsExchangesGetApiResponse?> V1ExternalmetricsExchangesGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsExchangesGetAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of all supported external exchanges Get all exchanges that have mapping to external data providers for metrics that actually have sources.  Only returns exchanges that are properly mapped to external protocols for metrics with defined sources.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsExchangesGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsExchangesGetApiResponse> V1ExternalmetricsExchangesGetAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/exchanges"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/exchanges");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsExchangesGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsExchangesGetApiResponse>();

                        V1ExternalmetricsExchangesGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/exchanges", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsExchangesGetDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnV1ExternalmetricsExchangesGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsExchangesGetDefaultImplementation(e, "/v1/externalmetrics/exchanges", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorV1ExternalmetricsExchangesGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsExchangesGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsExchangesGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsExchangesGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsExchangesGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsExchangesGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsExchangesGetApiResponse(ILogger<V1ExternalmetricsExchangesGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1ExternalExchange>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1ExternalExchange>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1ExternalExchange>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterV1ExternalmetricsListingGetDefaultImplementation(IV1ExternalmetricsListingGetApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterV1ExternalmetricsListingGet(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterV1ExternalmetricsListingGet(ref bool suppressDefaultLog, IV1ExternalmetricsListingGetApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorV1ExternalmetricsListingGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExternalmetricsListingGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorV1ExternalmetricsListingGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Listing of all supported metrics (both external and generic) Get all metrics available from external data providers and internal generic metrics.  External metrics have detailed descriptions, while generic metrics are marked as such.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsListingGetApiResponse?> V1ExternalmetricsListingGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExternalmetricsListingGetAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of all supported metrics (both external and generic) Get all metrics available from external data providers and internal generic metrics.  External metrics have detailed descriptions, while generic metrics are marked as such.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExternalmetricsListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExternalmetricsListingGetApiResponse> V1ExternalmetricsListingGetAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/externalmetrics/listing"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/externalmetrics/listing");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExternalmetricsListingGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExternalmetricsListingGetApiResponse>();

                        V1ExternalmetricsListingGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/externalmetrics/listing", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExternalmetricsListingGetDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnV1ExternalmetricsListingGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExternalmetricsListingGetDefaultImplementation(e, "/v1/externalmetrics/listing", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorV1ExternalmetricsListingGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExternalmetricsListingGetApiResponse"/>
        /// </summary>
        public partial class V1ExternalmetricsListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExternalmetricsListingGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExternalmetricsListingGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExternalmetricsListingGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExternalmetricsListingGetApiResponse(ILogger<V1ExternalmetricsListingGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1MetricInfo>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1MetricInfo>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1MetricInfo>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
