// <auto-generated>
/*
 * REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client;
using APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model;
using System.Diagnostics.CodeAnalysis;

namespace APIBricks.CoinAPI.MarketDataAPI.REST.V1.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IMetadataApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        MetadataApiEvents Events { get; }

        /// <summary>
        /// List all assets by asset ID
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The asset ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsAssetIdGetApiResponse"/>&gt;</returns>
        Task<IV1AssetsAssetIdGetApiResponse> V1AssetsAssetIdGetAsync(string assetId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all assets by asset ID
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="assetId">The asset ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsAssetIdGetApiResponse"/>?&gt;</returns>
        Task<IV1AssetsAssetIdGetApiResponse?> V1AssetsAssetIdGetOrDefaultAsync(string assetId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all assets
        /// </summary>
        /// <remarks>
        /// Retrieves all assets.                :::info  Our asset identifiers are aligned with the ISO 4217 currency codes standard only for fiat money (government or law regulated currency).  :::                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific asset. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response. (optional, eg. &#x60;BTC;ETH&#x60;). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsGetApiResponse"/>&gt;</returns>
        Task<IV1AssetsGetApiResponse> V1AssetsGetAsync(Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all assets
        /// </summary>
        /// <remarks>
        /// Retrieves all assets.                :::info  Our asset identifiers are aligned with the ISO 4217 currency codes standard only for fiat money (government or law regulated currency).  :::                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific asset. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </remarks>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response. (optional, eg. &#x60;BTC;ETH&#x60;). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsGetApiResponse"/>?&gt;</returns>
        Task<IV1AssetsGetApiResponse?> V1AssetsGetOrDefaultAsync(Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all asset icons
        /// </summary>
        /// <remarks>
        /// Gets the list of icons (of the given size) for all the assets.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The size of the icons.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsIconsSizeGetApiResponse"/>&gt;</returns>
        Task<IV1AssetsIconsSizeGetApiResponse> V1AssetsIconsSizeGetAsync(int size, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all asset icons
        /// </summary>
        /// <remarks>
        /// Gets the list of icons (of the given size) for all the assets.
        /// </remarks>
        /// <param name="size">The size of the icons.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsIconsSizeGetApiResponse"/>?&gt;</returns>
        Task<IV1AssetsIconsSizeGetApiResponse?> V1AssetsIconsSizeGetOrDefaultAsync(int size, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchanges by exchange_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The ID of the exchange.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesExchangeIdGetApiResponse"/>&gt;</returns>
        Task<IV1ExchangesExchangeIdGetApiResponse> V1ExchangesExchangeIdGetAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchanges by exchange_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="exchangeId">The ID of the exchange.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesExchangeIdGetApiResponse"/>?&gt;</returns>
        Task<IV1ExchangesExchangeIdGetApiResponse?> V1ExchangesExchangeIdGetOrDefaultAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchanges
        /// </summary>
        /// <remarks>
        /// Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterExchangeId">Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesGetApiResponse"/>&gt;</returns>
        Task<IV1ExchangesGetApiResponse> V1ExchangesGetAsync(Option<string> filterExchangeId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchanges
        /// </summary>
        /// <remarks>
        /// Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </remarks>
        /// <param name="filterExchangeId">Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesGetApiResponse"/>?&gt;</returns>
        Task<IV1ExchangesGetApiResponse?> V1ExchangesGetOrDefaultAsync(Option<string> filterExchangeId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List of icons for the exchanges
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The size of the icons.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesIconsSizeGetApiResponse"/>&gt;</returns>
        Task<IV1ExchangesIconsSizeGetApiResponse> V1ExchangesIconsSizeGetAsync(int size, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List of icons for the exchanges
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="size">The size of the icons.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesIconsSizeGetApiResponse"/>?&gt;</returns>
        Task<IV1ExchangesIconsSizeGetApiResponse?> V1ExchangesIconsSizeGetOrDefaultAsync(int size, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List of symbols for the exchange
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The ID of the exchange (from the Metadata -&gt; Exchanges)</param>
        /// <param name="filterSymbolId">The filter for symbol ID. (optional)</param>
        /// <param name="filterAssetId">The filter for asset ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsExchangeIdGetApiResponse"/>&gt;</returns>
        Task<IV1SymbolsExchangeIdGetApiResponse> V1SymbolsExchangeIdGetAsync(string exchangeId, Option<string> filterSymbolId = default, Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List of symbols for the exchange
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="exchangeId">The ID of the exchange (from the Metadata -&gt; Exchanges)</param>
        /// <param name="filterSymbolId">The filter for symbol ID. (optional)</param>
        /// <param name="filterAssetId">The filter for asset ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsExchangeIdGetApiResponse"/>?&gt;</returns>
        Task<IV1SymbolsExchangeIdGetApiResponse?> V1SymbolsExchangeIdGetOrDefaultAsync(string exchangeId, Option<string> filterSymbolId = default, Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all symbols
        /// </summary>
        /// <remarks>
        /// Retrieves all symbols with optional filtering.                :::info  \&quot;price_precision\&quot; and \&quot;size_precision\&quot; are data precisions and are not always the same precisions used for trading eg. for the \&quot;BINANCE\&quot; exchanges.  :::                :::info  You should not assume that the market data will be always within the resolution provided by the \&quot;price_precision\&quot; and \&quot;size_precision\&quot;. The fact that the precision values can be derived from a posterior implies the fact that this data could be delayed, also it can be changed by the data source without notice and we will immediately deliver data with the new precision while could not update the precision values in this endpoint immediately.  :::                ### Symbol identifier                Our symbol identifier is created using a pattern that depends on symbol type.                Type | &#x60;symbol_id&#x60; pattern  - -- -- -- -- | - -- -- -- --  SPOT | &#x60;{exchange_id}_SPOT_{asset_id_base}_{asset_id_quote}&#x60;  FUTURES | &#x60;{exchange_id}_FTS_{asset_id_base}_{asset_id_quote}_{YYMMDD of future_delivery_time}&#x60;  OPTION | &#x60;{exchange_id}_OPT_{asset_id_base}_{asset_id_quote}_{YYMMDD of option_expiration_time}_{option_strike_price}_{option_type_is_call as C/P}&#x60;  PERPETUAL | &#x60;{exchange_id}_PERP_{asset_id_base}_{asset_id_quote}&#x60;  INDEX | &#x60;{exchange_id}_IDX_{index_id}&#x60;  CREDIT | &#x60;{exchange_id}_CRE_{asset_id_base}&#x60;  CONTACT  | &#x60;{exchange_id}_COT_{contract_id}&#x60;                :::info  In the unlikely event when the \&quot;symbol_id\&quot; for more than one market is the same. We will append the additional term (prefixed with the \&quot;_\&quot;) at the end of the duplicated identifiers to differentiate them.  :::info                ### Symbol types list (enumeration of &#x60;symbol_type&#x60; output variable)                Type | Name | Description  - -- -- -- - | - | - -- -- -- -- --  SPOT | FX Spot | Agreement to exchange one asset for another one *(e.g. Buy BTC for USD)*  FUTURES | Futures contract | FX Spot derivative contract where traders agree to trade fx spot at predetermined future time  OPTION | Option contract | FX Spot derivative contract where traders agree to trade right to require buy or sell of fx spot at agreed price on exercise date  PERPETUAL | Perpetual contract | FX Spot derivative contract where traders agree to trade fx spot continously without predetermined future delivery time  INDEX | Index | Statistical composite that measures changes in the economy or markets.  CREDIT | Credit/Funding | Margin funding contract. Order book displays lending offers and borrow bids. Price represents the daily rate.  CONTRACT | Contract | Represents other types of financial instruments *(e.g. spreads, interest rate swap)*                ### Additional output variables for &#x60;symbol_type &#x3D; INDEX&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  index_id | Index identifier  index_display_name | Human readable name of the index *(optional)*  index_display_description | Description of the index *(optional)*                ### Additional output variables for &#x60;symbol_type &#x3D; FUTURES&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  future_delivery_time | Predetermined time of futures contract delivery date in ISO 8601  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; PERPETUAL&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; OPTION&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  option_type_is_call | Boolean value representing option type. &#x60;true&#x60; for Call options, &#x60;false&#x60; for Put options  option_strike_price | Price at which option contract can be exercised  option_contract_unit | Base asset amount of underlying spot which single option represents  option_exercise_style | Option exercise style. Can be &#x60;EUROPEAN&#x60; or &#x60;AMERICAN&#x60;  option_expiration_time | Option contract expiration time in ISO 8601                ### Additional output variables for &#x60;symbol_type &#x3D; CONTRACT&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  contract_delivery_time | Predetermined time of contract delivery date in ISO 8601  contract_unit | Contact size *(eg. 10 BTC if &#x60;contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  contract_unit_asset | Identifier of the asset used to denominate the contract unit  contract_id | Identifier of contract by the exchange
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSymbolId">Comma or semicolon delimited parts of symbol identifier used to filter response. (optional, eg. &#x60;BITSTAMP&#x60;_ or &#x60;BINANCE_SPOT_&#x60;) (optional)</param>
        /// <param name="filterExchangeId">The filter for exchange ID. (optional)</param>
        /// <param name="filterAssetId">The filter for asset ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsGetApiResponse"/>&gt;</returns>
        Task<IV1SymbolsGetApiResponse> V1SymbolsGetAsync(Option<string> filterSymbolId = default, Option<string> filterExchangeId = default, Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all symbols
        /// </summary>
        /// <remarks>
        /// Retrieves all symbols with optional filtering.                :::info  \&quot;price_precision\&quot; and \&quot;size_precision\&quot; are data precisions and are not always the same precisions used for trading eg. for the \&quot;BINANCE\&quot; exchanges.  :::                :::info  You should not assume that the market data will be always within the resolution provided by the \&quot;price_precision\&quot; and \&quot;size_precision\&quot;. The fact that the precision values can be derived from a posterior implies the fact that this data could be delayed, also it can be changed by the data source without notice and we will immediately deliver data with the new precision while could not update the precision values in this endpoint immediately.  :::                ### Symbol identifier                Our symbol identifier is created using a pattern that depends on symbol type.                Type | &#x60;symbol_id&#x60; pattern  - -- -- -- -- | - -- -- -- --  SPOT | &#x60;{exchange_id}_SPOT_{asset_id_base}_{asset_id_quote}&#x60;  FUTURES | &#x60;{exchange_id}_FTS_{asset_id_base}_{asset_id_quote}_{YYMMDD of future_delivery_time}&#x60;  OPTION | &#x60;{exchange_id}_OPT_{asset_id_base}_{asset_id_quote}_{YYMMDD of option_expiration_time}_{option_strike_price}_{option_type_is_call as C/P}&#x60;  PERPETUAL | &#x60;{exchange_id}_PERP_{asset_id_base}_{asset_id_quote}&#x60;  INDEX | &#x60;{exchange_id}_IDX_{index_id}&#x60;  CREDIT | &#x60;{exchange_id}_CRE_{asset_id_base}&#x60;  CONTACT  | &#x60;{exchange_id}_COT_{contract_id}&#x60;                :::info  In the unlikely event when the \&quot;symbol_id\&quot; for more than one market is the same. We will append the additional term (prefixed with the \&quot;_\&quot;) at the end of the duplicated identifiers to differentiate them.  :::info                ### Symbol types list (enumeration of &#x60;symbol_type&#x60; output variable)                Type | Name | Description  - -- -- -- - | - | - -- -- -- -- --  SPOT | FX Spot | Agreement to exchange one asset for another one *(e.g. Buy BTC for USD)*  FUTURES | Futures contract | FX Spot derivative contract where traders agree to trade fx spot at predetermined future time  OPTION | Option contract | FX Spot derivative contract where traders agree to trade right to require buy or sell of fx spot at agreed price on exercise date  PERPETUAL | Perpetual contract | FX Spot derivative contract where traders agree to trade fx spot continously without predetermined future delivery time  INDEX | Index | Statistical composite that measures changes in the economy or markets.  CREDIT | Credit/Funding | Margin funding contract. Order book displays lending offers and borrow bids. Price represents the daily rate.  CONTRACT | Contract | Represents other types of financial instruments *(e.g. spreads, interest rate swap)*                ### Additional output variables for &#x60;symbol_type &#x3D; INDEX&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  index_id | Index identifier  index_display_name | Human readable name of the index *(optional)*  index_display_description | Description of the index *(optional)*                ### Additional output variables for &#x60;symbol_type &#x3D; FUTURES&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  future_delivery_time | Predetermined time of futures contract delivery date in ISO 8601  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; PERPETUAL&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; OPTION&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  option_type_is_call | Boolean value representing option type. &#x60;true&#x60; for Call options, &#x60;false&#x60; for Put options  option_strike_price | Price at which option contract can be exercised  option_contract_unit | Base asset amount of underlying spot which single option represents  option_exercise_style | Option exercise style. Can be &#x60;EUROPEAN&#x60; or &#x60;AMERICAN&#x60;  option_expiration_time | Option contract expiration time in ISO 8601                ### Additional output variables for &#x60;symbol_type &#x3D; CONTRACT&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  contract_delivery_time | Predetermined time of contract delivery date in ISO 8601  contract_unit | Contact size *(eg. 10 BTC if &#x60;contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  contract_unit_asset | Identifier of the asset used to denominate the contract unit  contract_id | Identifier of contract by the exchange
        /// </remarks>
        /// <param name="filterSymbolId">Comma or semicolon delimited parts of symbol identifier used to filter response. (optional, eg. &#x60;BITSTAMP&#x60;_ or &#x60;BINANCE_SPOT_&#x60;) (optional)</param>
        /// <param name="filterExchangeId">The filter for exchange ID. (optional)</param>
        /// <param name="filterAssetId">The filter for asset ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsGetApiResponse"/>?&gt;</returns>
        Task<IV1SymbolsGetApiResponse?> V1SymbolsGetOrDefaultAsync(Option<string> filterSymbolId = default, Option<string> filterExchangeId = default, Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List symbol mapping for the exchange
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The ID of the exchange (from the Metadata -&gt; Exchanges)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsMapExchangeIdGetApiResponse"/>&gt;</returns>
        Task<IV1SymbolsMapExchangeIdGetApiResponse> V1SymbolsMapExchangeIdGetAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List symbol mapping for the exchange
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="exchangeId">The ID of the exchange (from the Metadata -&gt; Exchanges)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsMapExchangeIdGetApiResponse"/>?&gt;</returns>
        Task<IV1SymbolsMapExchangeIdGetApiResponse?> V1SymbolsMapExchangeIdGetOrDefaultAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IV1AssetsAssetIdGetApiResponse"/>
    /// </summary>
    public interface IV1AssetsAssetIdGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Asset>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1AssetsGetApiResponse"/>
    /// </summary>
    public interface IV1AssetsGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Asset>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1AssetsIconsSizeGetApiResponse"/>
    /// </summary>
    public interface IV1AssetsIconsSizeGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Icon>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExchangesExchangeIdGetApiResponse"/>
    /// </summary>
    public interface IV1ExchangesExchangeIdGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Exchange>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExchangesGetApiResponse"/>
    /// </summary>
    public interface IV1ExchangesGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Exchange>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExchangesIconsSizeGetApiResponse"/>
    /// </summary>
    public interface IV1ExchangesIconsSizeGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Icon>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1SymbolsExchangeIdGetApiResponse"/>
    /// </summary>
    public interface IV1SymbolsExchangeIdGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Symbol>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1SymbolsGetApiResponse"/>
    /// </summary>
    public interface IV1SymbolsGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Symbol>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1SymbolsMapExchangeIdGetApiResponse"/>
    /// </summary>
    public interface IV1SymbolsMapExchangeIdGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1SymbolMapping>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class MetadataApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1AssetsAssetIdGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1AssetsAssetIdGet;

        internal void ExecuteOnV1AssetsAssetIdGet(MetadataApi.V1AssetsAssetIdGetApiResponse apiResponse)
        {
            OnV1AssetsAssetIdGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1AssetsAssetIdGet(Exception exception)
        {
            OnErrorV1AssetsAssetIdGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1AssetsGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1AssetsGet;

        internal void ExecuteOnV1AssetsGet(MetadataApi.V1AssetsGetApiResponse apiResponse)
        {
            OnV1AssetsGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1AssetsGet(Exception exception)
        {
            OnErrorV1AssetsGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1AssetsIconsSizeGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1AssetsIconsSizeGet;

        internal void ExecuteOnV1AssetsIconsSizeGet(MetadataApi.V1AssetsIconsSizeGetApiResponse apiResponse)
        {
            OnV1AssetsIconsSizeGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1AssetsIconsSizeGet(Exception exception)
        {
            OnErrorV1AssetsIconsSizeGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExchangesExchangeIdGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExchangesExchangeIdGet;

        internal void ExecuteOnV1ExchangesExchangeIdGet(MetadataApi.V1ExchangesExchangeIdGetApiResponse apiResponse)
        {
            OnV1ExchangesExchangeIdGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExchangesExchangeIdGet(Exception exception)
        {
            OnErrorV1ExchangesExchangeIdGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExchangesGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExchangesGet;

        internal void ExecuteOnV1ExchangesGet(MetadataApi.V1ExchangesGetApiResponse apiResponse)
        {
            OnV1ExchangesGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExchangesGet(Exception exception)
        {
            OnErrorV1ExchangesGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExchangesIconsSizeGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExchangesIconsSizeGet;

        internal void ExecuteOnV1ExchangesIconsSizeGet(MetadataApi.V1ExchangesIconsSizeGetApiResponse apiResponse)
        {
            OnV1ExchangesIconsSizeGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExchangesIconsSizeGet(Exception exception)
        {
            OnErrorV1ExchangesIconsSizeGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1SymbolsExchangeIdGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1SymbolsExchangeIdGet;

        internal void ExecuteOnV1SymbolsExchangeIdGet(MetadataApi.V1SymbolsExchangeIdGetApiResponse apiResponse)
        {
            OnV1SymbolsExchangeIdGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1SymbolsExchangeIdGet(Exception exception)
        {
            OnErrorV1SymbolsExchangeIdGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1SymbolsGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1SymbolsGet;

        internal void ExecuteOnV1SymbolsGet(MetadataApi.V1SymbolsGetApiResponse apiResponse)
        {
            OnV1SymbolsGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1SymbolsGet(Exception exception)
        {
            OnErrorV1SymbolsGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1SymbolsMapExchangeIdGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1SymbolsMapExchangeIdGet;

        internal void ExecuteOnV1SymbolsMapExchangeIdGet(MetadataApi.V1SymbolsMapExchangeIdGetApiResponse apiResponse)
        {
            OnV1SymbolsMapExchangeIdGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1SymbolsMapExchangeIdGet(Exception exception)
        {
            OnErrorV1SymbolsMapExchangeIdGet?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class MetadataApi : IMetadataApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<MetadataApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public MetadataApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MetadataApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MetadataApi(ILogger<MetadataApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, MetadataApiEvents metadataApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<MetadataApi>();
            HttpClient = httpClient;
            Events = metadataApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatV1AssetsAssetIdGet(ref string assetId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assetId"></param>
        /// <returns></returns>
        private void ValidateV1AssetsAssetIdGet(string assetId)
        {
            if (assetId == null)
                throw new ArgumentNullException(nameof(assetId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetId"></param>
        private void AfterV1AssetsAssetIdGetDefaultImplementation(IV1AssetsAssetIdGetApiResponse apiResponseLocalVar, string assetId)
        {
            bool suppressDefaultLog = false;
            AfterV1AssetsAssetIdGet(ref suppressDefaultLog, apiResponseLocalVar, assetId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetId"></param>
        partial void AfterV1AssetsAssetIdGet(ref bool suppressDefaultLog, IV1AssetsAssetIdGetApiResponse apiResponseLocalVar, string assetId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetId"></param>
        private void OnErrorV1AssetsAssetIdGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1AssetsAssetIdGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assetId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetId"></param>
        partial void OnErrorV1AssetsAssetIdGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetId);

        /// <summary>
        /// List all assets by asset ID 
        /// </summary>
        /// <param name="assetId">The asset ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsAssetIdGetApiResponse"/>&gt;</returns>
        public async Task<IV1AssetsAssetIdGetApiResponse?> V1AssetsAssetIdGetOrDefaultAsync(string assetId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1AssetsAssetIdGetAsync(assetId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all assets by asset ID 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The asset ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsAssetIdGetApiResponse"/>&gt;</returns>
        public async Task<IV1AssetsAssetIdGetApiResponse> V1AssetsAssetIdGetAsync(string assetId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1AssetsAssetIdGet(assetId);

                FormatV1AssetsAssetIdGet(ref assetId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/assets/{asset_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/assets/{asset_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id%7D", Uri.EscapeDataString(assetId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1AssetsAssetIdGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1AssetsAssetIdGetApiResponse>();

                        V1AssetsAssetIdGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/assets/{asset_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1AssetsAssetIdGetDefaultImplementation(apiResponseLocalVar, assetId);

                        Events.ExecuteOnV1AssetsAssetIdGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1AssetsAssetIdGetDefaultImplementation(e, "/v1/assets/{asset_id}", uriBuilderLocalVar.Path, assetId);
                Events.ExecuteOnErrorV1AssetsAssetIdGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1AssetsAssetIdGetApiResponse"/>
        /// </summary>
        public partial class V1AssetsAssetIdGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1AssetsAssetIdGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1AssetsAssetIdGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1AssetsAssetIdGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1AssetsAssetIdGetApiResponse(ILogger<V1AssetsAssetIdGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Asset>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Asset>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Asset>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1AssetsGet(ref Option<string> filterAssetId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="filterAssetId"></param>
        /// <returns></returns>
        private void ValidateV1AssetsGet(Option<string> filterAssetId)
        {
            if (filterAssetId.IsSet && filterAssetId.Value == null)
                throw new ArgumentNullException(nameof(filterAssetId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="filterAssetId"></param>
        private void AfterV1AssetsGetDefaultImplementation(IV1AssetsGetApiResponse apiResponseLocalVar, Option<string> filterAssetId)
        {
            bool suppressDefaultLog = false;
            AfterV1AssetsGet(ref suppressDefaultLog, apiResponseLocalVar, filterAssetId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="filterAssetId"></param>
        partial void AfterV1AssetsGet(ref bool suppressDefaultLog, IV1AssetsGetApiResponse apiResponseLocalVar, Option<string> filterAssetId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="filterAssetId"></param>
        private void OnErrorV1AssetsGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> filterAssetId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1AssetsGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, filterAssetId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="filterAssetId"></param>
        partial void OnErrorV1AssetsGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> filterAssetId);

        /// <summary>
        /// List all assets Retrieves all assets.                :::info  Our asset identifiers are aligned with the ISO 4217 currency codes standard only for fiat money (government or law regulated currency).  :::                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific asset. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </summary>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response. (optional, eg. &#x60;BTC;ETH&#x60;). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsGetApiResponse"/>&gt;</returns>
        public async Task<IV1AssetsGetApiResponse?> V1AssetsGetOrDefaultAsync(Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1AssetsGetAsync(filterAssetId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all assets Retrieves all assets.                :::info  Our asset identifiers are aligned with the ISO 4217 currency codes standard only for fiat money (government or law regulated currency).  :::                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific asset. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response. (optional, eg. &#x60;BTC;ETH&#x60;). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsGetApiResponse"/>&gt;</returns>
        public async Task<IV1AssetsGetApiResponse> V1AssetsGetAsync(Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1AssetsGet(filterAssetId);

                FormatV1AssetsGet(ref filterAssetId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/assets"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/assets");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (filterAssetId.IsSet)
                        parseQueryStringLocalVar["filter_asset_id"] = ClientUtils.ParameterToString(filterAssetId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1AssetsGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1AssetsGetApiResponse>();

                        V1AssetsGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/assets", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1AssetsGetDefaultImplementation(apiResponseLocalVar, filterAssetId);

                        Events.ExecuteOnV1AssetsGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1AssetsGetDefaultImplementation(e, "/v1/assets", uriBuilderLocalVar.Path, filterAssetId);
                Events.ExecuteOnErrorV1AssetsGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1AssetsGetApiResponse"/>
        /// </summary>
        public partial class V1AssetsGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1AssetsGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1AssetsGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1AssetsGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1AssetsGetApiResponse(ILogger<V1AssetsGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Asset>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Asset>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Asset>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1AssetsIconsSizeGet(ref int size);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="size"></param>
        private void AfterV1AssetsIconsSizeGetDefaultImplementation(IV1AssetsIconsSizeGetApiResponse apiResponseLocalVar, int size)
        {
            bool suppressDefaultLog = false;
            AfterV1AssetsIconsSizeGet(ref suppressDefaultLog, apiResponseLocalVar, size);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="size"></param>
        partial void AfterV1AssetsIconsSizeGet(ref bool suppressDefaultLog, IV1AssetsIconsSizeGetApiResponse apiResponseLocalVar, int size);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        private void OnErrorV1AssetsIconsSizeGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int size)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1AssetsIconsSizeGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, size);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        partial void OnErrorV1AssetsIconsSizeGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int size);

        /// <summary>
        /// List all asset icons Gets the list of icons (of the given size) for all the assets.
        /// </summary>
        /// <param name="size">The size of the icons.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsIconsSizeGetApiResponse"/>&gt;</returns>
        public async Task<IV1AssetsIconsSizeGetApiResponse?> V1AssetsIconsSizeGetOrDefaultAsync(int size, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1AssetsIconsSizeGetAsync(size, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all asset icons Gets the list of icons (of the given size) for all the assets.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The size of the icons.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1AssetsIconsSizeGetApiResponse"/>&gt;</returns>
        public async Task<IV1AssetsIconsSizeGetApiResponse> V1AssetsIconsSizeGetAsync(int size, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatV1AssetsIconsSizeGet(ref size);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/assets/icons/{size}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/assets/icons/{size}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsize%7D", Uri.EscapeDataString(size.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1AssetsIconsSizeGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1AssetsIconsSizeGetApiResponse>();

                        V1AssetsIconsSizeGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/assets/icons/{size}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1AssetsIconsSizeGetDefaultImplementation(apiResponseLocalVar, size);

                        Events.ExecuteOnV1AssetsIconsSizeGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1AssetsIconsSizeGetDefaultImplementation(e, "/v1/assets/icons/{size}", uriBuilderLocalVar.Path, size);
                Events.ExecuteOnErrorV1AssetsIconsSizeGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1AssetsIconsSizeGetApiResponse"/>
        /// </summary>
        public partial class V1AssetsIconsSizeGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1AssetsIconsSizeGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1AssetsIconsSizeGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1AssetsIconsSizeGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1AssetsIconsSizeGetApiResponse(ILogger<V1AssetsIconsSizeGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Icon>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Icon>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Icon>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExchangesExchangeIdGet(ref string exchangeId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="exchangeId"></param>
        /// <returns></returns>
        private void ValidateV1ExchangesExchangeIdGet(string exchangeId)
        {
            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        private void AfterV1ExchangesExchangeIdGetDefaultImplementation(IV1ExchangesExchangeIdGetApiResponse apiResponseLocalVar, string exchangeId)
        {
            bool suppressDefaultLog = false;
            AfterV1ExchangesExchangeIdGet(ref suppressDefaultLog, apiResponseLocalVar, exchangeId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        partial void AfterV1ExchangesExchangeIdGet(ref bool suppressDefaultLog, IV1ExchangesExchangeIdGetApiResponse apiResponseLocalVar, string exchangeId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        private void OnErrorV1ExchangesExchangeIdGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExchangesExchangeIdGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, exchangeId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        partial void OnErrorV1ExchangesExchangeIdGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId);

        /// <summary>
        /// List all exchanges by exchange_id 
        /// </summary>
        /// <param name="exchangeId">The ID of the exchange.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesExchangeIdGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangesExchangeIdGetApiResponse?> V1ExchangesExchangeIdGetOrDefaultAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExchangesExchangeIdGetAsync(exchangeId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all exchanges by exchange_id 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The ID of the exchange.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesExchangeIdGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangesExchangeIdGetApiResponse> V1ExchangesExchangeIdGetAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExchangesExchangeIdGet(exchangeId);

                FormatV1ExchangesExchangeIdGet(ref exchangeId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchanges/{exchange_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchanges/{exchange_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bexchange_id%7D", Uri.EscapeDataString(exchangeId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExchangesExchangeIdGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExchangesExchangeIdGetApiResponse>();

                        V1ExchangesExchangeIdGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchanges/{exchange_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExchangesExchangeIdGetDefaultImplementation(apiResponseLocalVar, exchangeId);

                        Events.ExecuteOnV1ExchangesExchangeIdGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExchangesExchangeIdGetDefaultImplementation(e, "/v1/exchanges/{exchange_id}", uriBuilderLocalVar.Path, exchangeId);
                Events.ExecuteOnErrorV1ExchangesExchangeIdGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExchangesExchangeIdGetApiResponse"/>
        /// </summary>
        public partial class V1ExchangesExchangeIdGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExchangesExchangeIdGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExchangesExchangeIdGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExchangesExchangeIdGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangesExchangeIdGetApiResponse(ILogger<V1ExchangesExchangeIdGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Exchange>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Exchange>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Exchange>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExchangesGet(ref Option<string> filterExchangeId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="filterExchangeId"></param>
        /// <returns></returns>
        private void ValidateV1ExchangesGet(Option<string> filterExchangeId)
        {
            if (filterExchangeId.IsSet && filterExchangeId.Value == null)
                throw new ArgumentNullException(nameof(filterExchangeId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="filterExchangeId"></param>
        private void AfterV1ExchangesGetDefaultImplementation(IV1ExchangesGetApiResponse apiResponseLocalVar, Option<string> filterExchangeId)
        {
            bool suppressDefaultLog = false;
            AfterV1ExchangesGet(ref suppressDefaultLog, apiResponseLocalVar, filterExchangeId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="filterExchangeId"></param>
        partial void AfterV1ExchangesGet(ref bool suppressDefaultLog, IV1ExchangesGetApiResponse apiResponseLocalVar, Option<string> filterExchangeId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="filterExchangeId"></param>
        private void OnErrorV1ExchangesGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> filterExchangeId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExchangesGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, filterExchangeId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="filterExchangeId"></param>
        partial void OnErrorV1ExchangesGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> filterExchangeId);

        /// <summary>
        /// List all exchanges Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </summary>
        /// <param name="filterExchangeId">Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangesGetApiResponse?> V1ExchangesGetOrDefaultAsync(Option<string> filterExchangeId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExchangesGetAsync(filterExchangeId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all exchanges Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterExchangeId">Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangesGetApiResponse> V1ExchangesGetAsync(Option<string> filterExchangeId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExchangesGet(filterExchangeId);

                FormatV1ExchangesGet(ref filterExchangeId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchanges"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchanges");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (filterExchangeId.IsSet)
                        parseQueryStringLocalVar["filter_exchange_id"] = ClientUtils.ParameterToString(filterExchangeId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExchangesGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExchangesGetApiResponse>();

                        V1ExchangesGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchanges", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExchangesGetDefaultImplementation(apiResponseLocalVar, filterExchangeId);

                        Events.ExecuteOnV1ExchangesGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExchangesGetDefaultImplementation(e, "/v1/exchanges", uriBuilderLocalVar.Path, filterExchangeId);
                Events.ExecuteOnErrorV1ExchangesGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExchangesGetApiResponse"/>
        /// </summary>
        public partial class V1ExchangesGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExchangesGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExchangesGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExchangesGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangesGetApiResponse(ILogger<V1ExchangesGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Exchange>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Exchange>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Exchange>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExchangesIconsSizeGet(ref int size);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="size"></param>
        private void AfterV1ExchangesIconsSizeGetDefaultImplementation(IV1ExchangesIconsSizeGetApiResponse apiResponseLocalVar, int size)
        {
            bool suppressDefaultLog = false;
            AfterV1ExchangesIconsSizeGet(ref suppressDefaultLog, apiResponseLocalVar, size);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="size"></param>
        partial void AfterV1ExchangesIconsSizeGet(ref bool suppressDefaultLog, IV1ExchangesIconsSizeGetApiResponse apiResponseLocalVar, int size);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        private void OnErrorV1ExchangesIconsSizeGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int size)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExchangesIconsSizeGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, size);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        partial void OnErrorV1ExchangesIconsSizeGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int size);

        /// <summary>
        /// List of icons for the exchanges 
        /// </summary>
        /// <param name="size">The size of the icons.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesIconsSizeGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangesIconsSizeGetApiResponse?> V1ExchangesIconsSizeGetOrDefaultAsync(int size, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExchangesIconsSizeGetAsync(size, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List of icons for the exchanges 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The size of the icons.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangesIconsSizeGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangesIconsSizeGetApiResponse> V1ExchangesIconsSizeGetAsync(int size, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatV1ExchangesIconsSizeGet(ref size);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchanges/icons/{size}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchanges/icons/{size}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsize%7D", Uri.EscapeDataString(size.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExchangesIconsSizeGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExchangesIconsSizeGetApiResponse>();

                        V1ExchangesIconsSizeGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchanges/icons/{size}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExchangesIconsSizeGetDefaultImplementation(apiResponseLocalVar, size);

                        Events.ExecuteOnV1ExchangesIconsSizeGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExchangesIconsSizeGetDefaultImplementation(e, "/v1/exchanges/icons/{size}", uriBuilderLocalVar.Path, size);
                Events.ExecuteOnErrorV1ExchangesIconsSizeGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExchangesIconsSizeGetApiResponse"/>
        /// </summary>
        public partial class V1ExchangesIconsSizeGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1ExchangesIconsSizeGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExchangesIconsSizeGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExchangesIconsSizeGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangesIconsSizeGetApiResponse(ILogger<V1ExchangesIconsSizeGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Icon>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Icon>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Icon>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1SymbolsExchangeIdGet(ref string exchangeId, ref Option<string> filterSymbolId, ref Option<string> filterAssetId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="exchangeId"></param>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterAssetId"></param>
        /// <returns></returns>
        private void ValidateV1SymbolsExchangeIdGet(string exchangeId, Option<string> filterSymbolId, Option<string> filterAssetId)
        {
            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));

            if (filterSymbolId.IsSet && filterSymbolId.Value == null)
                throw new ArgumentNullException(nameof(filterSymbolId));

            if (filterAssetId.IsSet && filterAssetId.Value == null)
                throw new ArgumentNullException(nameof(filterAssetId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterAssetId"></param>
        private void AfterV1SymbolsExchangeIdGetDefaultImplementation(IV1SymbolsExchangeIdGetApiResponse apiResponseLocalVar, string exchangeId, Option<string> filterSymbolId, Option<string> filterAssetId)
        {
            bool suppressDefaultLog = false;
            AfterV1SymbolsExchangeIdGet(ref suppressDefaultLog, apiResponseLocalVar, exchangeId, filterSymbolId, filterAssetId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterAssetId"></param>
        partial void AfterV1SymbolsExchangeIdGet(ref bool suppressDefaultLog, IV1SymbolsExchangeIdGetApiResponse apiResponseLocalVar, string exchangeId, Option<string> filterSymbolId, Option<string> filterAssetId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterAssetId"></param>
        private void OnErrorV1SymbolsExchangeIdGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId, Option<string> filterSymbolId, Option<string> filterAssetId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1SymbolsExchangeIdGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, exchangeId, filterSymbolId, filterAssetId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterAssetId"></param>
        partial void OnErrorV1SymbolsExchangeIdGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId, Option<string> filterSymbolId, Option<string> filterAssetId);

        /// <summary>
        /// List of symbols for the exchange 
        /// </summary>
        /// <param name="exchangeId">The ID of the exchange (from the Metadata -&gt; Exchanges)</param>
        /// <param name="filterSymbolId">The filter for symbol ID. (optional)</param>
        /// <param name="filterAssetId">The filter for asset ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsExchangeIdGetApiResponse"/>&gt;</returns>
        public async Task<IV1SymbolsExchangeIdGetApiResponse?> V1SymbolsExchangeIdGetOrDefaultAsync(string exchangeId, Option<string> filterSymbolId = default, Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1SymbolsExchangeIdGetAsync(exchangeId, filterSymbolId, filterAssetId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List of symbols for the exchange 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The ID of the exchange (from the Metadata -&gt; Exchanges)</param>
        /// <param name="filterSymbolId">The filter for symbol ID. (optional)</param>
        /// <param name="filterAssetId">The filter for asset ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsExchangeIdGetApiResponse"/>&gt;</returns>
        public async Task<IV1SymbolsExchangeIdGetApiResponse> V1SymbolsExchangeIdGetAsync(string exchangeId, Option<string> filterSymbolId = default, Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1SymbolsExchangeIdGet(exchangeId, filterSymbolId, filterAssetId);

                FormatV1SymbolsExchangeIdGet(ref exchangeId, ref filterSymbolId, ref filterAssetId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/symbols/{exchange_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/symbols/{exchange_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bexchange_id%7D", Uri.EscapeDataString(exchangeId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (filterSymbolId.IsSet)
                        parseQueryStringLocalVar["filter_symbol_id"] = ClientUtils.ParameterToString(filterSymbolId.Value);

                    if (filterAssetId.IsSet)
                        parseQueryStringLocalVar["filter_asset_id"] = ClientUtils.ParameterToString(filterAssetId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1SymbolsExchangeIdGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1SymbolsExchangeIdGetApiResponse>();

                        V1SymbolsExchangeIdGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/symbols/{exchange_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1SymbolsExchangeIdGetDefaultImplementation(apiResponseLocalVar, exchangeId, filterSymbolId, filterAssetId);

                        Events.ExecuteOnV1SymbolsExchangeIdGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1SymbolsExchangeIdGetDefaultImplementation(e, "/v1/symbols/{exchange_id}", uriBuilderLocalVar.Path, exchangeId, filterSymbolId, filterAssetId);
                Events.ExecuteOnErrorV1SymbolsExchangeIdGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1SymbolsExchangeIdGetApiResponse"/>
        /// </summary>
        public partial class V1SymbolsExchangeIdGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1SymbolsExchangeIdGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1SymbolsExchangeIdGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1SymbolsExchangeIdGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1SymbolsExchangeIdGetApiResponse(ILogger<V1SymbolsExchangeIdGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Symbol>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Symbol>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Symbol>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1SymbolsGet(ref Option<string> filterSymbolId, ref Option<string> filterExchangeId, ref Option<string> filterAssetId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterExchangeId"></param>
        /// <param name="filterAssetId"></param>
        /// <returns></returns>
        private void ValidateV1SymbolsGet(Option<string> filterSymbolId, Option<string> filterExchangeId, Option<string> filterAssetId)
        {
            if (filterSymbolId.IsSet && filterSymbolId.Value == null)
                throw new ArgumentNullException(nameof(filterSymbolId));

            if (filterExchangeId.IsSet && filterExchangeId.Value == null)
                throw new ArgumentNullException(nameof(filterExchangeId));

            if (filterAssetId.IsSet && filterAssetId.Value == null)
                throw new ArgumentNullException(nameof(filterAssetId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterExchangeId"></param>
        /// <param name="filterAssetId"></param>
        private void AfterV1SymbolsGetDefaultImplementation(IV1SymbolsGetApiResponse apiResponseLocalVar, Option<string> filterSymbolId, Option<string> filterExchangeId, Option<string> filterAssetId)
        {
            bool suppressDefaultLog = false;
            AfterV1SymbolsGet(ref suppressDefaultLog, apiResponseLocalVar, filterSymbolId, filterExchangeId, filterAssetId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterExchangeId"></param>
        /// <param name="filterAssetId"></param>
        partial void AfterV1SymbolsGet(ref bool suppressDefaultLog, IV1SymbolsGetApiResponse apiResponseLocalVar, Option<string> filterSymbolId, Option<string> filterExchangeId, Option<string> filterAssetId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterExchangeId"></param>
        /// <param name="filterAssetId"></param>
        private void OnErrorV1SymbolsGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> filterSymbolId, Option<string> filterExchangeId, Option<string> filterAssetId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1SymbolsGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, filterSymbolId, filterExchangeId, filterAssetId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="filterSymbolId"></param>
        /// <param name="filterExchangeId"></param>
        /// <param name="filterAssetId"></param>
        partial void OnErrorV1SymbolsGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> filterSymbolId, Option<string> filterExchangeId, Option<string> filterAssetId);

        /// <summary>
        /// List all symbols Retrieves all symbols with optional filtering.                :::info  \&quot;price_precision\&quot; and \&quot;size_precision\&quot; are data precisions and are not always the same precisions used for trading eg. for the \&quot;BINANCE\&quot; exchanges.  :::                :::info  You should not assume that the market data will be always within the resolution provided by the \&quot;price_precision\&quot; and \&quot;size_precision\&quot;. The fact that the precision values can be derived from a posterior implies the fact that this data could be delayed, also it can be changed by the data source without notice and we will immediately deliver data with the new precision while could not update the precision values in this endpoint immediately.  :::                ### Symbol identifier                Our symbol identifier is created using a pattern that depends on symbol type.                Type | &#x60;symbol_id&#x60; pattern  - -- -- -- -- | - -- -- -- --  SPOT | &#x60;{exchange_id}_SPOT_{asset_id_base}_{asset_id_quote}&#x60;  FUTURES | &#x60;{exchange_id}_FTS_{asset_id_base}_{asset_id_quote}_{YYMMDD of future_delivery_time}&#x60;  OPTION | &#x60;{exchange_id}_OPT_{asset_id_base}_{asset_id_quote}_{YYMMDD of option_expiration_time}_{option_strike_price}_{option_type_is_call as C/P}&#x60;  PERPETUAL | &#x60;{exchange_id}_PERP_{asset_id_base}_{asset_id_quote}&#x60;  INDEX | &#x60;{exchange_id}_IDX_{index_id}&#x60;  CREDIT | &#x60;{exchange_id}_CRE_{asset_id_base}&#x60;  CONTACT  | &#x60;{exchange_id}_COT_{contract_id}&#x60;                :::info  In the unlikely event when the \&quot;symbol_id\&quot; for more than one market is the same. We will append the additional term (prefixed with the \&quot;_\&quot;) at the end of the duplicated identifiers to differentiate them.  :::info                ### Symbol types list (enumeration of &#x60;symbol_type&#x60; output variable)                Type | Name | Description  - -- -- -- - | - | - -- -- -- -- --  SPOT | FX Spot | Agreement to exchange one asset for another one *(e.g. Buy BTC for USD)*  FUTURES | Futures contract | FX Spot derivative contract where traders agree to trade fx spot at predetermined future time  OPTION | Option contract | FX Spot derivative contract where traders agree to trade right to require buy or sell of fx spot at agreed price on exercise date  PERPETUAL | Perpetual contract | FX Spot derivative contract where traders agree to trade fx spot continously without predetermined future delivery time  INDEX | Index | Statistical composite that measures changes in the economy or markets.  CREDIT | Credit/Funding | Margin funding contract. Order book displays lending offers and borrow bids. Price represents the daily rate.  CONTRACT | Contract | Represents other types of financial instruments *(e.g. spreads, interest rate swap)*                ### Additional output variables for &#x60;symbol_type &#x3D; INDEX&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  index_id | Index identifier  index_display_name | Human readable name of the index *(optional)*  index_display_description | Description of the index *(optional)*                ### Additional output variables for &#x60;symbol_type &#x3D; FUTURES&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  future_delivery_time | Predetermined time of futures contract delivery date in ISO 8601  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; PERPETUAL&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; OPTION&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  option_type_is_call | Boolean value representing option type. &#x60;true&#x60; for Call options, &#x60;false&#x60; for Put options  option_strike_price | Price at which option contract can be exercised  option_contract_unit | Base asset amount of underlying spot which single option represents  option_exercise_style | Option exercise style. Can be &#x60;EUROPEAN&#x60; or &#x60;AMERICAN&#x60;  option_expiration_time | Option contract expiration time in ISO 8601                ### Additional output variables for &#x60;symbol_type &#x3D; CONTRACT&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  contract_delivery_time | Predetermined time of contract delivery date in ISO 8601  contract_unit | Contact size *(eg. 10 BTC if &#x60;contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  contract_unit_asset | Identifier of the asset used to denominate the contract unit  contract_id | Identifier of contract by the exchange
        /// </summary>
        /// <param name="filterSymbolId">Comma or semicolon delimited parts of symbol identifier used to filter response. (optional, eg. &#x60;BITSTAMP&#x60;_ or &#x60;BINANCE_SPOT_&#x60;) (optional)</param>
        /// <param name="filterExchangeId">The filter for exchange ID. (optional)</param>
        /// <param name="filterAssetId">The filter for asset ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsGetApiResponse"/>&gt;</returns>
        public async Task<IV1SymbolsGetApiResponse?> V1SymbolsGetOrDefaultAsync(Option<string> filterSymbolId = default, Option<string> filterExchangeId = default, Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1SymbolsGetAsync(filterSymbolId, filterExchangeId, filterAssetId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all symbols Retrieves all symbols with optional filtering.                :::info  \&quot;price_precision\&quot; and \&quot;size_precision\&quot; are data precisions and are not always the same precisions used for trading eg. for the \&quot;BINANCE\&quot; exchanges.  :::                :::info  You should not assume that the market data will be always within the resolution provided by the \&quot;price_precision\&quot; and \&quot;size_precision\&quot;. The fact that the precision values can be derived from a posterior implies the fact that this data could be delayed, also it can be changed by the data source without notice and we will immediately deliver data with the new precision while could not update the precision values in this endpoint immediately.  :::                ### Symbol identifier                Our symbol identifier is created using a pattern that depends on symbol type.                Type | &#x60;symbol_id&#x60; pattern  - -- -- -- -- | - -- -- -- --  SPOT | &#x60;{exchange_id}_SPOT_{asset_id_base}_{asset_id_quote}&#x60;  FUTURES | &#x60;{exchange_id}_FTS_{asset_id_base}_{asset_id_quote}_{YYMMDD of future_delivery_time}&#x60;  OPTION | &#x60;{exchange_id}_OPT_{asset_id_base}_{asset_id_quote}_{YYMMDD of option_expiration_time}_{option_strike_price}_{option_type_is_call as C/P}&#x60;  PERPETUAL | &#x60;{exchange_id}_PERP_{asset_id_base}_{asset_id_quote}&#x60;  INDEX | &#x60;{exchange_id}_IDX_{index_id}&#x60;  CREDIT | &#x60;{exchange_id}_CRE_{asset_id_base}&#x60;  CONTACT  | &#x60;{exchange_id}_COT_{contract_id}&#x60;                :::info  In the unlikely event when the \&quot;symbol_id\&quot; for more than one market is the same. We will append the additional term (prefixed with the \&quot;_\&quot;) at the end of the duplicated identifiers to differentiate them.  :::info                ### Symbol types list (enumeration of &#x60;symbol_type&#x60; output variable)                Type | Name | Description  - -- -- -- - | - | - -- -- -- -- --  SPOT | FX Spot | Agreement to exchange one asset for another one *(e.g. Buy BTC for USD)*  FUTURES | Futures contract | FX Spot derivative contract where traders agree to trade fx spot at predetermined future time  OPTION | Option contract | FX Spot derivative contract where traders agree to trade right to require buy or sell of fx spot at agreed price on exercise date  PERPETUAL | Perpetual contract | FX Spot derivative contract where traders agree to trade fx spot continously without predetermined future delivery time  INDEX | Index | Statistical composite that measures changes in the economy or markets.  CREDIT | Credit/Funding | Margin funding contract. Order book displays lending offers and borrow bids. Price represents the daily rate.  CONTRACT | Contract | Represents other types of financial instruments *(e.g. spreads, interest rate swap)*                ### Additional output variables for &#x60;symbol_type &#x3D; INDEX&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  index_id | Index identifier  index_display_name | Human readable name of the index *(optional)*  index_display_description | Description of the index *(optional)*                ### Additional output variables for &#x60;symbol_type &#x3D; FUTURES&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  future_delivery_time | Predetermined time of futures contract delivery date in ISO 8601  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; PERPETUAL&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; OPTION&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  option_type_is_call | Boolean value representing option type. &#x60;true&#x60; for Call options, &#x60;false&#x60; for Put options  option_strike_price | Price at which option contract can be exercised  option_contract_unit | Base asset amount of underlying spot which single option represents  option_exercise_style | Option exercise style. Can be &#x60;EUROPEAN&#x60; or &#x60;AMERICAN&#x60;  option_expiration_time | Option contract expiration time in ISO 8601                ### Additional output variables for &#x60;symbol_type &#x3D; CONTRACT&#x60;                Variable | Description  - -- -- -- -- | - -- -- -- -- --  contract_delivery_time | Predetermined time of contract delivery date in ISO 8601  contract_unit | Contact size *(eg. 10 BTC if &#x60;contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  contract_unit_asset | Identifier of the asset used to denominate the contract unit  contract_id | Identifier of contract by the exchange
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSymbolId">Comma or semicolon delimited parts of symbol identifier used to filter response. (optional, eg. &#x60;BITSTAMP&#x60;_ or &#x60;BINANCE_SPOT_&#x60;) (optional)</param>
        /// <param name="filterExchangeId">The filter for exchange ID. (optional)</param>
        /// <param name="filterAssetId">The filter for asset ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsGetApiResponse"/>&gt;</returns>
        public async Task<IV1SymbolsGetApiResponse> V1SymbolsGetAsync(Option<string> filterSymbolId = default, Option<string> filterExchangeId = default, Option<string> filterAssetId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1SymbolsGet(filterSymbolId, filterExchangeId, filterAssetId);

                FormatV1SymbolsGet(ref filterSymbolId, ref filterExchangeId, ref filterAssetId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/symbols"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/symbols");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (filterSymbolId.IsSet)
                        parseQueryStringLocalVar["filter_symbol_id"] = ClientUtils.ParameterToString(filterSymbolId.Value);

                    if (filterExchangeId.IsSet)
                        parseQueryStringLocalVar["filter_exchange_id"] = ClientUtils.ParameterToString(filterExchangeId.Value);

                    if (filterAssetId.IsSet)
                        parseQueryStringLocalVar["filter_asset_id"] = ClientUtils.ParameterToString(filterAssetId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1SymbolsGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1SymbolsGetApiResponse>();

                        V1SymbolsGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/symbols", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1SymbolsGetDefaultImplementation(apiResponseLocalVar, filterSymbolId, filterExchangeId, filterAssetId);

                        Events.ExecuteOnV1SymbolsGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1SymbolsGetDefaultImplementation(e, "/v1/symbols", uriBuilderLocalVar.Path, filterSymbolId, filterExchangeId, filterAssetId);
                Events.ExecuteOnErrorV1SymbolsGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1SymbolsGetApiResponse"/>
        /// </summary>
        public partial class V1SymbolsGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1SymbolsGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1SymbolsGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1SymbolsGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1SymbolsGetApiResponse(ILogger<V1SymbolsGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Symbol>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Symbol>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Symbol>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1SymbolsMapExchangeIdGet(ref string exchangeId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="exchangeId"></param>
        /// <returns></returns>
        private void ValidateV1SymbolsMapExchangeIdGet(string exchangeId)
        {
            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        private void AfterV1SymbolsMapExchangeIdGetDefaultImplementation(IV1SymbolsMapExchangeIdGetApiResponse apiResponseLocalVar, string exchangeId)
        {
            bool suppressDefaultLog = false;
            AfterV1SymbolsMapExchangeIdGet(ref suppressDefaultLog, apiResponseLocalVar, exchangeId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        partial void AfterV1SymbolsMapExchangeIdGet(ref bool suppressDefaultLog, IV1SymbolsMapExchangeIdGetApiResponse apiResponseLocalVar, string exchangeId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        private void OnErrorV1SymbolsMapExchangeIdGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1SymbolsMapExchangeIdGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, exchangeId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        partial void OnErrorV1SymbolsMapExchangeIdGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId);

        /// <summary>
        /// List symbol mapping for the exchange 
        /// </summary>
        /// <param name="exchangeId">The ID of the exchange (from the Metadata -&gt; Exchanges)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsMapExchangeIdGetApiResponse"/>&gt;</returns>
        public async Task<IV1SymbolsMapExchangeIdGetApiResponse?> V1SymbolsMapExchangeIdGetOrDefaultAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1SymbolsMapExchangeIdGetAsync(exchangeId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List symbol mapping for the exchange 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The ID of the exchange (from the Metadata -&gt; Exchanges)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1SymbolsMapExchangeIdGetApiResponse"/>&gt;</returns>
        public async Task<IV1SymbolsMapExchangeIdGetApiResponse> V1SymbolsMapExchangeIdGetAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1SymbolsMapExchangeIdGet(exchangeId);

                FormatV1SymbolsMapExchangeIdGet(ref exchangeId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/symbols/map/{exchange_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/symbols/map/{exchange_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bexchange_id%7D", Uri.EscapeDataString(exchangeId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1SymbolsMapExchangeIdGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1SymbolsMapExchangeIdGetApiResponse>();

                        V1SymbolsMapExchangeIdGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/symbols/map/{exchange_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1SymbolsMapExchangeIdGetDefaultImplementation(apiResponseLocalVar, exchangeId);

                        Events.ExecuteOnV1SymbolsMapExchangeIdGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1SymbolsMapExchangeIdGetDefaultImplementation(e, "/v1/symbols/map/{exchange_id}", uriBuilderLocalVar.Path, exchangeId);
                Events.ExecuteOnErrorV1SymbolsMapExchangeIdGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1SymbolsMapExchangeIdGetApiResponse"/>
        /// </summary>
        public partial class V1SymbolsMapExchangeIdGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1SymbolsMapExchangeIdGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1SymbolsMapExchangeIdGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1SymbolsMapExchangeIdGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1SymbolsMapExchangeIdGetApiResponse(ILogger<V1SymbolsMapExchangeIdGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1SymbolMapping>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1SymbolMapping>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1SymbolMapping>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
