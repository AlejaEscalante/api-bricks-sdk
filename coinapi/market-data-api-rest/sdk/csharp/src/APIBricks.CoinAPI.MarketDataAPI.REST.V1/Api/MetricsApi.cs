// <auto-generated>
/*
 * CoinAPI Market Data REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client;
using APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model;
using System.Diagnostics.CodeAnalysis;

namespace APIBricks.CoinAPI.MarketDataAPI.REST.V1.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IMetricsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        MetricsApiEvents Events { get; }

        /// <summary>
        /// Current metrics for given asset
        /// </summary>
        /// <remarks>
        /// Get current asset metrics.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">Exchange asset identifier (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetCurrentGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsAssetCurrentGetApiResponse> V1MetricsAssetCurrentGetAsync(Option<string> metricId = default, Option<string> assetId = default, Option<string> assetIdExternal = default, Option<string> exchangeId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Current metrics for given asset
        /// </summary>
        /// <remarks>
        /// Get current asset metrics.
        /// </remarks>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">Exchange asset identifier (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetCurrentGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsAssetCurrentGetApiResponse?> V1MetricsAssetCurrentGetOrDefaultAsync(Option<string> metricId = default, Option<string> assetId = default, Option<string> assetIdExternal = default, Option<string> exchangeId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for asset
        /// </summary>
        /// <remarks>
        /// Get asset metrics history.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">Exchange asset identifier (optional)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetHistoryGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsAssetHistoryGetApiResponse> V1MetricsAssetHistoryGetAsync(string metricId, string exchangeId, Option<string> assetId = default, Option<string> assetIdExternal = default, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for asset
        /// </summary>
        /// <remarks>
        /// Get asset metrics history.
        /// </remarks>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">Exchange asset identifier (optional)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetHistoryGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsAssetHistoryGetApiResponse?> V1MetricsAssetHistoryGetOrDefaultAsync(string metricId, string exchangeId, Option<string> assetId = default, Option<string> assetIdExternal = default, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported metrics for asset
        /// </summary>
        /// <remarks>
        /// Get data metrics for asset.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="chainId">Chain identifier (optional)</param>
        /// <param name="networkId">Network identifier (optional)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">The asset external identifier (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetListingGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsAssetListingGetApiResponse> V1MetricsAssetListingGetAsync(Option<string> metricId = default, Option<string> exchangeId = default, Option<string> chainId = default, Option<string> networkId = default, Option<string> assetId = default, Option<string> assetIdExternal = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported metrics for asset
        /// </summary>
        /// <remarks>
        /// Get data metrics for asset.
        /// </remarks>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="chainId">Chain identifier (optional)</param>
        /// <param name="networkId">Network identifier (optional)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">The asset external identifier (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetListingGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsAssetListingGetApiResponse?> V1MetricsAssetListingGetOrDefaultAsync(Option<string> metricId = default, Option<string> exchangeId = default, Option<string> chainId = default, Option<string> networkId = default, Option<string> assetId = default, Option<string> assetIdExternal = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Current metrics for given exchange
        /// </summary>
        /// <remarks>
        /// Get current exchange metrics values.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="metricId">The metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeCurrentGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsExchangeCurrentGetApiResponse> V1MetricsExchangeCurrentGetAsync(string exchangeId, Option<string> metricId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Current metrics for given exchange
        /// </summary>
        /// <remarks>
        /// Get current exchange metrics values.
        /// </remarks>
        /// <param name="exchangeId">The exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="metricId">The metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeCurrentGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsExchangeCurrentGetApiResponse?> V1MetricsExchangeCurrentGetOrDefaultAsync(string exchangeId, Option<string> metricId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for the exchange
        /// </summary>
        /// <remarks>
        /// Get exchange metrics history.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeHistoryGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsExchangeHistoryGetApiResponse> V1MetricsExchangeHistoryGetAsync(string metricId, string exchangeId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for the exchange
        /// </summary>
        /// <remarks>
        /// Get exchange metrics history.
        /// </remarks>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeHistoryGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsExchangeHistoryGetApiResponse?> V1MetricsExchangeHistoryGetOrDefaultAsync(string metricId, string exchangeId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported exchange metrics
        /// </summary>
        /// <remarks>
        /// Get data metrics for exchange.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="metricId">The metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeListingGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsExchangeListingGetApiResponse> V1MetricsExchangeListingGetAsync(string exchangeId, Option<string> metricId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported exchange metrics
        /// </summary>
        /// <remarks>
        /// Get data metrics for exchange.
        /// </remarks>
        /// <param name="exchangeId">The exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="metricId">The metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeListingGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsExchangeListingGetApiResponse?> V1MetricsExchangeListingGetOrDefaultAsync(string exchangeId, Option<string> metricId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported metrics by CoinAPI
        /// </summary>
        /// <remarks>
        /// Get all data metrics.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsListingGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsListingGetApiResponse> V1MetricsListingGetAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported metrics by CoinAPI
        /// </summary>
        /// <remarks>
        /// Get all data metrics.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsListingGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsListingGetApiResponse?> V1MetricsListingGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Current metrics for given symbol
        /// </summary>
        /// <remarks>
        /// Get current symbol metrics.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols) (optional)</param>
        /// <param name="exchangeId">Exchange id (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolCurrentGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsSymbolCurrentGetApiResponse> V1MetricsSymbolCurrentGetAsync(Option<string> metricId = default, Option<string> symbolId = default, Option<string> exchangeId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Current metrics for given symbol
        /// </summary>
        /// <remarks>
        /// Get current symbol metrics.
        /// </remarks>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols) (optional)</param>
        /// <param name="exchangeId">Exchange id (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolCurrentGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsSymbolCurrentGetApiResponse?> V1MetricsSymbolCurrentGetOrDefaultAsync(Option<string> metricId = default, Option<string> symbolId = default, Option<string> exchangeId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for symbol
        /// </summary>
        /// <remarks>
        /// Get symbol metrics history.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolHistoryGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsSymbolHistoryGetApiResponse> V1MetricsSymbolHistoryGetAsync(string metricId, string symbolId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical metrics for symbol
        /// </summary>
        /// <remarks>
        /// Get symbol metrics history.
        /// </remarks>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolHistoryGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsSymbolHistoryGetApiResponse?> V1MetricsSymbolHistoryGetOrDefaultAsync(string metricId, string symbolId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported metrics for symbol
        /// </summary>
        /// <remarks>
        /// Get data metrics for symbol.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolListingGetApiResponse"/>&gt;</returns>
        Task<IV1MetricsSymbolListingGetApiResponse> V1MetricsSymbolListingGetAsync(Option<string> metricId = default, Option<string> exchangeId = default, Option<string> symbolId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Listing of all supported metrics for symbol
        /// </summary>
        /// <remarks>
        /// Get data metrics for symbol.
        /// </remarks>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolListingGetApiResponse"/>?&gt;</returns>
        Task<IV1MetricsSymbolListingGetApiResponse?> V1MetricsSymbolListingGetOrDefaultAsync(Option<string> metricId = default, Option<string> exchangeId = default, Option<string> symbolId = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IV1MetricsAssetCurrentGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsAssetCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1GeneralData>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1MetricsAssetHistoryGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsAssetHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1MetricData>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1MetricsAssetListingGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsAssetListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1ListingItem>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1MetricsExchangeCurrentGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsExchangeCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1GeneralData>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1MetricsExchangeHistoryGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsExchangeHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1MetricData>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1MetricsExchangeListingGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsExchangeListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1ListingItem>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1MetricsListingGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1Metric>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1MetricsSymbolCurrentGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsSymbolCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1GeneralData>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1MetricsSymbolHistoryGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsSymbolHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1MetricData>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1MetricsSymbolListingGetApiResponse"/>
    /// </summary>
    public interface IV1MetricsSymbolListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1ListingItem>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class MetricsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsAssetCurrentGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsAssetCurrentGet;

        internal void ExecuteOnV1MetricsAssetCurrentGet(MetricsApi.V1MetricsAssetCurrentGetApiResponse apiResponse)
        {
            OnV1MetricsAssetCurrentGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsAssetCurrentGet(Exception exception)
        {
            OnErrorV1MetricsAssetCurrentGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsAssetHistoryGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsAssetHistoryGet;

        internal void ExecuteOnV1MetricsAssetHistoryGet(MetricsApi.V1MetricsAssetHistoryGetApiResponse apiResponse)
        {
            OnV1MetricsAssetHistoryGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsAssetHistoryGet(Exception exception)
        {
            OnErrorV1MetricsAssetHistoryGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsAssetListingGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsAssetListingGet;

        internal void ExecuteOnV1MetricsAssetListingGet(MetricsApi.V1MetricsAssetListingGetApiResponse apiResponse)
        {
            OnV1MetricsAssetListingGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsAssetListingGet(Exception exception)
        {
            OnErrorV1MetricsAssetListingGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsExchangeCurrentGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsExchangeCurrentGet;

        internal void ExecuteOnV1MetricsExchangeCurrentGet(MetricsApi.V1MetricsExchangeCurrentGetApiResponse apiResponse)
        {
            OnV1MetricsExchangeCurrentGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsExchangeCurrentGet(Exception exception)
        {
            OnErrorV1MetricsExchangeCurrentGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsExchangeHistoryGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsExchangeHistoryGet;

        internal void ExecuteOnV1MetricsExchangeHistoryGet(MetricsApi.V1MetricsExchangeHistoryGetApiResponse apiResponse)
        {
            OnV1MetricsExchangeHistoryGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsExchangeHistoryGet(Exception exception)
        {
            OnErrorV1MetricsExchangeHistoryGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsExchangeListingGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsExchangeListingGet;

        internal void ExecuteOnV1MetricsExchangeListingGet(MetricsApi.V1MetricsExchangeListingGetApiResponse apiResponse)
        {
            OnV1MetricsExchangeListingGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsExchangeListingGet(Exception exception)
        {
            OnErrorV1MetricsExchangeListingGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsListingGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsListingGet;

        internal void ExecuteOnV1MetricsListingGet(MetricsApi.V1MetricsListingGetApiResponse apiResponse)
        {
            OnV1MetricsListingGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsListingGet(Exception exception)
        {
            OnErrorV1MetricsListingGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsSymbolCurrentGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsSymbolCurrentGet;

        internal void ExecuteOnV1MetricsSymbolCurrentGet(MetricsApi.V1MetricsSymbolCurrentGetApiResponse apiResponse)
        {
            OnV1MetricsSymbolCurrentGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsSymbolCurrentGet(Exception exception)
        {
            OnErrorV1MetricsSymbolCurrentGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsSymbolHistoryGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsSymbolHistoryGet;

        internal void ExecuteOnV1MetricsSymbolHistoryGet(MetricsApi.V1MetricsSymbolHistoryGetApiResponse apiResponse)
        {
            OnV1MetricsSymbolHistoryGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsSymbolHistoryGet(Exception exception)
        {
            OnErrorV1MetricsSymbolHistoryGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1MetricsSymbolListingGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1MetricsSymbolListingGet;

        internal void ExecuteOnV1MetricsSymbolListingGet(MetricsApi.V1MetricsSymbolListingGetApiResponse apiResponse)
        {
            OnV1MetricsSymbolListingGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1MetricsSymbolListingGet(Exception exception)
        {
            OnErrorV1MetricsSymbolListingGet?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class MetricsApi : IMetricsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<MetricsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public MetricsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MetricsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MetricsApi(ILogger<MetricsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, MetricsApiEvents metricsApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<MetricsApi>();
            HttpClient = httpClient;
            Events = metricsApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatV1MetricsAssetCurrentGet(ref Option<string> metricId, ref Option<string> assetId, ref Option<string> assetIdExternal, ref Option<string> exchangeId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="exchangeId"></param>
        /// <returns></returns>
        private void ValidateV1MetricsAssetCurrentGet(Option<string> metricId, Option<string> assetId, Option<string> assetIdExternal, Option<string> exchangeId)
        {
            if (metricId.IsSet && metricId.Value == null)
                throw new ArgumentNullException(nameof(metricId));

            if (assetId.IsSet && assetId.Value == null)
                throw new ArgumentNullException(nameof(assetId));

            if (assetIdExternal.IsSet && assetIdExternal.Value == null)
                throw new ArgumentNullException(nameof(assetIdExternal));

            if (exchangeId.IsSet && exchangeId.Value == null)
                throw new ArgumentNullException(nameof(exchangeId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="exchangeId"></param>
        private void AfterV1MetricsAssetCurrentGetDefaultImplementation(IV1MetricsAssetCurrentGetApiResponse apiResponseLocalVar, Option<string> metricId, Option<string> assetId, Option<string> assetIdExternal, Option<string> exchangeId)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsAssetCurrentGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, assetId, assetIdExternal, exchangeId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="exchangeId"></param>
        partial void AfterV1MetricsAssetCurrentGet(ref bool suppressDefaultLog, IV1MetricsAssetCurrentGetApiResponse apiResponseLocalVar, Option<string> metricId, Option<string> assetId, Option<string> assetIdExternal, Option<string> exchangeId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="exchangeId"></param>
        private void OnErrorV1MetricsAssetCurrentGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> metricId, Option<string> assetId, Option<string> assetIdExternal, Option<string> exchangeId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsAssetCurrentGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, assetId, assetIdExternal, exchangeId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="exchangeId"></param>
        partial void OnErrorV1MetricsAssetCurrentGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> metricId, Option<string> assetId, Option<string> assetIdExternal, Option<string> exchangeId);

        /// <summary>
        /// Current metrics for given asset Get current asset metrics.
        /// </summary>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">Exchange asset identifier (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsAssetCurrentGetApiResponse?> V1MetricsAssetCurrentGetOrDefaultAsync(Option<string> metricId = default, Option<string> assetId = default, Option<string> assetIdExternal = default, Option<string> exchangeId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsAssetCurrentGetAsync(metricId, assetId, assetIdExternal, exchangeId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Current metrics for given asset Get current asset metrics.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">Exchange asset identifier (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsAssetCurrentGetApiResponse> V1MetricsAssetCurrentGetAsync(Option<string> metricId = default, Option<string> assetId = default, Option<string> assetIdExternal = default, Option<string> exchangeId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1MetricsAssetCurrentGet(metricId, assetId, assetIdExternal, exchangeId);

                FormatV1MetricsAssetCurrentGet(ref metricId, ref assetId, ref assetIdExternal, ref exchangeId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/asset/current"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/asset/current");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (metricId.IsSet)
                        parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId.Value);

                    if (assetId.IsSet)
                        parseQueryStringLocalVar["asset_id"] = ClientUtils.ParameterToString(assetId.Value);

                    if (assetIdExternal.IsSet)
                        parseQueryStringLocalVar["asset_id_external"] = ClientUtils.ParameterToString(assetIdExternal.Value);

                    if (exchangeId.IsSet)
                        parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsAssetCurrentGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsAssetCurrentGetApiResponse>();

                        V1MetricsAssetCurrentGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/asset/current", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsAssetCurrentGetDefaultImplementation(apiResponseLocalVar, metricId, assetId, assetIdExternal, exchangeId);

                        Events.ExecuteOnV1MetricsAssetCurrentGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsAssetCurrentGetDefaultImplementation(e, "/v1/metrics/asset/current", uriBuilderLocalVar.Path, metricId, assetId, assetIdExternal, exchangeId);
                Events.ExecuteOnErrorV1MetricsAssetCurrentGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsAssetCurrentGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsAssetCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsAssetCurrentGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsAssetCurrentGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsAssetCurrentGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsAssetCurrentGetApiResponse(ILogger<V1MetricsAssetCurrentGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1GeneralData>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1GeneralData>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1GeneralData>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1MetricsAssetHistoryGet(ref string metricId, ref string exchangeId, ref Option<string> assetId, ref Option<string> assetIdExternal, ref Option<DateTime> timeStart, ref Option<DateTime> timeEnd, ref Option<string> timeFormat, ref Option<string> periodId, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <returns></returns>
        private void ValidateV1MetricsAssetHistoryGet(string metricId, string exchangeId, Option<string> assetId, Option<string> assetIdExternal, Option<string> timeFormat, Option<string> periodId)
        {
            if (metricId == null)
                throw new ArgumentNullException(nameof(metricId));

            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));

            if (assetId.IsSet && assetId.Value == null)
                throw new ArgumentNullException(nameof(assetId));

            if (assetIdExternal.IsSet && assetIdExternal.Value == null)
                throw new ArgumentNullException(nameof(assetIdExternal));

            if (timeFormat.IsSet && timeFormat.Value == null)
                throw new ArgumentNullException(nameof(timeFormat));

            if (periodId.IsSet && periodId.Value == null)
                throw new ArgumentNullException(nameof(periodId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void AfterV1MetricsAssetHistoryGetDefaultImplementation(IV1MetricsAssetHistoryGetApiResponse apiResponseLocalVar, string metricId, string exchangeId, Option<string> assetId, Option<string> assetIdExternal, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsAssetHistoryGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, exchangeId, assetId, assetIdExternal, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void AfterV1MetricsAssetHistoryGet(ref bool suppressDefaultLog, IV1MetricsAssetHistoryGetApiResponse apiResponseLocalVar, string metricId, string exchangeId, Option<string> assetId, Option<string> assetIdExternal, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void OnErrorV1MetricsAssetHistoryGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string exchangeId, Option<string> assetId, Option<string> assetIdExternal, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsAssetHistoryGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, exchangeId, assetId, assetIdExternal, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void OnErrorV1MetricsAssetHistoryGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string exchangeId, Option<string> assetId, Option<string> assetIdExternal, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Historical metrics for asset Get asset metrics history.
        /// </summary>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">Exchange asset identifier (optional)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsAssetHistoryGetApiResponse?> V1MetricsAssetHistoryGetOrDefaultAsync(string metricId, string exchangeId, Option<string> assetId = default, Option<string> assetIdExternal = default, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsAssetHistoryGetAsync(metricId, exchangeId, assetId, assetIdExternal, timeStart, timeEnd, timeFormat, periodId, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Historical metrics for asset Get asset metrics history.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">Exchange asset identifier (optional)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsAssetHistoryGetApiResponse> V1MetricsAssetHistoryGetAsync(string metricId, string exchangeId, Option<string> assetId = default, Option<string> assetIdExternal = default, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1MetricsAssetHistoryGet(metricId, exchangeId, assetId, assetIdExternal, timeFormat, periodId);

                FormatV1MetricsAssetHistoryGet(ref metricId, ref exchangeId, ref assetId, ref assetIdExternal, ref timeStart, ref timeEnd, ref timeFormat, ref periodId, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/asset/history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/asset/history");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId);
                    parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId);

                    if (assetId.IsSet)
                        parseQueryStringLocalVar["asset_id"] = ClientUtils.ParameterToString(assetId.Value);

                    if (assetIdExternal.IsSet)
                        parseQueryStringLocalVar["asset_id_external"] = ClientUtils.ParameterToString(assetIdExternal.Value);

                    if (timeStart.IsSet)
                        parseQueryStringLocalVar["time_start"] = ClientUtils.ParameterToString(timeStart.Value);

                    if (timeEnd.IsSet)
                        parseQueryStringLocalVar["time_end"] = ClientUtils.ParameterToString(timeEnd.Value);

                    if (timeFormat.IsSet)
                        parseQueryStringLocalVar["time_format"] = ClientUtils.ParameterToString(timeFormat.Value);

                    if (periodId.IsSet)
                        parseQueryStringLocalVar["period_id"] = ClientUtils.ParameterToString(periodId.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsAssetHistoryGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsAssetHistoryGetApiResponse>();

                        V1MetricsAssetHistoryGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/asset/history", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsAssetHistoryGetDefaultImplementation(apiResponseLocalVar, metricId, exchangeId, assetId, assetIdExternal, timeStart, timeEnd, timeFormat, periodId, limit);

                        Events.ExecuteOnV1MetricsAssetHistoryGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsAssetHistoryGetDefaultImplementation(e, "/v1/metrics/asset/history", uriBuilderLocalVar.Path, metricId, exchangeId, assetId, assetIdExternal, timeStart, timeEnd, timeFormat, periodId, limit);
                Events.ExecuteOnErrorV1MetricsAssetHistoryGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsAssetHistoryGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsAssetHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsAssetHistoryGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsAssetHistoryGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsAssetHistoryGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsAssetHistoryGetApiResponse(ILogger<V1MetricsAssetHistoryGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1MetricData>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1MetricData>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1MetricData>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1MetricsAssetListingGet(ref Option<string> metricId, ref Option<string> exchangeId, ref Option<string> chainId, ref Option<string> networkId, ref Option<string> assetId, ref Option<string> assetIdExternal);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="chainId"></param>
        /// <param name="networkId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        /// <returns></returns>
        private void ValidateV1MetricsAssetListingGet(Option<string> metricId, Option<string> exchangeId, Option<string> chainId, Option<string> networkId, Option<string> assetId, Option<string> assetIdExternal)
        {
            if (metricId.IsSet && metricId.Value == null)
                throw new ArgumentNullException(nameof(metricId));

            if (exchangeId.IsSet && exchangeId.Value == null)
                throw new ArgumentNullException(nameof(exchangeId));

            if (chainId.IsSet && chainId.Value == null)
                throw new ArgumentNullException(nameof(chainId));

            if (networkId.IsSet && networkId.Value == null)
                throw new ArgumentNullException(nameof(networkId));

            if (assetId.IsSet && assetId.Value == null)
                throw new ArgumentNullException(nameof(assetId));

            if (assetIdExternal.IsSet && assetIdExternal.Value == null)
                throw new ArgumentNullException(nameof(assetIdExternal));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="chainId"></param>
        /// <param name="networkId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        private void AfterV1MetricsAssetListingGetDefaultImplementation(IV1MetricsAssetListingGetApiResponse apiResponseLocalVar, Option<string> metricId, Option<string> exchangeId, Option<string> chainId, Option<string> networkId, Option<string> assetId, Option<string> assetIdExternal)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsAssetListingGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, exchangeId, chainId, networkId, assetId, assetIdExternal);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="chainId"></param>
        /// <param name="networkId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        partial void AfterV1MetricsAssetListingGet(ref bool suppressDefaultLog, IV1MetricsAssetListingGetApiResponse apiResponseLocalVar, Option<string> metricId, Option<string> exchangeId, Option<string> chainId, Option<string> networkId, Option<string> assetId, Option<string> assetIdExternal);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="chainId"></param>
        /// <param name="networkId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        private void OnErrorV1MetricsAssetListingGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> metricId, Option<string> exchangeId, Option<string> chainId, Option<string> networkId, Option<string> assetId, Option<string> assetIdExternal)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsAssetListingGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, exchangeId, chainId, networkId, assetId, assetIdExternal);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="chainId"></param>
        /// <param name="networkId"></param>
        /// <param name="assetId"></param>
        /// <param name="assetIdExternal"></param>
        partial void OnErrorV1MetricsAssetListingGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> metricId, Option<string> exchangeId, Option<string> chainId, Option<string> networkId, Option<string> assetId, Option<string> assetIdExternal);

        /// <summary>
        /// Listing of all supported metrics for asset Get data metrics for asset.
        /// </summary>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="chainId">Chain identifier (optional)</param>
        /// <param name="networkId">Network identifier (optional)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">The asset external identifier (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsAssetListingGetApiResponse?> V1MetricsAssetListingGetOrDefaultAsync(Option<string> metricId = default, Option<string> exchangeId = default, Option<string> chainId = default, Option<string> networkId = default, Option<string> assetId = default, Option<string> assetIdExternal = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsAssetListingGetAsync(metricId, exchangeId, chainId, networkId, assetId, assetIdExternal, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of all supported metrics for asset Get data metrics for asset.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="chainId">Chain identifier (optional)</param>
        /// <param name="networkId">Network identifier (optional)</param>
        /// <param name="assetId">Asset identifier (from the Metadata -&gt; Assets) (optional)</param>
        /// <param name="assetIdExternal">The asset external identifier (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsAssetListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsAssetListingGetApiResponse> V1MetricsAssetListingGetAsync(Option<string> metricId = default, Option<string> exchangeId = default, Option<string> chainId = default, Option<string> networkId = default, Option<string> assetId = default, Option<string> assetIdExternal = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1MetricsAssetListingGet(metricId, exchangeId, chainId, networkId, assetId, assetIdExternal);

                FormatV1MetricsAssetListingGet(ref metricId, ref exchangeId, ref chainId, ref networkId, ref assetId, ref assetIdExternal);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/asset/listing"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/asset/listing");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (metricId.IsSet)
                        parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId.Value);

                    if (exchangeId.IsSet)
                        parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId.Value);

                    if (chainId.IsSet)
                        parseQueryStringLocalVar["chain_id"] = ClientUtils.ParameterToString(chainId.Value);

                    if (networkId.IsSet)
                        parseQueryStringLocalVar["network_id"] = ClientUtils.ParameterToString(networkId.Value);

                    if (assetId.IsSet)
                        parseQueryStringLocalVar["asset_id"] = ClientUtils.ParameterToString(assetId.Value);

                    if (assetIdExternal.IsSet)
                        parseQueryStringLocalVar["asset_id_external"] = ClientUtils.ParameterToString(assetIdExternal.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsAssetListingGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsAssetListingGetApiResponse>();

                        V1MetricsAssetListingGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/asset/listing", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsAssetListingGetDefaultImplementation(apiResponseLocalVar, metricId, exchangeId, chainId, networkId, assetId, assetIdExternal);

                        Events.ExecuteOnV1MetricsAssetListingGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsAssetListingGetDefaultImplementation(e, "/v1/metrics/asset/listing", uriBuilderLocalVar.Path, metricId, exchangeId, chainId, networkId, assetId, assetIdExternal);
                Events.ExecuteOnErrorV1MetricsAssetListingGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsAssetListingGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsAssetListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsAssetListingGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsAssetListingGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsAssetListingGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsAssetListingGetApiResponse(ILogger<V1MetricsAssetListingGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1ListingItem>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1ListingItem>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1ListingItem>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1MetricsExchangeCurrentGet(ref string exchangeId, ref Option<string> metricId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        /// <returns></returns>
        private void ValidateV1MetricsExchangeCurrentGet(string exchangeId, Option<string> metricId)
        {
            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));

            if (metricId.IsSet && metricId.Value == null)
                throw new ArgumentNullException(nameof(metricId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        private void AfterV1MetricsExchangeCurrentGetDefaultImplementation(IV1MetricsExchangeCurrentGetApiResponse apiResponseLocalVar, string exchangeId, Option<string> metricId)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsExchangeCurrentGet(ref suppressDefaultLog, apiResponseLocalVar, exchangeId, metricId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        partial void AfterV1MetricsExchangeCurrentGet(ref bool suppressDefaultLog, IV1MetricsExchangeCurrentGetApiResponse apiResponseLocalVar, string exchangeId, Option<string> metricId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        private void OnErrorV1MetricsExchangeCurrentGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId, Option<string> metricId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsExchangeCurrentGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, exchangeId, metricId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        partial void OnErrorV1MetricsExchangeCurrentGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId, Option<string> metricId);

        /// <summary>
        /// Current metrics for given exchange Get current exchange metrics values.
        /// </summary>
        /// <param name="exchangeId">The exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="metricId">The metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsExchangeCurrentGetApiResponse?> V1MetricsExchangeCurrentGetOrDefaultAsync(string exchangeId, Option<string> metricId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsExchangeCurrentGetAsync(exchangeId, metricId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Current metrics for given exchange Get current exchange metrics values.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="metricId">The metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsExchangeCurrentGetApiResponse> V1MetricsExchangeCurrentGetAsync(string exchangeId, Option<string> metricId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1MetricsExchangeCurrentGet(exchangeId, metricId);

                FormatV1MetricsExchangeCurrentGet(ref exchangeId, ref metricId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/exchange/current"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/exchange/current");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId);

                    if (metricId.IsSet)
                        parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsExchangeCurrentGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsExchangeCurrentGetApiResponse>();

                        V1MetricsExchangeCurrentGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/exchange/current", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsExchangeCurrentGetDefaultImplementation(apiResponseLocalVar, exchangeId, metricId);

                        Events.ExecuteOnV1MetricsExchangeCurrentGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsExchangeCurrentGetDefaultImplementation(e, "/v1/metrics/exchange/current", uriBuilderLocalVar.Path, exchangeId, metricId);
                Events.ExecuteOnErrorV1MetricsExchangeCurrentGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsExchangeCurrentGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsExchangeCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsExchangeCurrentGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsExchangeCurrentGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsExchangeCurrentGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsExchangeCurrentGetApiResponse(ILogger<V1MetricsExchangeCurrentGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1GeneralData>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1GeneralData>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1GeneralData>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1MetricsExchangeHistoryGet(ref string metricId, ref string exchangeId, ref Option<DateTime> timeStart, ref Option<DateTime> timeEnd, ref Option<string> timeFormat, ref Option<string> periodId, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <returns></returns>
        private void ValidateV1MetricsExchangeHistoryGet(string metricId, string exchangeId, Option<string> timeFormat, Option<string> periodId)
        {
            if (metricId == null)
                throw new ArgumentNullException(nameof(metricId));

            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));

            if (timeFormat.IsSet && timeFormat.Value == null)
                throw new ArgumentNullException(nameof(timeFormat));

            if (periodId.IsSet && periodId.Value == null)
                throw new ArgumentNullException(nameof(periodId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void AfterV1MetricsExchangeHistoryGetDefaultImplementation(IV1MetricsExchangeHistoryGetApiResponse apiResponseLocalVar, string metricId, string exchangeId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsExchangeHistoryGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void AfterV1MetricsExchangeHistoryGet(ref bool suppressDefaultLog, IV1MetricsExchangeHistoryGetApiResponse apiResponseLocalVar, string metricId, string exchangeId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void OnErrorV1MetricsExchangeHistoryGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string exchangeId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsExchangeHistoryGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void OnErrorV1MetricsExchangeHistoryGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string exchangeId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Historical metrics for the exchange Get exchange metrics history.
        /// </summary>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsExchangeHistoryGetApiResponse?> V1MetricsExchangeHistoryGetOrDefaultAsync(string metricId, string exchangeId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsExchangeHistoryGetAsync(metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Historical metrics for the exchange Get exchange metrics history.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsExchangeHistoryGetApiResponse> V1MetricsExchangeHistoryGetAsync(string metricId, string exchangeId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1MetricsExchangeHistoryGet(metricId, exchangeId, timeFormat, periodId);

                FormatV1MetricsExchangeHistoryGet(ref metricId, ref exchangeId, ref timeStart, ref timeEnd, ref timeFormat, ref periodId, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/exchange/history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/exchange/history");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId);
                    parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId);

                    if (timeStart.IsSet)
                        parseQueryStringLocalVar["time_start"] = ClientUtils.ParameterToString(timeStart.Value);

                    if (timeEnd.IsSet)
                        parseQueryStringLocalVar["time_end"] = ClientUtils.ParameterToString(timeEnd.Value);

                    if (timeFormat.IsSet)
                        parseQueryStringLocalVar["time_format"] = ClientUtils.ParameterToString(timeFormat.Value);

                    if (periodId.IsSet)
                        parseQueryStringLocalVar["period_id"] = ClientUtils.ParameterToString(periodId.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsExchangeHistoryGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsExchangeHistoryGetApiResponse>();

                        V1MetricsExchangeHistoryGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/exchange/history", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsExchangeHistoryGetDefaultImplementation(apiResponseLocalVar, metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit);

                        Events.ExecuteOnV1MetricsExchangeHistoryGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsExchangeHistoryGetDefaultImplementation(e, "/v1/metrics/exchange/history", uriBuilderLocalVar.Path, metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit);
                Events.ExecuteOnErrorV1MetricsExchangeHistoryGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsExchangeHistoryGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsExchangeHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsExchangeHistoryGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsExchangeHistoryGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsExchangeHistoryGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsExchangeHistoryGetApiResponse(ILogger<V1MetricsExchangeHistoryGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1MetricData>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1MetricData>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1MetricData>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1MetricsExchangeListingGet(ref string exchangeId, ref Option<string> metricId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        /// <returns></returns>
        private void ValidateV1MetricsExchangeListingGet(string exchangeId, Option<string> metricId)
        {
            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));

            if (metricId.IsSet && metricId.Value == null)
                throw new ArgumentNullException(nameof(metricId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        private void AfterV1MetricsExchangeListingGetDefaultImplementation(IV1MetricsExchangeListingGetApiResponse apiResponseLocalVar, string exchangeId, Option<string> metricId)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsExchangeListingGet(ref suppressDefaultLog, apiResponseLocalVar, exchangeId, metricId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        partial void AfterV1MetricsExchangeListingGet(ref bool suppressDefaultLog, IV1MetricsExchangeListingGetApiResponse apiResponseLocalVar, string exchangeId, Option<string> metricId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        private void OnErrorV1MetricsExchangeListingGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId, Option<string> metricId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsExchangeListingGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, exchangeId, metricId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        /// <param name="metricId"></param>
        partial void OnErrorV1MetricsExchangeListingGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId, Option<string> metricId);

        /// <summary>
        /// Listing of all supported exchange metrics Get data metrics for exchange.
        /// </summary>
        /// <param name="exchangeId">The exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="metricId">The metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsExchangeListingGetApiResponse?> V1MetricsExchangeListingGetOrDefaultAsync(string exchangeId, Option<string> metricId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsExchangeListingGetAsync(exchangeId, metricId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of all supported exchange metrics Get data metrics for exchange.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The exchange identifier (from the Metadata -&gt; Exchanges)</param>
        /// <param name="metricId">The metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsExchangeListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsExchangeListingGetApiResponse> V1MetricsExchangeListingGetAsync(string exchangeId, Option<string> metricId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1MetricsExchangeListingGet(exchangeId, metricId);

                FormatV1MetricsExchangeListingGet(ref exchangeId, ref metricId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/exchange/listing"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/exchange/listing");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId);

                    if (metricId.IsSet)
                        parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsExchangeListingGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsExchangeListingGetApiResponse>();

                        V1MetricsExchangeListingGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/exchange/listing", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsExchangeListingGetDefaultImplementation(apiResponseLocalVar, exchangeId, metricId);

                        Events.ExecuteOnV1MetricsExchangeListingGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsExchangeListingGetDefaultImplementation(e, "/v1/metrics/exchange/listing", uriBuilderLocalVar.Path, exchangeId, metricId);
                Events.ExecuteOnErrorV1MetricsExchangeListingGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsExchangeListingGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsExchangeListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsExchangeListingGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsExchangeListingGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsExchangeListingGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsExchangeListingGetApiResponse(ILogger<V1MetricsExchangeListingGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1ListingItem>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1ListingItem>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1ListingItem>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterV1MetricsListingGetDefaultImplementation(IV1MetricsListingGetApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsListingGet(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterV1MetricsListingGet(ref bool suppressDefaultLog, IV1MetricsListingGetApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorV1MetricsListingGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsListingGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorV1MetricsListingGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Listing of all supported metrics by CoinAPI Get all data metrics.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsListingGetApiResponse?> V1MetricsListingGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsListingGetAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of all supported metrics by CoinAPI Get all data metrics.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsListingGetApiResponse> V1MetricsListingGetAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/listing"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/listing");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsListingGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsListingGetApiResponse>();

                        V1MetricsListingGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/listing", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsListingGetDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnV1MetricsListingGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsListingGetDefaultImplementation(e, "/v1/metrics/listing", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorV1MetricsListingGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsListingGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsListingGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsListingGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsListingGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsListingGetApiResponse(ILogger<V1MetricsListingGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1Metric>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1Metric>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1Metric>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1MetricsSymbolCurrentGet(ref Option<string> metricId, ref Option<string> symbolId, ref Option<string> exchangeId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="exchangeId"></param>
        /// <returns></returns>
        private void ValidateV1MetricsSymbolCurrentGet(Option<string> metricId, Option<string> symbolId, Option<string> exchangeId)
        {
            if (metricId.IsSet && metricId.Value == null)
                throw new ArgumentNullException(nameof(metricId));

            if (symbolId.IsSet && symbolId.Value == null)
                throw new ArgumentNullException(nameof(symbolId));

            if (exchangeId.IsSet && exchangeId.Value == null)
                throw new ArgumentNullException(nameof(exchangeId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="exchangeId"></param>
        private void AfterV1MetricsSymbolCurrentGetDefaultImplementation(IV1MetricsSymbolCurrentGetApiResponse apiResponseLocalVar, Option<string> metricId, Option<string> symbolId, Option<string> exchangeId)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsSymbolCurrentGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, symbolId, exchangeId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="exchangeId"></param>
        partial void AfterV1MetricsSymbolCurrentGet(ref bool suppressDefaultLog, IV1MetricsSymbolCurrentGetApiResponse apiResponseLocalVar, Option<string> metricId, Option<string> symbolId, Option<string> exchangeId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="exchangeId"></param>
        private void OnErrorV1MetricsSymbolCurrentGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> metricId, Option<string> symbolId, Option<string> exchangeId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsSymbolCurrentGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, symbolId, exchangeId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="exchangeId"></param>
        partial void OnErrorV1MetricsSymbolCurrentGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> metricId, Option<string> symbolId, Option<string> exchangeId);

        /// <summary>
        /// Current metrics for given symbol Get current symbol metrics.
        /// </summary>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols) (optional)</param>
        /// <param name="exchangeId">Exchange id (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsSymbolCurrentGetApiResponse?> V1MetricsSymbolCurrentGetOrDefaultAsync(Option<string> metricId = default, Option<string> symbolId = default, Option<string> exchangeId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsSymbolCurrentGetAsync(metricId, symbolId, exchangeId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Current metrics for given symbol Get current symbol metrics.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols) (optional)</param>
        /// <param name="exchangeId">Exchange id (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsSymbolCurrentGetApiResponse> V1MetricsSymbolCurrentGetAsync(Option<string> metricId = default, Option<string> symbolId = default, Option<string> exchangeId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1MetricsSymbolCurrentGet(metricId, symbolId, exchangeId);

                FormatV1MetricsSymbolCurrentGet(ref metricId, ref symbolId, ref exchangeId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/symbol/current"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/symbol/current");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (metricId.IsSet)
                        parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId.Value);

                    if (symbolId.IsSet)
                        parseQueryStringLocalVar["symbol_id"] = ClientUtils.ParameterToString(symbolId.Value);

                    if (exchangeId.IsSet)
                        parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsSymbolCurrentGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsSymbolCurrentGetApiResponse>();

                        V1MetricsSymbolCurrentGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/symbol/current", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsSymbolCurrentGetDefaultImplementation(apiResponseLocalVar, metricId, symbolId, exchangeId);

                        Events.ExecuteOnV1MetricsSymbolCurrentGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsSymbolCurrentGetDefaultImplementation(e, "/v1/metrics/symbol/current", uriBuilderLocalVar.Path, metricId, symbolId, exchangeId);
                Events.ExecuteOnErrorV1MetricsSymbolCurrentGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsSymbolCurrentGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsSymbolCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsSymbolCurrentGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsSymbolCurrentGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsSymbolCurrentGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsSymbolCurrentGetApiResponse(ILogger<V1MetricsSymbolCurrentGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1GeneralData>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1GeneralData>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1GeneralData>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1MetricsSymbolHistoryGet(ref string metricId, ref string symbolId, ref Option<DateTime> timeStart, ref Option<DateTime> timeEnd, ref Option<string> timeFormat, ref Option<string> periodId, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <returns></returns>
        private void ValidateV1MetricsSymbolHistoryGet(string metricId, string symbolId, Option<string> timeFormat, Option<string> periodId)
        {
            if (metricId == null)
                throw new ArgumentNullException(nameof(metricId));

            if (symbolId == null)
                throw new ArgumentNullException(nameof(symbolId));

            if (timeFormat.IsSet && timeFormat.Value == null)
                throw new ArgumentNullException(nameof(timeFormat));

            if (periodId.IsSet && periodId.Value == null)
                throw new ArgumentNullException(nameof(periodId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void AfterV1MetricsSymbolHistoryGetDefaultImplementation(IV1MetricsSymbolHistoryGetApiResponse apiResponseLocalVar, string metricId, string symbolId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsSymbolHistoryGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, symbolId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void AfterV1MetricsSymbolHistoryGet(ref bool suppressDefaultLog, IV1MetricsSymbolHistoryGetApiResponse apiResponseLocalVar, string metricId, string symbolId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        private void OnErrorV1MetricsSymbolHistoryGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string symbolId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsSymbolHistoryGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, symbolId, timeStart, timeEnd, timeFormat, periodId, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="symbolId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="timeFormat"></param>
        /// <param name="periodId"></param>
        /// <param name="limit"></param>
        partial void OnErrorV1MetricsSymbolHistoryGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string metricId, string symbolId, Option<DateTime> timeStart, Option<DateTime> timeEnd, Option<string> timeFormat, Option<string> periodId, Option<int> limit);

        /// <summary>
        /// Historical metrics for symbol Get symbol metrics history.
        /// </summary>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsSymbolHistoryGetApiResponse?> V1MetricsSymbolHistoryGetOrDefaultAsync(string metricId, string symbolId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsSymbolHistoryGetAsync(metricId, symbolId, timeStart, timeEnd, timeFormat, periodId, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Historical metrics for symbol Get symbol metrics history.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (optional)</param>
        /// <param name="timeEnd">Ending time in ISO 8601 (optional)</param>
        /// <param name="timeFormat">If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)</param>
        /// <param name="periodId">Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsSymbolHistoryGetApiResponse> V1MetricsSymbolHistoryGetAsync(string metricId, string symbolId, Option<DateTime> timeStart = default, Option<DateTime> timeEnd = default, Option<string> timeFormat = default, Option<string> periodId = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1MetricsSymbolHistoryGet(metricId, symbolId, timeFormat, periodId);

                FormatV1MetricsSymbolHistoryGet(ref metricId, ref symbolId, ref timeStart, ref timeEnd, ref timeFormat, ref periodId, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/symbol/history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/symbol/history");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId);
                    parseQueryStringLocalVar["symbol_id"] = ClientUtils.ParameterToString(symbolId);

                    if (timeStart.IsSet)
                        parseQueryStringLocalVar["time_start"] = ClientUtils.ParameterToString(timeStart.Value);

                    if (timeEnd.IsSet)
                        parseQueryStringLocalVar["time_end"] = ClientUtils.ParameterToString(timeEnd.Value);

                    if (timeFormat.IsSet)
                        parseQueryStringLocalVar["time_format"] = ClientUtils.ParameterToString(timeFormat.Value);

                    if (periodId.IsSet)
                        parseQueryStringLocalVar["period_id"] = ClientUtils.ParameterToString(periodId.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsSymbolHistoryGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsSymbolHistoryGetApiResponse>();

                        V1MetricsSymbolHistoryGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/symbol/history", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsSymbolHistoryGetDefaultImplementation(apiResponseLocalVar, metricId, symbolId, timeStart, timeEnd, timeFormat, periodId, limit);

                        Events.ExecuteOnV1MetricsSymbolHistoryGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsSymbolHistoryGetDefaultImplementation(e, "/v1/metrics/symbol/history", uriBuilderLocalVar.Path, metricId, symbolId, timeStart, timeEnd, timeFormat, periodId, limit);
                Events.ExecuteOnErrorV1MetricsSymbolHistoryGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsSymbolHistoryGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsSymbolHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsSymbolHistoryGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsSymbolHistoryGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsSymbolHistoryGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsSymbolHistoryGetApiResponse(ILogger<V1MetricsSymbolHistoryGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1MetricData>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1MetricData>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1MetricData>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1MetricsSymbolListingGet(ref Option<string> metricId, ref Option<string> exchangeId, ref Option<string> symbolId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="symbolId"></param>
        /// <returns></returns>
        private void ValidateV1MetricsSymbolListingGet(Option<string> metricId, Option<string> exchangeId, Option<string> symbolId)
        {
            if (metricId.IsSet && metricId.Value == null)
                throw new ArgumentNullException(nameof(metricId));

            if (exchangeId.IsSet && exchangeId.Value == null)
                throw new ArgumentNullException(nameof(exchangeId));

            if (symbolId.IsSet && symbolId.Value == null)
                throw new ArgumentNullException(nameof(symbolId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="symbolId"></param>
        private void AfterV1MetricsSymbolListingGetDefaultImplementation(IV1MetricsSymbolListingGetApiResponse apiResponseLocalVar, Option<string> metricId, Option<string> exchangeId, Option<string> symbolId)
        {
            bool suppressDefaultLog = false;
            AfterV1MetricsSymbolListingGet(ref suppressDefaultLog, apiResponseLocalVar, metricId, exchangeId, symbolId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="symbolId"></param>
        partial void AfterV1MetricsSymbolListingGet(ref bool suppressDefaultLog, IV1MetricsSymbolListingGetApiResponse apiResponseLocalVar, Option<string> metricId, Option<string> exchangeId, Option<string> symbolId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="symbolId"></param>
        private void OnErrorV1MetricsSymbolListingGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> metricId, Option<string> exchangeId, Option<string> symbolId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1MetricsSymbolListingGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, metricId, exchangeId, symbolId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="metricId"></param>
        /// <param name="exchangeId"></param>
        /// <param name="symbolId"></param>
        partial void OnErrorV1MetricsSymbolListingGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> metricId, Option<string> exchangeId, Option<string> symbolId);

        /// <summary>
        /// Listing of all supported metrics for symbol Get data metrics for symbol.
        /// </summary>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsSymbolListingGetApiResponse?> V1MetricsSymbolListingGetOrDefaultAsync(Option<string> metricId = default, Option<string> exchangeId = default, Option<string> symbolId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1MetricsSymbolListingGetAsync(metricId, exchangeId, symbolId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Listing of all supported metrics for symbol Get data metrics for symbol.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="metricId">Metric identifier (from the Metrics -&gt; Listing) (optional)</param>
        /// <param name="exchangeId">Exchange identifier (from the Metadata -&gt; Exchanges) (optional)</param>
        /// <param name="symbolId">Symbol identifier (from the Metadata -&gt; Symbols) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1MetricsSymbolListingGetApiResponse"/>&gt;</returns>
        public async Task<IV1MetricsSymbolListingGetApiResponse> V1MetricsSymbolListingGetAsync(Option<string> metricId = default, Option<string> exchangeId = default, Option<string> symbolId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1MetricsSymbolListingGet(metricId, exchangeId, symbolId);

                FormatV1MetricsSymbolListingGet(ref metricId, ref exchangeId, ref symbolId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/metrics/symbol/listing"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/metrics/symbol/listing");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (metricId.IsSet)
                        parseQueryStringLocalVar["metric_id"] = ClientUtils.ParameterToString(metricId.Value);

                    if (exchangeId.IsSet)
                        parseQueryStringLocalVar["exchange_id"] = ClientUtils.ParameterToString(exchangeId.Value);

                    if (symbolId.IsSet)
                        parseQueryStringLocalVar["symbol_id"] = ClientUtils.ParameterToString(symbolId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1MetricsSymbolListingGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1MetricsSymbolListingGetApiResponse>();

                        V1MetricsSymbolListingGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/metrics/symbol/listing", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1MetricsSymbolListingGetDefaultImplementation(apiResponseLocalVar, metricId, exchangeId, symbolId);

                        Events.ExecuteOnV1MetricsSymbolListingGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1MetricsSymbolListingGetDefaultImplementation(e, "/v1/metrics/symbol/listing", uriBuilderLocalVar.Path, metricId, exchangeId, symbolId);
                Events.ExecuteOnErrorV1MetricsSymbolListingGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1MetricsSymbolListingGetApiResponse"/>
        /// </summary>
        public partial class V1MetricsSymbolListingGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1MetricsSymbolListingGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1MetricsSymbolListingGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1MetricsSymbolListingGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1MetricsSymbolListingGetApiResponse(ILogger<V1MetricsSymbolListingGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1ListingItem>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1ListingItem>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1ListingItem>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
