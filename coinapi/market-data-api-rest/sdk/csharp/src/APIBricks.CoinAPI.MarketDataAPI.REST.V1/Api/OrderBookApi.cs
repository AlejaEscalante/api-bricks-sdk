// <auto-generated>
/*
 * CoinAPI Market Data REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client;
using APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model;
using System.Diagnostics.CodeAnalysis;

namespace APIBricks.CoinAPI.MarketDataAPI.REST.V1.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IOrderBookApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        OrderBookApiEvents Events { get; }

        /// <summary>
        /// Get current order book
        /// </summary>
        /// <remarks>
        /// Retrieves the current order book for the specified symbol.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="symbolId">The symbol ID (from the Metadata -&gt; Symbols)</param>
        /// <param name="limitLevels">The maximum number of levels to include in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdCurrentGetApiResponse"/>&gt;</returns>
        Task<IV1OrderbooksSymbolIdCurrentGetApiResponse> V1OrderbooksSymbolIdCurrentGetAsync(string symbolId, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get current order book
        /// </summary>
        /// <remarks>
        /// Retrieves the current order book for the specified symbol.
        /// </remarks>
        /// <param name="symbolId">The symbol ID (from the Metadata -&gt; Symbols)</param>
        /// <param name="limitLevels">The maximum number of levels to include in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdCurrentGetApiResponse"/>?&gt;</returns>
        Task<IV1OrderbooksSymbolIdCurrentGetApiResponse?> V1OrderbooksSymbolIdCurrentGetOrDefaultAsync(string symbolId, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Current depth of the order book
        /// </summary>
        /// <remarks>
        /// Retrieves the current depth of the order book for the specified symbol.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="symbolId">The symbol ID (from the Metadata -&gt; Symbols)</param>
        /// <param name="limitLevels">The maximum number of levels to include in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdDepthCurrentGetApiResponse"/>&gt;</returns>
        Task<IV1OrderbooksSymbolIdDepthCurrentGetApiResponse> V1OrderbooksSymbolIdDepthCurrentGetAsync(string symbolId, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Current depth of the order book
        /// </summary>
        /// <remarks>
        /// Retrieves the current depth of the order book for the specified symbol.
        /// </remarks>
        /// <param name="symbolId">The symbol ID (from the Metadata -&gt; Symbols)</param>
        /// <param name="limitLevels">The maximum number of levels to include in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdDepthCurrentGetApiResponse"/>?&gt;</returns>
        Task<IV1OrderbooksSymbolIdDepthCurrentGetApiResponse?> V1OrderbooksSymbolIdDepthCurrentGetOrDefaultAsync(string symbolId, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical data
        /// </summary>
        /// <remarks>
        /// Get historical order book snapshots for a specific symbol within time range, returned in time ascending order.              :::info The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels. :::  :::warning The &#39;time_start&#39; and &#39;time_end&#39; parameters must be from the same day as this endpoint provides intraday data only for specific day. Please use the &#39;date&#39; parameter instead for querying data for a specific day without filter. :::
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="symbolId">Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)</param>
        /// <param name="date">Date in ISO 8601, returned data is for the whole given day (preferred method, required if &#39;time_start&#39; is not provided) (optional)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (deprecated, use &#39;date&#39; instead) (optional)</param>
        /// <param name="timeEnd">Timeseries ending time in ISO 8601 (deprecated, use &#39;date&#39; instead) (optional)</param>
        /// <param name="limit">Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="limitLevels">Maximum amount of levels from each side of the book to include in response (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdHistoryGetApiResponse"/>&gt;</returns>
        Task<IV1OrderbooksSymbolIdHistoryGetApiResponse> V1OrderbooksSymbolIdHistoryGetAsync(string symbolId, Option<string> date = default, Option<string> timeStart = default, Option<string> timeEnd = default, Option<int> limit = default, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Historical data
        /// </summary>
        /// <remarks>
        /// Get historical order book snapshots for a specific symbol within time range, returned in time ascending order.              :::info The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels. :::  :::warning The &#39;time_start&#39; and &#39;time_end&#39; parameters must be from the same day as this endpoint provides intraday data only for specific day. Please use the &#39;date&#39; parameter instead for querying data for a specific day without filter. :::
        /// </remarks>
        /// <param name="symbolId">Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)</param>
        /// <param name="date">Date in ISO 8601, returned data is for the whole given day (preferred method, required if &#39;time_start&#39; is not provided) (optional)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (deprecated, use &#39;date&#39; instead) (optional)</param>
        /// <param name="timeEnd">Timeseries ending time in ISO 8601 (deprecated, use &#39;date&#39; instead) (optional)</param>
        /// <param name="limit">Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="limitLevels">Maximum amount of levels from each side of the book to include in response (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdHistoryGetApiResponse"/>?&gt;</returns>
        Task<IV1OrderbooksSymbolIdHistoryGetApiResponse?> V1OrderbooksSymbolIdHistoryGetOrDefaultAsync(string symbolId, Option<string> date = default, Option<string> timeStart = default, Option<string> timeEnd = default, Option<int> limit = default, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Latest data
        /// </summary>
        /// <remarks>
        /// Get latest order book snapshots for a specific symbol, returned in time descending order.              :::info The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels. :::
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="symbolId">Symbol identifier of requested timeseries (from the Metadata -&gt; Symbols)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="limitLevels">Maximum amount of levels from each side of the book to include in response (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdLatestGetApiResponse"/>&gt;</returns>
        Task<IV1OrderbooksSymbolIdLatestGetApiResponse> V1OrderbooksSymbolIdLatestGetAsync(string symbolId, Option<int> limit = default, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Latest data
        /// </summary>
        /// <remarks>
        /// Get latest order book snapshots for a specific symbol, returned in time descending order.              :::info The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels. :::
        /// </remarks>
        /// <param name="symbolId">Symbol identifier of requested timeseries (from the Metadata -&gt; Symbols)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="limitLevels">Maximum amount of levels from each side of the book to include in response (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdLatestGetApiResponse"/>?&gt;</returns>
        Task<IV1OrderbooksSymbolIdLatestGetApiResponse?> V1OrderbooksSymbolIdLatestGetOrDefaultAsync(string symbolId, Option<int> limit = default, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IV1OrderbooksSymbolIdCurrentGetApiResponse"/>
    /// </summary>
    public interface IV1OrderbooksSymbolIdCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model.V1OrderBookBase?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1OrderbooksSymbolIdDepthCurrentGetApiResponse"/>
    /// </summary>
    public interface IV1OrderbooksSymbolIdDepthCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model.V1OrderBookDepth?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1OrderbooksSymbolIdHistoryGetApiResponse"/>
    /// </summary>
    public interface IV1OrderbooksSymbolIdHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1OrderBook>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1OrderbooksSymbolIdLatestGetApiResponse"/>
    /// </summary>
    public interface IV1OrderbooksSymbolIdLatestGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.IApiResponse, IOk<List<V1OrderBook>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class OrderBookApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1OrderbooksSymbolIdCurrentGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1OrderbooksSymbolIdCurrentGet;

        internal void ExecuteOnV1OrderbooksSymbolIdCurrentGet(OrderBookApi.V1OrderbooksSymbolIdCurrentGetApiResponse apiResponse)
        {
            OnV1OrderbooksSymbolIdCurrentGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1OrderbooksSymbolIdCurrentGet(Exception exception)
        {
            OnErrorV1OrderbooksSymbolIdCurrentGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1OrderbooksSymbolIdDepthCurrentGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1OrderbooksSymbolIdDepthCurrentGet;

        internal void ExecuteOnV1OrderbooksSymbolIdDepthCurrentGet(OrderBookApi.V1OrderbooksSymbolIdDepthCurrentGetApiResponse apiResponse)
        {
            OnV1OrderbooksSymbolIdDepthCurrentGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1OrderbooksSymbolIdDepthCurrentGet(Exception exception)
        {
            OnErrorV1OrderbooksSymbolIdDepthCurrentGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1OrderbooksSymbolIdHistoryGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1OrderbooksSymbolIdHistoryGet;

        internal void ExecuteOnV1OrderbooksSymbolIdHistoryGet(OrderBookApi.V1OrderbooksSymbolIdHistoryGetApiResponse apiResponse)
        {
            OnV1OrderbooksSymbolIdHistoryGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1OrderbooksSymbolIdHistoryGet(Exception exception)
        {
            OnErrorV1OrderbooksSymbolIdHistoryGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1OrderbooksSymbolIdLatestGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1OrderbooksSymbolIdLatestGet;

        internal void ExecuteOnV1OrderbooksSymbolIdLatestGet(OrderBookApi.V1OrderbooksSymbolIdLatestGetApiResponse apiResponse)
        {
            OnV1OrderbooksSymbolIdLatestGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1OrderbooksSymbolIdLatestGet(Exception exception)
        {
            OnErrorV1OrderbooksSymbolIdLatestGet?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class OrderBookApi : IOrderBookApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<OrderBookApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public OrderBookApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="OrderBookApi"/> class.
        /// </summary>
        /// <returns></returns>
        public OrderBookApi(ILogger<OrderBookApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, OrderBookApiEvents orderBookApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<OrderBookApi>();
            HttpClient = httpClient;
            Events = orderBookApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatV1OrderbooksSymbolIdCurrentGet(ref string symbolId, ref Option<int> limitLevels);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="symbolId"></param>
        /// <returns></returns>
        private void ValidateV1OrderbooksSymbolIdCurrentGet(string symbolId)
        {
            if (symbolId == null)
                throw new ArgumentNullException(nameof(symbolId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limitLevels"></param>
        private void AfterV1OrderbooksSymbolIdCurrentGetDefaultImplementation(IV1OrderbooksSymbolIdCurrentGetApiResponse apiResponseLocalVar, string symbolId, Option<int> limitLevels)
        {
            bool suppressDefaultLog = false;
            AfterV1OrderbooksSymbolIdCurrentGet(ref suppressDefaultLog, apiResponseLocalVar, symbolId, limitLevels);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limitLevels"></param>
        partial void AfterV1OrderbooksSymbolIdCurrentGet(ref bool suppressDefaultLog, IV1OrderbooksSymbolIdCurrentGetApiResponse apiResponseLocalVar, string symbolId, Option<int> limitLevels);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limitLevels"></param>
        private void OnErrorV1OrderbooksSymbolIdCurrentGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string symbolId, Option<int> limitLevels)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1OrderbooksSymbolIdCurrentGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, symbolId, limitLevels);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limitLevels"></param>
        partial void OnErrorV1OrderbooksSymbolIdCurrentGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string symbolId, Option<int> limitLevels);

        /// <summary>
        /// Get current order book Retrieves the current order book for the specified symbol.
        /// </summary>
        /// <param name="symbolId">The symbol ID (from the Metadata -&gt; Symbols)</param>
        /// <param name="limitLevels">The maximum number of levels to include in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1OrderbooksSymbolIdCurrentGetApiResponse?> V1OrderbooksSymbolIdCurrentGetOrDefaultAsync(string symbolId, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1OrderbooksSymbolIdCurrentGetAsync(symbolId, limitLevels, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get current order book Retrieves the current order book for the specified symbol.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="symbolId">The symbol ID (from the Metadata -&gt; Symbols)</param>
        /// <param name="limitLevels">The maximum number of levels to include in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1OrderbooksSymbolIdCurrentGetApiResponse> V1OrderbooksSymbolIdCurrentGetAsync(string symbolId, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1OrderbooksSymbolIdCurrentGet(symbolId);

                FormatV1OrderbooksSymbolIdCurrentGet(ref symbolId, ref limitLevels);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/orderbooks/{symbol_id}/current"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/orderbooks/{symbol_id}/current");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsymbol_id%7D", Uri.EscapeDataString(symbolId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limitLevels.IsSet)
                        parseQueryStringLocalVar["limit_levels"] = ClientUtils.ParameterToString(limitLevels.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1OrderbooksSymbolIdCurrentGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1OrderbooksSymbolIdCurrentGetApiResponse>();

                        V1OrderbooksSymbolIdCurrentGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/orderbooks/{symbol_id}/current", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1OrderbooksSymbolIdCurrentGetDefaultImplementation(apiResponseLocalVar, symbolId, limitLevels);

                        Events.ExecuteOnV1OrderbooksSymbolIdCurrentGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1OrderbooksSymbolIdCurrentGetDefaultImplementation(e, "/v1/orderbooks/{symbol_id}/current", uriBuilderLocalVar.Path, symbolId, limitLevels);
                Events.ExecuteOnErrorV1OrderbooksSymbolIdCurrentGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1OrderbooksSymbolIdCurrentGetApiResponse"/>
        /// </summary>
        public partial class V1OrderbooksSymbolIdCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1OrderbooksSymbolIdCurrentGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1OrderbooksSymbolIdCurrentGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1OrderbooksSymbolIdCurrentGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1OrderbooksSymbolIdCurrentGetApiResponse(ILogger<V1OrderbooksSymbolIdCurrentGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model.V1OrderBookBase? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model.V1OrderBookBase>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model.V1OrderBookBase? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1OrderbooksSymbolIdDepthCurrentGet(ref string symbolId, ref Option<int> limitLevels);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="symbolId"></param>
        /// <returns></returns>
        private void ValidateV1OrderbooksSymbolIdDepthCurrentGet(string symbolId)
        {
            if (symbolId == null)
                throw new ArgumentNullException(nameof(symbolId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limitLevels"></param>
        private void AfterV1OrderbooksSymbolIdDepthCurrentGetDefaultImplementation(IV1OrderbooksSymbolIdDepthCurrentGetApiResponse apiResponseLocalVar, string symbolId, Option<int> limitLevels)
        {
            bool suppressDefaultLog = false;
            AfterV1OrderbooksSymbolIdDepthCurrentGet(ref suppressDefaultLog, apiResponseLocalVar, symbolId, limitLevels);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limitLevels"></param>
        partial void AfterV1OrderbooksSymbolIdDepthCurrentGet(ref bool suppressDefaultLog, IV1OrderbooksSymbolIdDepthCurrentGetApiResponse apiResponseLocalVar, string symbolId, Option<int> limitLevels);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limitLevels"></param>
        private void OnErrorV1OrderbooksSymbolIdDepthCurrentGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string symbolId, Option<int> limitLevels)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1OrderbooksSymbolIdDepthCurrentGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, symbolId, limitLevels);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limitLevels"></param>
        partial void OnErrorV1OrderbooksSymbolIdDepthCurrentGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string symbolId, Option<int> limitLevels);

        /// <summary>
        /// Current depth of the order book Retrieves the current depth of the order book for the specified symbol.
        /// </summary>
        /// <param name="symbolId">The symbol ID (from the Metadata -&gt; Symbols)</param>
        /// <param name="limitLevels">The maximum number of levels to include in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdDepthCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1OrderbooksSymbolIdDepthCurrentGetApiResponse?> V1OrderbooksSymbolIdDepthCurrentGetOrDefaultAsync(string symbolId, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1OrderbooksSymbolIdDepthCurrentGetAsync(symbolId, limitLevels, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Current depth of the order book Retrieves the current depth of the order book for the specified symbol.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="symbolId">The symbol ID (from the Metadata -&gt; Symbols)</param>
        /// <param name="limitLevels">The maximum number of levels to include in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdDepthCurrentGetApiResponse"/>&gt;</returns>
        public async Task<IV1OrderbooksSymbolIdDepthCurrentGetApiResponse> V1OrderbooksSymbolIdDepthCurrentGetAsync(string symbolId, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1OrderbooksSymbolIdDepthCurrentGet(symbolId);

                FormatV1OrderbooksSymbolIdDepthCurrentGet(ref symbolId, ref limitLevels);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/orderbooks/{symbol_id}/depth/current"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/orderbooks/{symbol_id}/depth/current");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsymbol_id%7D", Uri.EscapeDataString(symbolId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limitLevels.IsSet)
                        parseQueryStringLocalVar["limit_levels"] = ClientUtils.ParameterToString(limitLevels.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1OrderbooksSymbolIdDepthCurrentGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1OrderbooksSymbolIdDepthCurrentGetApiResponse>();

                        V1OrderbooksSymbolIdDepthCurrentGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/orderbooks/{symbol_id}/depth/current", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1OrderbooksSymbolIdDepthCurrentGetDefaultImplementation(apiResponseLocalVar, symbolId, limitLevels);

                        Events.ExecuteOnV1OrderbooksSymbolIdDepthCurrentGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1OrderbooksSymbolIdDepthCurrentGetDefaultImplementation(e, "/v1/orderbooks/{symbol_id}/depth/current", uriBuilderLocalVar.Path, symbolId, limitLevels);
                Events.ExecuteOnErrorV1OrderbooksSymbolIdDepthCurrentGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1OrderbooksSymbolIdDepthCurrentGetApiResponse"/>
        /// </summary>
        public partial class V1OrderbooksSymbolIdDepthCurrentGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1OrderbooksSymbolIdDepthCurrentGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1OrderbooksSymbolIdDepthCurrentGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1OrderbooksSymbolIdDepthCurrentGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1OrderbooksSymbolIdDepthCurrentGetApiResponse(ILogger<V1OrderbooksSymbolIdDepthCurrentGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model.V1OrderBookDepth? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model.V1OrderBookDepth>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out APIBricks.CoinAPI.MarketDataAPI.REST.V1.Model.V1OrderBookDepth? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1OrderbooksSymbolIdHistoryGet(ref string symbolId, ref Option<string> date, ref Option<string> timeStart, ref Option<string> timeEnd, ref Option<int> limit, ref Option<int> limitLevels);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="symbolId"></param>
        /// <param name="date"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <returns></returns>
        private void ValidateV1OrderbooksSymbolIdHistoryGet(string symbolId, Option<string> date, Option<string> timeStart, Option<string> timeEnd)
        {
            if (symbolId == null)
                throw new ArgumentNullException(nameof(symbolId));

            if (date.IsSet && date.Value == null)
                throw new ArgumentNullException(nameof(date));

            if (timeStart.IsSet && timeStart.Value == null)
                throw new ArgumentNullException(nameof(timeStart));

            if (timeEnd.IsSet && timeEnd.Value == null)
                throw new ArgumentNullException(nameof(timeEnd));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="date"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="limit"></param>
        /// <param name="limitLevels"></param>
        private void AfterV1OrderbooksSymbolIdHistoryGetDefaultImplementation(IV1OrderbooksSymbolIdHistoryGetApiResponse apiResponseLocalVar, string symbolId, Option<string> date, Option<string> timeStart, Option<string> timeEnd, Option<int> limit, Option<int> limitLevels)
        {
            bool suppressDefaultLog = false;
            AfterV1OrderbooksSymbolIdHistoryGet(ref suppressDefaultLog, apiResponseLocalVar, symbolId, date, timeStart, timeEnd, limit, limitLevels);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="date"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="limit"></param>
        /// <param name="limitLevels"></param>
        partial void AfterV1OrderbooksSymbolIdHistoryGet(ref bool suppressDefaultLog, IV1OrderbooksSymbolIdHistoryGetApiResponse apiResponseLocalVar, string symbolId, Option<string> date, Option<string> timeStart, Option<string> timeEnd, Option<int> limit, Option<int> limitLevels);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="date"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="limit"></param>
        /// <param name="limitLevels"></param>
        private void OnErrorV1OrderbooksSymbolIdHistoryGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string symbolId, Option<string> date, Option<string> timeStart, Option<string> timeEnd, Option<int> limit, Option<int> limitLevels)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1OrderbooksSymbolIdHistoryGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, symbolId, date, timeStart, timeEnd, limit, limitLevels);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="date"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="limit"></param>
        /// <param name="limitLevels"></param>
        partial void OnErrorV1OrderbooksSymbolIdHistoryGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string symbolId, Option<string> date, Option<string> timeStart, Option<string> timeEnd, Option<int> limit, Option<int> limitLevels);

        /// <summary>
        /// Historical data Get historical order book snapshots for a specific symbol within time range, returned in time ascending order.              :::info The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels. :::  :::warning The &#39;time_start&#39; and &#39;time_end&#39; parameters must be from the same day as this endpoint provides intraday data only for specific day. Please use the &#39;date&#39; parameter instead for querying data for a specific day without filter. :::
        /// </summary>
        /// <param name="symbolId">Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)</param>
        /// <param name="date">Date in ISO 8601, returned data is for the whole given day (preferred method, required if &#39;time_start&#39; is not provided) (optional)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (deprecated, use &#39;date&#39; instead) (optional)</param>
        /// <param name="timeEnd">Timeseries ending time in ISO 8601 (deprecated, use &#39;date&#39; instead) (optional)</param>
        /// <param name="limit">Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="limitLevels">Maximum amount of levels from each side of the book to include in response (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1OrderbooksSymbolIdHistoryGetApiResponse?> V1OrderbooksSymbolIdHistoryGetOrDefaultAsync(string symbolId, Option<string> date = default, Option<string> timeStart = default, Option<string> timeEnd = default, Option<int> limit = default, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1OrderbooksSymbolIdHistoryGetAsync(symbolId, date, timeStart, timeEnd, limit, limitLevels, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Historical data Get historical order book snapshots for a specific symbol within time range, returned in time ascending order.              :::info The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels. :::  :::warning The &#39;time_start&#39; and &#39;time_end&#39; parameters must be from the same day as this endpoint provides intraday data only for specific day. Please use the &#39;date&#39; parameter instead for querying data for a specific day without filter. :::
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="symbolId">Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)</param>
        /// <param name="date">Date in ISO 8601, returned data is for the whole given day (preferred method, required if &#39;time_start&#39; is not provided) (optional)</param>
        /// <param name="timeStart">Starting time in ISO 8601 (deprecated, use &#39;date&#39; instead) (optional)</param>
        /// <param name="timeEnd">Timeseries ending time in ISO 8601 (deprecated, use &#39;date&#39; instead) (optional)</param>
        /// <param name="limit">Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="limitLevels">Maximum amount of levels from each side of the book to include in response (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1OrderbooksSymbolIdHistoryGetApiResponse> V1OrderbooksSymbolIdHistoryGetAsync(string symbolId, Option<string> date = default, Option<string> timeStart = default, Option<string> timeEnd = default, Option<int> limit = default, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1OrderbooksSymbolIdHistoryGet(symbolId, date, timeStart, timeEnd);

                FormatV1OrderbooksSymbolIdHistoryGet(ref symbolId, ref date, ref timeStart, ref timeEnd, ref limit, ref limitLevels);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/orderbooks/{symbol_id}/history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/orderbooks/{symbol_id}/history");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsymbol_id%7D", Uri.EscapeDataString(symbolId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (date.IsSet)
                        parseQueryStringLocalVar["date"] = ClientUtils.ParameterToString(date.Value);

                    if (timeStart.IsSet)
                        parseQueryStringLocalVar["time_start"] = ClientUtils.ParameterToString(timeStart.Value);

                    if (timeEnd.IsSet)
                        parseQueryStringLocalVar["time_end"] = ClientUtils.ParameterToString(timeEnd.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (limitLevels.IsSet)
                        parseQueryStringLocalVar["limit_levels"] = ClientUtils.ParameterToString(limitLevels.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1OrderbooksSymbolIdHistoryGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1OrderbooksSymbolIdHistoryGetApiResponse>();

                        V1OrderbooksSymbolIdHistoryGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/orderbooks/{symbol_id}/history", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1OrderbooksSymbolIdHistoryGetDefaultImplementation(apiResponseLocalVar, symbolId, date, timeStart, timeEnd, limit, limitLevels);

                        Events.ExecuteOnV1OrderbooksSymbolIdHistoryGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1OrderbooksSymbolIdHistoryGetDefaultImplementation(e, "/v1/orderbooks/{symbol_id}/history", uriBuilderLocalVar.Path, symbolId, date, timeStart, timeEnd, limit, limitLevels);
                Events.ExecuteOnErrorV1OrderbooksSymbolIdHistoryGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1OrderbooksSymbolIdHistoryGetApiResponse"/>
        /// </summary>
        public partial class V1OrderbooksSymbolIdHistoryGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1OrderbooksSymbolIdHistoryGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1OrderbooksSymbolIdHistoryGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1OrderbooksSymbolIdHistoryGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1OrderbooksSymbolIdHistoryGetApiResponse(ILogger<V1OrderbooksSymbolIdHistoryGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1OrderBook>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1OrderBook>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1OrderBook>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1OrderbooksSymbolIdLatestGet(ref string symbolId, ref Option<int> limit, ref Option<int> limitLevels);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="symbolId"></param>
        /// <returns></returns>
        private void ValidateV1OrderbooksSymbolIdLatestGet(string symbolId)
        {
            if (symbolId == null)
                throw new ArgumentNullException(nameof(symbolId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limit"></param>
        /// <param name="limitLevels"></param>
        private void AfterV1OrderbooksSymbolIdLatestGetDefaultImplementation(IV1OrderbooksSymbolIdLatestGetApiResponse apiResponseLocalVar, string symbolId, Option<int> limit, Option<int> limitLevels)
        {
            bool suppressDefaultLog = false;
            AfterV1OrderbooksSymbolIdLatestGet(ref suppressDefaultLog, apiResponseLocalVar, symbolId, limit, limitLevels);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limit"></param>
        /// <param name="limitLevels"></param>
        partial void AfterV1OrderbooksSymbolIdLatestGet(ref bool suppressDefaultLog, IV1OrderbooksSymbolIdLatestGetApiResponse apiResponseLocalVar, string symbolId, Option<int> limit, Option<int> limitLevels);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limit"></param>
        /// <param name="limitLevels"></param>
        private void OnErrorV1OrderbooksSymbolIdLatestGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string symbolId, Option<int> limit, Option<int> limitLevels)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1OrderbooksSymbolIdLatestGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, symbolId, limit, limitLevels);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="symbolId"></param>
        /// <param name="limit"></param>
        /// <param name="limitLevels"></param>
        partial void OnErrorV1OrderbooksSymbolIdLatestGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string symbolId, Option<int> limit, Option<int> limitLevels);

        /// <summary>
        /// Latest data Get latest order book snapshots for a specific symbol, returned in time descending order.              :::info The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels. :::
        /// </summary>
        /// <param name="symbolId">Symbol identifier of requested timeseries (from the Metadata -&gt; Symbols)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="limitLevels">Maximum amount of levels from each side of the book to include in response (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdLatestGetApiResponse"/>&gt;</returns>
        public async Task<IV1OrderbooksSymbolIdLatestGetApiResponse?> V1OrderbooksSymbolIdLatestGetOrDefaultAsync(string symbolId, Option<int> limit = default, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1OrderbooksSymbolIdLatestGetAsync(symbolId, limit, limitLevels, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Latest data Get latest order book snapshots for a specific symbol, returned in time descending order.              :::info The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels. :::
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="symbolId">Symbol identifier of requested timeseries (from the Metadata -&gt; Symbols)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="limitLevels">Maximum amount of levels from each side of the book to include in response (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1OrderbooksSymbolIdLatestGetApiResponse"/>&gt;</returns>
        public async Task<IV1OrderbooksSymbolIdLatestGetApiResponse> V1OrderbooksSymbolIdLatestGetAsync(string symbolId, Option<int> limit = default, Option<int> limitLevels = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1OrderbooksSymbolIdLatestGet(symbolId);

                FormatV1OrderbooksSymbolIdLatestGet(ref symbolId, ref limit, ref limitLevels);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/orderbooks/{symbol_id}/latest"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/orderbooks/{symbol_id}/latest");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bsymbol_id%7D", Uri.EscapeDataString(symbolId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (limitLevels.IsSet)
                        parseQueryStringLocalVar["limit_levels"] = ClientUtils.ParameterToString(limitLevels.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1OrderbooksSymbolIdLatestGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1OrderbooksSymbolIdLatestGetApiResponse>();

                        V1OrderbooksSymbolIdLatestGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/orderbooks/{symbol_id}/latest", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1OrderbooksSymbolIdLatestGetDefaultImplementation(apiResponseLocalVar, symbolId, limit, limitLevels);

                        Events.ExecuteOnV1OrderbooksSymbolIdLatestGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1OrderbooksSymbolIdLatestGetDefaultImplementation(e, "/v1/orderbooks/{symbol_id}/latest", uriBuilderLocalVar.Path, symbolId, limit, limitLevels);
                Events.ExecuteOnErrorV1OrderbooksSymbolIdLatestGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1OrderbooksSymbolIdLatestGetApiResponse"/>
        /// </summary>
        public partial class V1OrderbooksSymbolIdLatestGetApiResponse : APIBricks.CoinAPI.MarketDataAPI.REST.V1.Client.ApiResponse, IV1OrderbooksSymbolIdLatestGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1OrderbooksSymbolIdLatestGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1OrderbooksSymbolIdLatestGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1OrderbooksSymbolIdLatestGetApiResponse(ILogger<V1OrderbooksSymbolIdLatestGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1OrderBook>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1OrderBook>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1OrderBook>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
