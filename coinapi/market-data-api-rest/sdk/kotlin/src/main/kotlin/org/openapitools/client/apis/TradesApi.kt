/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.V1Trade

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class TradesApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://rest.coinapi.io")
        }
    }

    /**
     * GET /v1/trades/latest
     * Latest data
     * Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.
     * @param filterSymbolId Comma or semicolon delimited parts of symbol identifier used to filter response. (optional) (optional)
     * @param includeId Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers. (optional, default to false)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<V1Trade>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1TradesLatestGet(filterSymbolId: kotlin.String? = null, includeId: kotlin.Boolean? = false, limit: kotlin.Int? = 100) : kotlin.collections.List<V1Trade> {
        val localVarResponse = v1TradesLatestGetWithHttpInfo(filterSymbolId = filterSymbolId, includeId = includeId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1Trade>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/trades/latest
     * Latest data
     * Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.
     * @param filterSymbolId Comma or semicolon delimited parts of symbol identifier used to filter response. (optional) (optional)
     * @param includeId Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers. (optional, default to false)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<V1Trade>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1TradesLatestGetWithHttpInfo(filterSymbolId: kotlin.String?, includeId: kotlin.Boolean?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<V1Trade>?> {
        val localVariableConfig = v1TradesLatestGetRequestConfig(filterSymbolId = filterSymbolId, includeId = includeId, limit = limit)

        return request<Unit, kotlin.collections.List<V1Trade>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1TradesLatestGet
     *
     * @param filterSymbolId Comma or semicolon delimited parts of symbol identifier used to filter response. (optional) (optional)
     * @param includeId Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers. (optional, default to false)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v1TradesLatestGetRequestConfig(filterSymbolId: kotlin.String?, includeId: kotlin.Boolean?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterSymbolId != null) {
                    put("filter_symbol_id", listOf(filterSymbolId.toString()))
                }
                if (includeId != null) {
                    put("include_id", listOf(includeId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/trades/latest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/trades/{symbol_id}/history
     * Historical data
     * Get history transactions from specific symbol, returned in time ascending order.  :::warning The &#39;time_start&#39; and &#39;time_end&#39; parameters must be from the same day as this endpoint provides intraday data only for specific day. Please use the &#39;date&#39; parameter instead for querying data for a specific day without filter. :::
     * @param symbolId Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)
     * @param date Date in ISO 8601, returned data is for the whole given day (required if &#39;time_start&#39; is not provided) (optional)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Timeseries ending time in ISO 8601 (optional)
     * @param limit Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param includeId Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers. (optional, default to false)
     * @return kotlin.collections.List<V1Trade>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1TradesSymbolIdHistoryGet(symbolId: kotlin.String, date: kotlin.String? = null, timeStart: kotlin.String? = null, timeEnd: kotlin.String? = null, limit: kotlin.Int? = 100, includeId: kotlin.Boolean? = false) : kotlin.collections.List<V1Trade> {
        val localVarResponse = v1TradesSymbolIdHistoryGetWithHttpInfo(symbolId = symbolId, date = date, timeStart = timeStart, timeEnd = timeEnd, limit = limit, includeId = includeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1Trade>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/trades/{symbol_id}/history
     * Historical data
     * Get history transactions from specific symbol, returned in time ascending order.  :::warning The &#39;time_start&#39; and &#39;time_end&#39; parameters must be from the same day as this endpoint provides intraday data only for specific day. Please use the &#39;date&#39; parameter instead for querying data for a specific day without filter. :::
     * @param symbolId Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)
     * @param date Date in ISO 8601, returned data is for the whole given day (required if &#39;time_start&#39; is not provided) (optional)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Timeseries ending time in ISO 8601 (optional)
     * @param limit Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param includeId Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers. (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<V1Trade>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1TradesSymbolIdHistoryGetWithHttpInfo(symbolId: kotlin.String, date: kotlin.String?, timeStart: kotlin.String?, timeEnd: kotlin.String?, limit: kotlin.Int?, includeId: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<V1Trade>?> {
        val localVariableConfig = v1TradesSymbolIdHistoryGetRequestConfig(symbolId = symbolId, date = date, timeStart = timeStart, timeEnd = timeEnd, limit = limit, includeId = includeId)

        return request<Unit, kotlin.collections.List<V1Trade>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1TradesSymbolIdHistoryGet
     *
     * @param symbolId Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)
     * @param date Date in ISO 8601, returned data is for the whole given day (required if &#39;time_start&#39; is not provided) (optional)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Timeseries ending time in ISO 8601 (optional)
     * @param limit Amount of items to return (optional, minimum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param includeId Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers. (optional, default to false)
     * @return RequestConfig
     */
    fun v1TradesSymbolIdHistoryGetRequestConfig(symbolId: kotlin.String, date: kotlin.String?, timeStart: kotlin.String?, timeEnd: kotlin.String?, limit: kotlin.Int?, includeId: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (timeStart != null) {
                    put("time_start", listOf(timeStart.toString()))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(timeEnd.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (includeId != null) {
                    put("include_id", listOf(includeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/trades/{symbol_id}/history".replace("{"+"symbol_id"+"}", encodeURIComponent(symbolId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/trades/{symbol_id}/latest
     * Latest data by symbol_id
     * Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.
     * @param symbolId Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param includeId Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers. (optional, default to false)
     * @return kotlin.collections.List<V1Trade>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1TradesSymbolIdLatestGet(symbolId: kotlin.String, limit: kotlin.Int? = 100, includeId: kotlin.Boolean? = false) : kotlin.collections.List<V1Trade> {
        val localVarResponse = v1TradesSymbolIdLatestGetWithHttpInfo(symbolId = symbolId, limit = limit, includeId = includeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1Trade>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/trades/{symbol_id}/latest
     * Latest data by symbol_id
     * Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.
     * @param symbolId Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param includeId Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers. (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<V1Trade>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1TradesSymbolIdLatestGetWithHttpInfo(symbolId: kotlin.String, limit: kotlin.Int?, includeId: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<V1Trade>?> {
        val localVariableConfig = v1TradesSymbolIdLatestGetRequestConfig(symbolId = symbolId, limit = limit, includeId = includeId)

        return request<Unit, kotlin.collections.List<V1Trade>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1TradesSymbolIdLatestGet
     *
     * @param symbolId Symbol identifier for requested timeseries (from the Metadata -&gt; Symbols)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param includeId Information that additional exchange trade identifier should be included in the &#x60;id_trade&#x60; parameter of the trade if exchange providing identifiers. (optional, default to false)
     * @return RequestConfig
     */
    fun v1TradesSymbolIdLatestGetRequestConfig(symbolId: kotlin.String, limit: kotlin.Int?, includeId: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (includeId != null) {
                    put("include_id", listOf(includeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/trades/{symbol_id}/latest".replace("{"+"symbol_id"+"}", encodeURIComponent(symbolId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
