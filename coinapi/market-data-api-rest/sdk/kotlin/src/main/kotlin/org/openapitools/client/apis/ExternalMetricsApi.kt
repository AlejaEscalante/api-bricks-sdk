/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.V1Chain
import org.openapitools.client.models.V1ExternalAsset
import org.openapitools.client.models.V1ExternalExchange
import org.openapitools.client.models.V1MetricInfo

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ExternalMetricsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://rest.coinapi.io")
        }
    }

    /**
     * GET /v1/externalmetrics/asset/history
     * Historical metrics for the asset from external sources
     * Get asset metrics history from external data providers. Data is typically aggregated daily.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60; - from supported assets list)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsAssetHistoryGet(metricId: kotlin.String, assetId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<kotlin.Any> {
        val localVarResponse = v1ExternalmetricsAssetHistoryGetWithHttpInfo(metricId = metricId, assetId = assetId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/asset/history
     * Historical metrics for the asset from external sources
     * Get asset metrics history from external data providers. Data is typically aggregated daily.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60; - from supported assets list)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsAssetHistoryGetWithHttpInfo(metricId: kotlin.String, assetId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Any>?> {
        val localVariableConfig = v1ExternalmetricsAssetHistoryGetRequestConfig(metricId = metricId, assetId = assetId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsAssetHistoryGet
     *
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60; - from supported assets list)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v1ExternalmetricsAssetHistoryGetRequestConfig(metricId: kotlin.String, assetId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("asset_id", listOf(assetId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/asset/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/externalmetrics/asset/listing
     * Listing of metrics available for specific asset
     * Get all metrics that are actually available for the specified asset from external providers.
     * @param assetId Asset identifier (e.g., USDC, USDT)
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsAssetListingGet(assetId: kotlin.String) : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = v1ExternalmetricsAssetListingGetWithHttpInfo(assetId = assetId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/asset/listing
     * Listing of metrics available for specific asset
     * Get all metrics that are actually available for the specified asset from external providers.
     * @param assetId Asset identifier (e.g., USDC, USDT)
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsAssetListingGetWithHttpInfo(assetId: kotlin.String) : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = v1ExternalmetricsAssetListingGetRequestConfig(assetId = assetId)

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsAssetListingGet
     *
     * @param assetId Asset identifier (e.g., USDC, USDT)
     * @return RequestConfig
     */
    fun v1ExternalmetricsAssetListingGetRequestConfig(assetId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("asset_id", listOf(assetId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/asset/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/externalmetrics/assets
     * Listing of all supported external assets
     * Get all assets (primarily stablecoins) supported by external data providers.
     * @return kotlin.collections.List<V1ExternalAsset>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsAssetsGet() : kotlin.collections.List<V1ExternalAsset> {
        val localVarResponse = v1ExternalmetricsAssetsGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1ExternalAsset>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/assets
     * Listing of all supported external assets
     * Get all assets (primarily stablecoins) supported by external data providers.
     * @return ApiResponse<kotlin.collections.List<V1ExternalAsset>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsAssetsGetWithHttpInfo() : ApiResponse<kotlin.collections.List<V1ExternalAsset>?> {
        val localVariableConfig = v1ExternalmetricsAssetsGetRequestConfig()

        return request<Unit, kotlin.collections.List<V1ExternalAsset>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsAssetsGet
     *
     * @return RequestConfig
     */
    fun v1ExternalmetricsAssetsGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/externalmetrics/chain/history
     * Historical metrics for the chain from external sources
     * Get chain metrics history from external data providers. Data is typically aggregated daily.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60; - from supported chains list)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsChainHistoryGet(metricId: kotlin.String, chainId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<kotlin.Any> {
        val localVarResponse = v1ExternalmetricsChainHistoryGetWithHttpInfo(metricId = metricId, chainId = chainId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/chain/history
     * Historical metrics for the chain from external sources
     * Get chain metrics history from external data providers. Data is typically aggregated daily.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60; - from supported chains list)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsChainHistoryGetWithHttpInfo(metricId: kotlin.String, chainId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Any>?> {
        val localVariableConfig = v1ExternalmetricsChainHistoryGetRequestConfig(metricId = metricId, chainId = chainId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsChainHistoryGet
     *
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; - internal metric key)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60; - from supported chains list)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v1ExternalmetricsChainHistoryGetRequestConfig(metricId: kotlin.String, chainId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("chain_id", listOf(chainId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/chain/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/externalmetrics/chain/listing
     * Listing of metrics available for specific chain
     * Get all metrics that are actually available for the specified blockchain chain from external providers.
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsChainListingGet(chainId: kotlin.String) : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = v1ExternalmetricsChainListingGetWithHttpInfo(chainId = chainId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/chain/listing
     * Listing of metrics available for specific chain
     * Get all metrics that are actually available for the specified blockchain chain from external providers.
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsChainListingGetWithHttpInfo(chainId: kotlin.String) : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = v1ExternalmetricsChainListingGetRequestConfig(chainId = chainId)

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsChainListingGet
     *
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     * @return RequestConfig
     */
    fun v1ExternalmetricsChainListingGetRequestConfig(chainId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("chain_id", listOf(chainId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/chain/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/externalmetrics/chains
     * Listing of all supported external chains
     * Get all blockchain chains supported by external data providers.
     * @return kotlin.collections.List<V1Chain>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsChainsGet() : kotlin.collections.List<V1Chain> {
        val localVarResponse = v1ExternalmetricsChainsGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1Chain>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/chains
     * Listing of all supported external chains
     * Get all blockchain chains supported by external data providers.
     * @return ApiResponse<kotlin.collections.List<V1Chain>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsChainsGetWithHttpInfo() : ApiResponse<kotlin.collections.List<V1Chain>?> {
        val localVariableConfig = v1ExternalmetricsChainsGetRequestConfig()

        return request<Unit, kotlin.collections.List<V1Chain>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsChainsGet
     *
     * @return RequestConfig
     */
    fun v1ExternalmetricsChainsGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/chains",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/externalmetrics/exchange/history
     * Historical metrics for the exchange from both external and internal sources
     * Get exchange metrics history from external data providers or internal sources based on metric type.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; for external, or generic metric IDs)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsExchangeHistoryGet(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<kotlin.Any> {
        val localVarResponse = v1ExternalmetricsExchangeHistoryGetWithHttpInfo(metricId = metricId, exchangeId = exchangeId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/exchange/history
     * Historical metrics for the exchange from both external and internal sources
     * Get exchange metrics history from external data providers or internal sources based on metric type.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; for external, or generic metric IDs)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsExchangeHistoryGetWithHttpInfo(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Any>?> {
        val localVariableConfig = v1ExternalmetricsExchangeHistoryGetRequestConfig(metricId = metricId, exchangeId = exchangeId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsExchangeHistoryGet
     *
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60; for external, or generic metric IDs)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v1ExternalmetricsExchangeHistoryGetRequestConfig(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("exchange_id", listOf(exchangeId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/exchange/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/externalmetrics/exchange/listing
     * Listing of metrics available for specific exchange (both external and generic)
     * Get all metrics that are actually available for the specified exchange from both external providers and internal sources.
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsExchangeListingGet(exchangeId: kotlin.String) : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = v1ExternalmetricsExchangeListingGetWithHttpInfo(exchangeId = exchangeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/exchange/listing
     * Listing of metrics available for specific exchange (both external and generic)
     * Get all metrics that are actually available for the specified exchange from both external providers and internal sources.
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsExchangeListingGetWithHttpInfo(exchangeId: kotlin.String) : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = v1ExternalmetricsExchangeListingGetRequestConfig(exchangeId = exchangeId)

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsExchangeListingGet
     *
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     * @return RequestConfig
     */
    fun v1ExternalmetricsExchangeListingGetRequestConfig(exchangeId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("exchange_id", listOf(exchangeId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/exchange/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/externalmetrics/exchanges
     * Listing of all supported external exchanges
     * Get all exchanges that have mapping to external data providers for metrics that actually have sources.  Only returns exchanges that are properly mapped to external protocols for metrics with defined sources.
     * @return kotlin.collections.List<V1ExternalExchange>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsExchangesGet() : kotlin.collections.List<V1ExternalExchange> {
        val localVarResponse = v1ExternalmetricsExchangesGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1ExternalExchange>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/exchanges
     * Listing of all supported external exchanges
     * Get all exchanges that have mapping to external data providers for metrics that actually have sources.  Only returns exchanges that are properly mapped to external protocols for metrics with defined sources.
     * @return ApiResponse<kotlin.collections.List<V1ExternalExchange>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsExchangesGetWithHttpInfo() : ApiResponse<kotlin.collections.List<V1ExternalExchange>?> {
        val localVariableConfig = v1ExternalmetricsExchangesGetRequestConfig()

        return request<Unit, kotlin.collections.List<V1ExternalExchange>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsExchangesGet
     *
     * @return RequestConfig
     */
    fun v1ExternalmetricsExchangesGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/exchanges",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/externalmetrics/listing
     * Listing of all supported metrics (both external and generic)
     * Get all metrics available from external data providers and internal generic metrics.  External metrics have detailed descriptions, while generic metrics are marked as such.
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1ExternalmetricsListingGet() : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = v1ExternalmetricsListingGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/externalmetrics/listing
     * Listing of all supported metrics (both external and generic)
     * Get all metrics available from external data providers and internal generic metrics.  External metrics have detailed descriptions, while generic metrics are marked as such.
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1ExternalmetricsListingGetWithHttpInfo() : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = v1ExternalmetricsListingGetRequestConfig()

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1ExternalmetricsListingGet
     *
     * @return RequestConfig
     */
    fun v1ExternalmetricsListingGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/externalmetrics/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
