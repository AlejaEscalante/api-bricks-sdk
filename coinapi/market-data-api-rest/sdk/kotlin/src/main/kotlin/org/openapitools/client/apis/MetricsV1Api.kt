/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.V1GeneralData
import org.openapitools.client.models.V1ListingItem
import org.openapitools.client.models.V1Metric
import org.openapitools.client.models.V1MetricData

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class MetricsV1Api(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://rest.coinapi.io")
        }
    }

    /**
     * GET /v1/metrics/asset/current
     * Current metrics for given asset
     * Get current asset metrics.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param assetIdExternal Exchange asset identifier (optional)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @return kotlin.collections.List<V1GeneralData>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsAssetCurrentGet(metricId: kotlin.String? = null, assetId: kotlin.String? = null, assetIdExternal: kotlin.String? = null, exchangeId: kotlin.String? = null) : kotlin.collections.List<V1GeneralData> {
        val localVarResponse = v1MetricsAssetCurrentGetWithHttpInfo(metricId = metricId, assetId = assetId, assetIdExternal = assetIdExternal, exchangeId = exchangeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1GeneralData>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/asset/current
     * Current metrics for given asset
     * Get current asset metrics.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param assetIdExternal Exchange asset identifier (optional)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @return ApiResponse<kotlin.collections.List<V1GeneralData>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsAssetCurrentGetWithHttpInfo(metricId: kotlin.String?, assetId: kotlin.String?, assetIdExternal: kotlin.String?, exchangeId: kotlin.String?) : ApiResponse<kotlin.collections.List<V1GeneralData>?> {
        val localVariableConfig = v1MetricsAssetCurrentGetRequestConfig(metricId = metricId, assetId = assetId, assetIdExternal = assetIdExternal, exchangeId = exchangeId)

        return request<Unit, kotlin.collections.List<V1GeneralData>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsAssetCurrentGet
     *
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param assetIdExternal Exchange asset identifier (optional)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @return RequestConfig
     */
    fun v1MetricsAssetCurrentGetRequestConfig(metricId: kotlin.String?, assetId: kotlin.String?, assetIdExternal: kotlin.String?, exchangeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (metricId != null) {
                    put("metric_id", listOf(metricId.toString()))
                }
                if (assetId != null) {
                    put("asset_id", listOf(assetId.toString()))
                }
                if (assetIdExternal != null) {
                    put("asset_id_external", listOf(assetIdExternal.toString()))
                }
                if (exchangeId != null) {
                    put("exchange_id", listOf(exchangeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/asset/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/metrics/asset/history
     * Historical metrics for asset
     * Get asset metrics history.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param assetIdExternal Exchange asset identifier (optional)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<V1MetricData>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsAssetHistoryGet(metricId: kotlin.String, exchangeId: kotlin.String, assetId: kotlin.String? = null, assetIdExternal: kotlin.String? = null, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<V1MetricData> {
        val localVarResponse = v1MetricsAssetHistoryGetWithHttpInfo(metricId = metricId, exchangeId = exchangeId, assetId = assetId, assetIdExternal = assetIdExternal, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricData>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/asset/history
     * Historical metrics for asset
     * Get asset metrics history.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param assetIdExternal Exchange asset identifier (optional)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<V1MetricData>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsAssetHistoryGetWithHttpInfo(metricId: kotlin.String, exchangeId: kotlin.String, assetId: kotlin.String?, assetIdExternal: kotlin.String?, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<V1MetricData>?> {
        val localVariableConfig = v1MetricsAssetHistoryGetRequestConfig(metricId = metricId, exchangeId = exchangeId, assetId = assetId, assetIdExternal = assetIdExternal, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<V1MetricData>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsAssetHistoryGet
     *
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param assetIdExternal Exchange asset identifier (optional)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v1MetricsAssetHistoryGetRequestConfig(metricId: kotlin.String, exchangeId: kotlin.String, assetId: kotlin.String?, assetIdExternal: kotlin.String?, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                if (assetId != null) {
                    put("asset_id", listOf(assetId.toString()))
                }
                if (assetIdExternal != null) {
                    put("asset_id_external", listOf(assetIdExternal.toString()))
                }
                put("exchange_id", listOf(exchangeId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/asset/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/metrics/asset/listing
     * Listing of all supported metrics for asset
     * Get data metrics for asset.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param chainId Chain identifier (optional)
     * @param networkId Network identifier (optional)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param assetIdExternal The asset external identifier (optional)
     * @return kotlin.collections.List<V1ListingItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsAssetListingGet(metricId: kotlin.String? = null, exchangeId: kotlin.String? = null, chainId: kotlin.String? = null, networkId: kotlin.String? = null, assetId: kotlin.String? = null, assetIdExternal: kotlin.String? = null) : kotlin.collections.List<V1ListingItem> {
        val localVarResponse = v1MetricsAssetListingGetWithHttpInfo(metricId = metricId, exchangeId = exchangeId, chainId = chainId, networkId = networkId, assetId = assetId, assetIdExternal = assetIdExternal)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1ListingItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/asset/listing
     * Listing of all supported metrics for asset
     * Get data metrics for asset.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param chainId Chain identifier (optional)
     * @param networkId Network identifier (optional)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param assetIdExternal The asset external identifier (optional)
     * @return ApiResponse<kotlin.collections.List<V1ListingItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsAssetListingGetWithHttpInfo(metricId: kotlin.String?, exchangeId: kotlin.String?, chainId: kotlin.String?, networkId: kotlin.String?, assetId: kotlin.String?, assetIdExternal: kotlin.String?) : ApiResponse<kotlin.collections.List<V1ListingItem>?> {
        val localVariableConfig = v1MetricsAssetListingGetRequestConfig(metricId = metricId, exchangeId = exchangeId, chainId = chainId, networkId = networkId, assetId = assetId, assetIdExternal = assetIdExternal)

        return request<Unit, kotlin.collections.List<V1ListingItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsAssetListingGet
     *
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param chainId Chain identifier (optional)
     * @param networkId Network identifier (optional)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param assetIdExternal The asset external identifier (optional)
     * @return RequestConfig
     */
    fun v1MetricsAssetListingGetRequestConfig(metricId: kotlin.String?, exchangeId: kotlin.String?, chainId: kotlin.String?, networkId: kotlin.String?, assetId: kotlin.String?, assetIdExternal: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (metricId != null) {
                    put("metric_id", listOf(metricId.toString()))
                }
                if (exchangeId != null) {
                    put("exchange_id", listOf(exchangeId.toString()))
                }
                if (chainId != null) {
                    put("chain_id", listOf(chainId.toString()))
                }
                if (networkId != null) {
                    put("network_id", listOf(networkId.toString()))
                }
                if (assetId != null) {
                    put("asset_id", listOf(assetId.toString()))
                }
                if (assetIdExternal != null) {
                    put("asset_id_external", listOf(assetIdExternal.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/asset/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/metrics/exchange/current
     * Current metrics for given exchange
     * Get current exchange metrics values.
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @return kotlin.collections.List<V1GeneralData>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsExchangeCurrentGet(exchangeId: kotlin.String, metricId: kotlin.String? = null) : kotlin.collections.List<V1GeneralData> {
        val localVarResponse = v1MetricsExchangeCurrentGetWithHttpInfo(exchangeId = exchangeId, metricId = metricId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1GeneralData>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/exchange/current
     * Current metrics for given exchange
     * Get current exchange metrics values.
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @return ApiResponse<kotlin.collections.List<V1GeneralData>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsExchangeCurrentGetWithHttpInfo(exchangeId: kotlin.String, metricId: kotlin.String?) : ApiResponse<kotlin.collections.List<V1GeneralData>?> {
        val localVariableConfig = v1MetricsExchangeCurrentGetRequestConfig(exchangeId = exchangeId, metricId = metricId)

        return request<Unit, kotlin.collections.List<V1GeneralData>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsExchangeCurrentGet
     *
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @return RequestConfig
     */
    fun v1MetricsExchangeCurrentGetRequestConfig(exchangeId: kotlin.String, metricId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (metricId != null) {
                    put("metric_id", listOf(metricId.toString()))
                }
                put("exchange_id", listOf(exchangeId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/exchange/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/metrics/exchange/history
     * Historical metrics for the exchange
     * Get exchange metrics history.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<V1MetricData>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsExchangeHistoryGet(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<V1MetricData> {
        val localVarResponse = v1MetricsExchangeHistoryGetWithHttpInfo(metricId = metricId, exchangeId = exchangeId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricData>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/exchange/history
     * Historical metrics for the exchange
     * Get exchange metrics history.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<V1MetricData>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsExchangeHistoryGetWithHttpInfo(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<V1MetricData>?> {
        val localVariableConfig = v1MetricsExchangeHistoryGetRequestConfig(metricId = metricId, exchangeId = exchangeId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<V1MetricData>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsExchangeHistoryGet
     *
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v1MetricsExchangeHistoryGetRequestConfig(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("exchange_id", listOf(exchangeId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/exchange/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/metrics/exchange/listing
     * Listing of all supported exchange metrics
     * Get data metrics for exchange.
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @return kotlin.collections.List<V1ListingItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsExchangeListingGet(exchangeId: kotlin.String, metricId: kotlin.String? = null) : kotlin.collections.List<V1ListingItem> {
        val localVarResponse = v1MetricsExchangeListingGetWithHttpInfo(exchangeId = exchangeId, metricId = metricId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1ListingItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/exchange/listing
     * Listing of all supported exchange metrics
     * Get data metrics for exchange.
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @return ApiResponse<kotlin.collections.List<V1ListingItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsExchangeListingGetWithHttpInfo(exchangeId: kotlin.String, metricId: kotlin.String?) : ApiResponse<kotlin.collections.List<V1ListingItem>?> {
        val localVariableConfig = v1MetricsExchangeListingGetRequestConfig(exchangeId = exchangeId, metricId = metricId)

        return request<Unit, kotlin.collections.List<V1ListingItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsExchangeListingGet
     *
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @return RequestConfig
     */
    fun v1MetricsExchangeListingGetRequestConfig(exchangeId: kotlin.String, metricId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (metricId != null) {
                    put("metric_id", listOf(metricId.toString()))
                }
                put("exchange_id", listOf(exchangeId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/exchange/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/metrics/listing
     * Listing of all supported metrics by CoinAPI
     * Get all data metrics.
     * @return kotlin.collections.List<V1Metric>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsListingGet() : kotlin.collections.List<V1Metric> {
        val localVarResponse = v1MetricsListingGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1Metric>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/listing
     * Listing of all supported metrics by CoinAPI
     * Get all data metrics.
     * @return ApiResponse<kotlin.collections.List<V1Metric>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsListingGetWithHttpInfo() : ApiResponse<kotlin.collections.List<V1Metric>?> {
        val localVariableConfig = v1MetricsListingGetRequestConfig()

        return request<Unit, kotlin.collections.List<V1Metric>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsListingGet
     *
     * @return RequestConfig
     */
    fun v1MetricsListingGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/metrics/symbol/current
     * Current metrics for given symbol
     * Get current symbol metrics.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param exchangeId Exchange id (from the Metadata -&gt; Exchanges) (optional)
     * @return kotlin.collections.List<V1GeneralData>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsSymbolCurrentGet(metricId: kotlin.String? = null, symbolId: kotlin.String? = null, exchangeId: kotlin.String? = null) : kotlin.collections.List<V1GeneralData> {
        val localVarResponse = v1MetricsSymbolCurrentGetWithHttpInfo(metricId = metricId, symbolId = symbolId, exchangeId = exchangeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1GeneralData>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/symbol/current
     * Current metrics for given symbol
     * Get current symbol metrics.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param exchangeId Exchange id (from the Metadata -&gt; Exchanges) (optional)
     * @return ApiResponse<kotlin.collections.List<V1GeneralData>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsSymbolCurrentGetWithHttpInfo(metricId: kotlin.String?, symbolId: kotlin.String?, exchangeId: kotlin.String?) : ApiResponse<kotlin.collections.List<V1GeneralData>?> {
        val localVariableConfig = v1MetricsSymbolCurrentGetRequestConfig(metricId = metricId, symbolId = symbolId, exchangeId = exchangeId)

        return request<Unit, kotlin.collections.List<V1GeneralData>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsSymbolCurrentGet
     *
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param exchangeId Exchange id (from the Metadata -&gt; Exchanges) (optional)
     * @return RequestConfig
     */
    fun v1MetricsSymbolCurrentGetRequestConfig(metricId: kotlin.String?, symbolId: kotlin.String?, exchangeId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (metricId != null) {
                    put("metric_id", listOf(metricId.toString()))
                }
                if (symbolId != null) {
                    put("symbol_id", listOf(symbolId.toString()))
                }
                if (exchangeId != null) {
                    put("exchange_id", listOf(exchangeId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/symbol/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/metrics/symbol/history
     * Historical metrics for symbol
     * Get symbol metrics history.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<V1MetricData>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsSymbolHistoryGet(metricId: kotlin.String, symbolId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<V1MetricData> {
        val localVarResponse = v1MetricsSymbolHistoryGetWithHttpInfo(metricId = metricId, symbolId = symbolId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricData>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/symbol/history
     * Historical metrics for symbol
     * Get symbol metrics history.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<V1MetricData>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsSymbolHistoryGetWithHttpInfo(metricId: kotlin.String, symbolId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<V1MetricData>?> {
        val localVariableConfig = v1MetricsSymbolHistoryGetRequestConfig(metricId = metricId, symbolId = symbolId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<V1MetricData>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsSymbolHistoryGet
     *
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v1MetricsSymbolHistoryGetRequestConfig(metricId: kotlin.String, symbolId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("symbol_id", listOf(symbolId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/symbol/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/metrics/symbol/listing
     * Listing of all supported metrics for symbol
     * Get data metrics for symbol.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @return kotlin.collections.List<V1ListingItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1MetricsSymbolListingGet(metricId: kotlin.String? = null, exchangeId: kotlin.String? = null, symbolId: kotlin.String? = null) : kotlin.collections.List<V1ListingItem> {
        val localVarResponse = v1MetricsSymbolListingGetWithHttpInfo(metricId = metricId, exchangeId = exchangeId, symbolId = symbolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1ListingItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/metrics/symbol/listing
     * Listing of all supported metrics for symbol
     * Get data metrics for symbol.
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @return ApiResponse<kotlin.collections.List<V1ListingItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1MetricsSymbolListingGetWithHttpInfo(metricId: kotlin.String?, exchangeId: kotlin.String?, symbolId: kotlin.String?) : ApiResponse<kotlin.collections.List<V1ListingItem>?> {
        val localVariableConfig = v1MetricsSymbolListingGetRequestConfig(metricId = metricId, exchangeId = exchangeId, symbolId = symbolId)

        return request<Unit, kotlin.collections.List<V1ListingItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1MetricsSymbolListingGet
     *
     * @param metricId Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @return RequestConfig
     */
    fun v1MetricsSymbolListingGetRequestConfig(metricId: kotlin.String?, exchangeId: kotlin.String?, symbolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (metricId != null) {
                    put("metric_id", listOf(metricId.toString()))
                }
                if (exchangeId != null) {
                    put("exchange_id", listOf(exchangeId.toString()))
                }
                if (symbolId != null) {
                    put("symbol_id", listOf(symbolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/metrics/symbol/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
