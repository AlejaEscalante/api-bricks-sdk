/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.V1MetricInfo

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class MetricsV2Api(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://rest.coinapi.io")
        }
    }

    /**
     * GET /v2/metrics/asset/history
     * Historical metrics for the asset
     * Get asset metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v2MetricsAssetHistoryGet(metricId: kotlin.String, assetId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<kotlin.Any> {
        val localVarResponse = v2MetricsAssetHistoryGetWithHttpInfo(metricId = metricId, assetId = assetId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/asset/history
     * Historical metrics for the asset
     * Get asset metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v2MetricsAssetHistoryGetWithHttpInfo(metricId: kotlin.String, assetId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Any>?> {
        val localVariableConfig = v2MetricsAssetHistoryGetRequestConfig(metricId = metricId, assetId = assetId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v2MetricsAssetHistoryGet
     *
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v2MetricsAssetHistoryGetRequestConfig(metricId: kotlin.String, assetId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("asset_id", listOf(assetId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/asset/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/asset/listing
     * Listing of metrics available for specific asset
     * Get all metrics that are actually available for the specified asset.
     * @param assetId Asset identifier (e.g., USDC, USDT)
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v2MetricsAssetListingGet(assetId: kotlin.String) : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = v2MetricsAssetListingGetWithHttpInfo(assetId = assetId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/asset/listing
     * Listing of metrics available for specific asset
     * Get all metrics that are actually available for the specified asset.
     * @param assetId Asset identifier (e.g., USDC, USDT)
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v2MetricsAssetListingGetWithHttpInfo(assetId: kotlin.String) : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = v2MetricsAssetListingGetRequestConfig(assetId = assetId)

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v2MetricsAssetListingGet
     *
     * @param assetId Asset identifier (e.g., USDC, USDT)
     * @return RequestConfig
     */
    fun v2MetricsAssetListingGetRequestConfig(assetId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("asset_id", listOf(assetId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/asset/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/chain/history
     * Historical metrics for the chain
     * Get chain metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v2MetricsChainHistoryGet(metricId: kotlin.String, chainId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<kotlin.Any> {
        val localVarResponse = v2MetricsChainHistoryGetWithHttpInfo(metricId = metricId, chainId = chainId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/chain/history
     * Historical metrics for the chain
     * Get chain metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v2MetricsChainHistoryGetWithHttpInfo(metricId: kotlin.String, chainId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Any>?> {
        val localVariableConfig = v2MetricsChainHistoryGetRequestConfig(metricId = metricId, chainId = chainId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v2MetricsChainHistoryGet
     *
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v2MetricsChainHistoryGetRequestConfig(metricId: kotlin.String, chainId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("chain_id", listOf(chainId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/chain/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/chain/listing
     * Listing of metrics available for specific chain
     * Get all metrics that are actually available for the specified blockchain chain.
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v2MetricsChainListingGet(chainId: kotlin.String) : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = v2MetricsChainListingGetWithHttpInfo(chainId = chainId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/chain/listing
     * Listing of metrics available for specific chain
     * Get all metrics that are actually available for the specified blockchain chain.
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v2MetricsChainListingGetWithHttpInfo(chainId: kotlin.String) : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = v2MetricsChainListingGetRequestConfig(chainId = chainId)

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v2MetricsChainListingGet
     *
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     * @return RequestConfig
     */
    fun v2MetricsChainListingGetRequestConfig(chainId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("chain_id", listOf(chainId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/chain/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/exchange/history
     * Historical metrics for the exchange
     * Get exchange metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v2MetricsExchangeHistoryGet(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, timeFormat: kotlin.String? = null, periodId: kotlin.String? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<kotlin.Any> {
        val localVarResponse = v2MetricsExchangeHistoryGetWithHttpInfo(metricId = metricId, exchangeId = exchangeId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/exchange/history
     * Historical metrics for the exchange
     * Get exchange metrics history.
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v2MetricsExchangeHistoryGetWithHttpInfo(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Any>?> {
        val localVariableConfig = v2MetricsExchangeHistoryGetRequestConfig(metricId = metricId, exchangeId = exchangeId, timeStart = timeStart, timeEnd = timeEnd, timeFormat = timeFormat, periodId = periodId, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v2MetricsExchangeHistoryGet
     *
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601 (optional)
     * @param timeEnd Ending time in ISO 8601 (optional)
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60; (optional)
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v2MetricsExchangeHistoryGetRequestConfig(metricId: kotlin.String, exchangeId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, timeFormat: kotlin.String?, periodId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("metric_id", listOf(metricId.toString()))
                put("exchange_id", listOf(exchangeId.toString()))
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (timeFormat != null) {
                    put("time_format", listOf(timeFormat.toString()))
                }
                if (periodId != null) {
                    put("period_id", listOf(periodId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/exchange/history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/exchange/listing
     * Listing of metrics available for specific exchange
     * Get all metrics that are actually available for the specified exchange.
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v2MetricsExchangeListingGet(exchangeId: kotlin.String) : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = v2MetricsExchangeListingGetWithHttpInfo(exchangeId = exchangeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/exchange/listing
     * Listing of metrics available for specific exchange
     * Get all metrics that are actually available for the specified exchange.
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v2MetricsExchangeListingGetWithHttpInfo(exchangeId: kotlin.String) : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = v2MetricsExchangeListingGetRequestConfig(exchangeId = exchangeId)

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v2MetricsExchangeListingGet
     *
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     * @return RequestConfig
     */
    fun v2MetricsExchangeListingGetRequestConfig(exchangeId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("exchange_id", listOf(exchangeId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/exchange/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/metrics/listing
     * Listing of all supported metrics
     * Get all metrics available in the system.
     * @return kotlin.collections.List<V1MetricInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v2MetricsListingGet() : kotlin.collections.List<V1MetricInfo> {
        val localVarResponse = v2MetricsListingGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V1MetricInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/metrics/listing
     * Listing of all supported metrics
     * Get all metrics available in the system.
     * @return ApiResponse<kotlin.collections.List<V1MetricInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v2MetricsListingGetWithHttpInfo() : ApiResponse<kotlin.collections.List<V1MetricInfo>?> {
        val localVariableConfig = v2MetricsListingGetRequestConfig()

        return request<Unit, kotlin.collections.List<V1MetricInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v2MetricsListingGet
     *
     * @return RequestConfig
     */
    fun v2MetricsListingGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/metrics/listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
