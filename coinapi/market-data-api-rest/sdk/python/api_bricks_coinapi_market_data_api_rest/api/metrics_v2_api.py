# coding: utf-8

"""
    CoinAPI Market Data REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Contact: support@apibricks.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictInt, StrictStr
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated
from api_bricks_coinapi_market_data_api_rest.models.v1_metric_info import V1MetricInfo

from api_bricks_coinapi_market_data_api_rest.api_client import ApiClient, RequestSerialized
from api_bricks_coinapi_market_data_api_rest.api_response import ApiResponse
from api_bricks_coinapi_market_data_api_rest.rest import RESTResponseType


class MetricsV2Api:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def v2_metrics_asset_history_get(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`)")],
        asset_id: Annotated[StrictStr, Field(description="Asset identifier (e.g., `USDC`, `USDT`)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Historical metrics for the asset

        Get asset metrics history.

        :param metric_id: Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`) (required)
        :type metric_id: str
        :param asset_id: Asset identifier (e.g., `USDC`, `USDT`) (required)
        :type asset_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_asset_history_get_serialize(
            metric_id=metric_id,
            asset_id=asset_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v2_metrics_asset_history_get_with_http_info(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`)")],
        asset_id: Annotated[StrictStr, Field(description="Asset identifier (e.g., `USDC`, `USDT`)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Historical metrics for the asset

        Get asset metrics history.

        :param metric_id: Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`) (required)
        :type metric_id: str
        :param asset_id: Asset identifier (e.g., `USDC`, `USDT`) (required)
        :type asset_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_asset_history_get_serialize(
            metric_id=metric_id,
            asset_id=asset_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v2_metrics_asset_history_get_without_preload_content(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`)")],
        asset_id: Annotated[StrictStr, Field(description="Asset identifier (e.g., `USDC`, `USDT`)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Historical metrics for the asset

        Get asset metrics history.

        :param metric_id: Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`) (required)
        :type metric_id: str
        :param asset_id: Asset identifier (e.g., `USDC`, `USDT`) (required)
        :type asset_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_asset_history_get_serialize(
            metric_id=metric_id,
            asset_id=asset_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_metrics_asset_history_get_serialize(
        self,
        metric_id,
        asset_id,
        time_start,
        time_end,
        time_format,
        period_id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if asset_id is not None:
            
            _query_params.append(('asset_id', asset_id))
            
        if time_start is not None:
            if isinstance(time_start, datetime):
                _query_params.append(
                    (
                        'time_start',
                        time_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_start', time_start))
            
        if time_end is not None:
            if isinstance(time_end, datetime):
                _query_params.append(
                    (
                        'time_end',
                        time_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_end', time_end))
            
        if time_format is not None:
            
            _query_params.append(('time_format', time_format))
            
        if period_id is not None:
            
            _query_params.append(('period_id', period_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/metrics/asset/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v2_metrics_asset_listing_get(
        self,
        asset_id: Annotated[StrictStr, Field(description="Asset identifier (e.g., USDC, USDT)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1MetricInfo]:
        """Listing of metrics available for specific asset

        Get all metrics that are actually available for the specified asset.

        :param asset_id: Asset identifier (e.g., USDC, USDT) (required)
        :type asset_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_asset_listing_get_serialize(
            asset_id=asset_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v2_metrics_asset_listing_get_with_http_info(
        self,
        asset_id: Annotated[StrictStr, Field(description="Asset identifier (e.g., USDC, USDT)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1MetricInfo]]:
        """Listing of metrics available for specific asset

        Get all metrics that are actually available for the specified asset.

        :param asset_id: Asset identifier (e.g., USDC, USDT) (required)
        :type asset_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_asset_listing_get_serialize(
            asset_id=asset_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v2_metrics_asset_listing_get_without_preload_content(
        self,
        asset_id: Annotated[StrictStr, Field(description="Asset identifier (e.g., USDC, USDT)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Listing of metrics available for specific asset

        Get all metrics that are actually available for the specified asset.

        :param asset_id: Asset identifier (e.g., USDC, USDT) (required)
        :type asset_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_asset_listing_get_serialize(
            asset_id=asset_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_metrics_asset_listing_get_serialize(
        self,
        asset_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if asset_id is not None:
            
            _query_params.append(('asset_id', asset_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/metrics/asset/listing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v2_metrics_chain_history_get(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`)")],
        chain_id: Annotated[StrictStr, Field(description="Chain identifier (e.g., `Ethereum`, `Arbitrum`)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Historical metrics for the chain

        Get chain metrics history.

        :param metric_id: Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`) (required)
        :type metric_id: str
        :param chain_id: Chain identifier (e.g., `Ethereum`, `Arbitrum`) (required)
        :type chain_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_chain_history_get_serialize(
            metric_id=metric_id,
            chain_id=chain_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v2_metrics_chain_history_get_with_http_info(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`)")],
        chain_id: Annotated[StrictStr, Field(description="Chain identifier (e.g., `Ethereum`, `Arbitrum`)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Historical metrics for the chain

        Get chain metrics history.

        :param metric_id: Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`) (required)
        :type metric_id: str
        :param chain_id: Chain identifier (e.g., `Ethereum`, `Arbitrum`) (required)
        :type chain_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_chain_history_get_serialize(
            metric_id=metric_id,
            chain_id=chain_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v2_metrics_chain_history_get_without_preload_content(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`)")],
        chain_id: Annotated[StrictStr, Field(description="Chain identifier (e.g., `Ethereum`, `Arbitrum`)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Historical metrics for the chain

        Get chain metrics history.

        :param metric_id: Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`) (required)
        :type metric_id: str
        :param chain_id: Chain identifier (e.g., `Ethereum`, `Arbitrum`) (required)
        :type chain_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_chain_history_get_serialize(
            metric_id=metric_id,
            chain_id=chain_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_metrics_chain_history_get_serialize(
        self,
        metric_id,
        chain_id,
        time_start,
        time_end,
        time_format,
        period_id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if chain_id is not None:
            
            _query_params.append(('chain_id', chain_id))
            
        if time_start is not None:
            if isinstance(time_start, datetime):
                _query_params.append(
                    (
                        'time_start',
                        time_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_start', time_start))
            
        if time_end is not None:
            if isinstance(time_end, datetime):
                _query_params.append(
                    (
                        'time_end',
                        time_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_end', time_end))
            
        if time_format is not None:
            
            _query_params.append(('time_format', time_format))
            
        if period_id is not None:
            
            _query_params.append(('period_id', period_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/metrics/chain/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v2_metrics_chain_listing_get(
        self,
        chain_id: Annotated[StrictStr, Field(description="Chain identifier (e.g., ETHEREUM, ARBITRUM)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1MetricInfo]:
        """Listing of metrics available for specific chain

        Get all metrics that are actually available for the specified blockchain chain.

        :param chain_id: Chain identifier (e.g., ETHEREUM, ARBITRUM) (required)
        :type chain_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_chain_listing_get_serialize(
            chain_id=chain_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v2_metrics_chain_listing_get_with_http_info(
        self,
        chain_id: Annotated[StrictStr, Field(description="Chain identifier (e.g., ETHEREUM, ARBITRUM)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1MetricInfo]]:
        """Listing of metrics available for specific chain

        Get all metrics that are actually available for the specified blockchain chain.

        :param chain_id: Chain identifier (e.g., ETHEREUM, ARBITRUM) (required)
        :type chain_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_chain_listing_get_serialize(
            chain_id=chain_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v2_metrics_chain_listing_get_without_preload_content(
        self,
        chain_id: Annotated[StrictStr, Field(description="Chain identifier (e.g., ETHEREUM, ARBITRUM)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Listing of metrics available for specific chain

        Get all metrics that are actually available for the specified blockchain chain.

        :param chain_id: Chain identifier (e.g., ETHEREUM, ARBITRUM) (required)
        :type chain_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_chain_listing_get_serialize(
            chain_id=chain_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_metrics_chain_listing_get_serialize(
        self,
        chain_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if chain_id is not None:
            
            _query_params.append(('chain_id', chain_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/metrics/chain/listing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v2_metrics_exchange_history_get(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`)")],
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (e.g., `BINANCE`, `UNISWAP-V3-ETHEREUM`)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Historical metrics for the exchange

        Get exchange metrics history.

        :param metric_id: Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`) (required)
        :type metric_id: str
        :param exchange_id: Exchange identifier (e.g., `BINANCE`, `UNISWAP-V3-ETHEREUM`) (required)
        :type exchange_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_exchange_history_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v2_metrics_exchange_history_get_with_http_info(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`)")],
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (e.g., `BINANCE`, `UNISWAP-V3-ETHEREUM`)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Historical metrics for the exchange

        Get exchange metrics history.

        :param metric_id: Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`) (required)
        :type metric_id: str
        :param exchange_id: Exchange identifier (e.g., `BINANCE`, `UNISWAP-V3-ETHEREUM`) (required)
        :type exchange_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_exchange_history_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v2_metrics_exchange_history_get_without_preload_content(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`)")],
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (e.g., `BINANCE`, `UNISWAP-V3-ETHEREUM`)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Historical metrics for the exchange

        Get exchange metrics history.

        :param metric_id: Metric identifier (e.g., `TVL`, `STABLES_BRIDGED_USD`) (required)
        :type metric_id: str
        :param exchange_id: Exchange identifier (e.g., `BINANCE`, `UNISWAP-V3-ETHEREUM`) (required)
        :type exchange_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `1MIN` or `2MTH`), default value is `1MIN`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_exchange_history_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_metrics_exchange_history_get_serialize(
        self,
        metric_id,
        exchange_id,
        time_start,
        time_end,
        time_format,
        period_id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        if time_start is not None:
            if isinstance(time_start, datetime):
                _query_params.append(
                    (
                        'time_start',
                        time_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_start', time_start))
            
        if time_end is not None:
            if isinstance(time_end, datetime):
                _query_params.append(
                    (
                        'time_end',
                        time_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_end', time_end))
            
        if time_format is not None:
            
            _query_params.append(('time_format', time_format))
            
        if period_id is not None:
            
            _query_params.append(('period_id', period_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/metrics/exchange/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v2_metrics_exchange_listing_get(
        self,
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1MetricInfo]:
        """Listing of metrics available for specific exchange

        Get all metrics that are actually available for the specified exchange.

        :param exchange_id: Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM) (required)
        :type exchange_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_exchange_listing_get_serialize(
            exchange_id=exchange_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v2_metrics_exchange_listing_get_with_http_info(
        self,
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1MetricInfo]]:
        """Listing of metrics available for specific exchange

        Get all metrics that are actually available for the specified exchange.

        :param exchange_id: Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM) (required)
        :type exchange_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_exchange_listing_get_serialize(
            exchange_id=exchange_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v2_metrics_exchange_listing_get_without_preload_content(
        self,
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Listing of metrics available for specific exchange

        Get all metrics that are actually available for the specified exchange.

        :param exchange_id: Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM) (required)
        :type exchange_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_exchange_listing_get_serialize(
            exchange_id=exchange_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_metrics_exchange_listing_get_serialize(
        self,
        exchange_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/metrics/exchange/listing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v2_metrics_listing_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1MetricInfo]:
        """Listing of all supported metrics

        Get all metrics available in the system.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_listing_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v2_metrics_listing_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1MetricInfo]]:
        """Listing of all supported metrics

        Get all metrics available in the system.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_listing_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v2_metrics_listing_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Listing of all supported metrics

        Get all metrics available in the system.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v2_metrics_listing_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricInfo]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_metrics_listing_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/metrics/listing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


