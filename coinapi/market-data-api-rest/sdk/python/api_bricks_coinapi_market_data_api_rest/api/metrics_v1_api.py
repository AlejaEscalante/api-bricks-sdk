# coding: utf-8

"""
    CoinAPI Market Data REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Contact: support@apibricks.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from api_bricks_coinapi_market_data_api_rest.models.v1_general_data import V1GeneralData
from api_bricks_coinapi_market_data_api_rest.models.v1_listing_item import V1ListingItem
from api_bricks_coinapi_market_data_api_rest.models.v1_metric import V1Metric
from api_bricks_coinapi_market_data_api_rest.models.v1_metric_data import V1MetricData

from api_bricks_coinapi_market_data_api_rest.api_client import ApiClient, RequestSerialized
from api_bricks_coinapi_market_data_api_rest.api_response import ApiResponse
from api_bricks_coinapi_market_data_api_rest.rest import RESTResponseType


class MetricsV1Api:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def v1_metrics_asset_current_get(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        asset_id: Annotated[Optional[StrictStr], Field(description="Asset identifier (from the Metadata -> Assets)")] = None,
        asset_id_external: Annotated[Optional[StrictStr], Field(description="Exchange asset identifier")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange identifier (from the Metadata -> Exchanges)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1GeneralData]:
        """Current metrics for given asset

        Get current asset metrics.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param asset_id: Asset identifier (from the Metadata -> Assets)
        :type asset_id: str
        :param asset_id_external: Exchange asset identifier
        :type asset_id_external: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_asset_current_get_serialize(
            metric_id=metric_id,
            asset_id=asset_id,
            asset_id_external=asset_id_external,
            exchange_id=exchange_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1GeneralData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_asset_current_get_with_http_info(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        asset_id: Annotated[Optional[StrictStr], Field(description="Asset identifier (from the Metadata -> Assets)")] = None,
        asset_id_external: Annotated[Optional[StrictStr], Field(description="Exchange asset identifier")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange identifier (from the Metadata -> Exchanges)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1GeneralData]]:
        """Current metrics for given asset

        Get current asset metrics.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param asset_id: Asset identifier (from the Metadata -> Assets)
        :type asset_id: str
        :param asset_id_external: Exchange asset identifier
        :type asset_id_external: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_asset_current_get_serialize(
            metric_id=metric_id,
            asset_id=asset_id,
            asset_id_external=asset_id_external,
            exchange_id=exchange_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1GeneralData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_asset_current_get_without_preload_content(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        asset_id: Annotated[Optional[StrictStr], Field(description="Asset identifier (from the Metadata -> Assets)")] = None,
        asset_id_external: Annotated[Optional[StrictStr], Field(description="Exchange asset identifier")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange identifier (from the Metadata -> Exchanges)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Current metrics for given asset

        Get current asset metrics.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param asset_id: Asset identifier (from the Metadata -> Assets)
        :type asset_id: str
        :param asset_id_external: Exchange asset identifier
        :type asset_id_external: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_asset_current_get_serialize(
            metric_id=metric_id,
            asset_id=asset_id,
            asset_id_external=asset_id_external,
            exchange_id=exchange_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1GeneralData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_asset_current_get_serialize(
        self,
        metric_id,
        asset_id,
        asset_id_external,
        exchange_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if asset_id is not None:
            
            _query_params.append(('asset_id', asset_id))
            
        if asset_id_external is not None:
            
            _query_params.append(('asset_id_external', asset_id_external))
            
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/asset/current',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v1_metrics_asset_history_get(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (from the Metrics -> Listing)")],
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (from the Metadata -> Exchanges)")],
        asset_id: Annotated[Optional[StrictStr], Field(description="Asset identifier (from the Metadata -> Assets)")] = None,
        asset_id_external: Annotated[Optional[StrictStr], Field(description="Exchange asset identifier")] = None,
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1MetricData]:
        """Historical metrics for asset

        Get asset metrics history.

        :param metric_id: Metric identifier (from the Metrics -> Listing) (required)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param asset_id: Asset identifier (from the Metadata -> Assets)
        :type asset_id: str
        :param asset_id_external: Exchange asset identifier
        :type asset_id_external: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_asset_history_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            asset_id=asset_id,
            asset_id_external=asset_id_external,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_asset_history_get_with_http_info(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (from the Metrics -> Listing)")],
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (from the Metadata -> Exchanges)")],
        asset_id: Annotated[Optional[StrictStr], Field(description="Asset identifier (from the Metadata -> Assets)")] = None,
        asset_id_external: Annotated[Optional[StrictStr], Field(description="Exchange asset identifier")] = None,
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1MetricData]]:
        """Historical metrics for asset

        Get asset metrics history.

        :param metric_id: Metric identifier (from the Metrics -> Listing) (required)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param asset_id: Asset identifier (from the Metadata -> Assets)
        :type asset_id: str
        :param asset_id_external: Exchange asset identifier
        :type asset_id_external: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_asset_history_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            asset_id=asset_id,
            asset_id_external=asset_id_external,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_asset_history_get_without_preload_content(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (from the Metrics -> Listing)")],
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (from the Metadata -> Exchanges)")],
        asset_id: Annotated[Optional[StrictStr], Field(description="Asset identifier (from the Metadata -> Assets)")] = None,
        asset_id_external: Annotated[Optional[StrictStr], Field(description="Exchange asset identifier")] = None,
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Historical metrics for asset

        Get asset metrics history.

        :param metric_id: Metric identifier (from the Metrics -> Listing) (required)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param asset_id: Asset identifier (from the Metadata -> Assets)
        :type asset_id: str
        :param asset_id_external: Exchange asset identifier
        :type asset_id_external: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_asset_history_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            asset_id=asset_id,
            asset_id_external=asset_id_external,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_asset_history_get_serialize(
        self,
        metric_id,
        exchange_id,
        asset_id,
        asset_id_external,
        time_start,
        time_end,
        time_format,
        period_id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if asset_id is not None:
            
            _query_params.append(('asset_id', asset_id))
            
        if asset_id_external is not None:
            
            _query_params.append(('asset_id_external', asset_id_external))
            
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        if time_start is not None:
            if isinstance(time_start, datetime):
                _query_params.append(
                    (
                        'time_start',
                        time_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_start', time_start))
            
        if time_end is not None:
            if isinstance(time_end, datetime):
                _query_params.append(
                    (
                        'time_end',
                        time_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_end', time_end))
            
        if time_format is not None:
            
            _query_params.append(('time_format', time_format))
            
        if period_id is not None:
            
            _query_params.append(('period_id', period_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/asset/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v1_metrics_asset_listing_get(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange identifier (from the Metadata -> Exchanges)")] = None,
        chain_id: Annotated[Optional[StrictStr], Field(description="Chain identifier")] = None,
        network_id: Annotated[Optional[StrictStr], Field(description="Network identifier")] = None,
        asset_id: Annotated[Optional[StrictStr], Field(description="Asset identifier (from the Metadata -> Assets)")] = None,
        asset_id_external: Annotated[Optional[StrictStr], Field(description="The asset external identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1ListingItem]:
        """Listing of all supported metrics for asset

        Get data metrics for asset.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param chain_id: Chain identifier
        :type chain_id: str
        :param network_id: Network identifier
        :type network_id: str
        :param asset_id: Asset identifier (from the Metadata -> Assets)
        :type asset_id: str
        :param asset_id_external: The asset external identifier
        :type asset_id_external: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_asset_listing_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            chain_id=chain_id,
            network_id=network_id,
            asset_id=asset_id,
            asset_id_external=asset_id_external,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1ListingItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_asset_listing_get_with_http_info(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange identifier (from the Metadata -> Exchanges)")] = None,
        chain_id: Annotated[Optional[StrictStr], Field(description="Chain identifier")] = None,
        network_id: Annotated[Optional[StrictStr], Field(description="Network identifier")] = None,
        asset_id: Annotated[Optional[StrictStr], Field(description="Asset identifier (from the Metadata -> Assets)")] = None,
        asset_id_external: Annotated[Optional[StrictStr], Field(description="The asset external identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1ListingItem]]:
        """Listing of all supported metrics for asset

        Get data metrics for asset.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param chain_id: Chain identifier
        :type chain_id: str
        :param network_id: Network identifier
        :type network_id: str
        :param asset_id: Asset identifier (from the Metadata -> Assets)
        :type asset_id: str
        :param asset_id_external: The asset external identifier
        :type asset_id_external: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_asset_listing_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            chain_id=chain_id,
            network_id=network_id,
            asset_id=asset_id,
            asset_id_external=asset_id_external,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1ListingItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_asset_listing_get_without_preload_content(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange identifier (from the Metadata -> Exchanges)")] = None,
        chain_id: Annotated[Optional[StrictStr], Field(description="Chain identifier")] = None,
        network_id: Annotated[Optional[StrictStr], Field(description="Network identifier")] = None,
        asset_id: Annotated[Optional[StrictStr], Field(description="Asset identifier (from the Metadata -> Assets)")] = None,
        asset_id_external: Annotated[Optional[StrictStr], Field(description="The asset external identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Listing of all supported metrics for asset

        Get data metrics for asset.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param chain_id: Chain identifier
        :type chain_id: str
        :param network_id: Network identifier
        :type network_id: str
        :param asset_id: Asset identifier (from the Metadata -> Assets)
        :type asset_id: str
        :param asset_id_external: The asset external identifier
        :type asset_id_external: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_asset_listing_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            chain_id=chain_id,
            network_id=network_id,
            asset_id=asset_id,
            asset_id_external=asset_id_external,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1ListingItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_asset_listing_get_serialize(
        self,
        metric_id,
        exchange_id,
        chain_id,
        network_id,
        asset_id,
        asset_id_external,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        if chain_id is not None:
            
            _query_params.append(('chain_id', chain_id))
            
        if network_id is not None:
            
            _query_params.append(('network_id', network_id))
            
        if asset_id is not None:
            
            _query_params.append(('asset_id', asset_id))
            
        if asset_id_external is not None:
            
            _query_params.append(('asset_id_external', asset_id_external))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/asset/listing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v1_metrics_exchange_current_get(
        self,
        exchange_id: Annotated[StrictStr, Field(description="The exchange identifier (from the Metadata -> Exchanges)")],
        metric_id: Annotated[Optional[StrictStr], Field(description="The metric identifier (from the Metrics -> Listing)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1GeneralData]:
        """Current metrics for given exchange

        Get current exchange metrics values.

        :param exchange_id: The exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param metric_id: The metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_exchange_current_get_serialize(
            exchange_id=exchange_id,
            metric_id=metric_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1GeneralData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_exchange_current_get_with_http_info(
        self,
        exchange_id: Annotated[StrictStr, Field(description="The exchange identifier (from the Metadata -> Exchanges)")],
        metric_id: Annotated[Optional[StrictStr], Field(description="The metric identifier (from the Metrics -> Listing)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1GeneralData]]:
        """Current metrics for given exchange

        Get current exchange metrics values.

        :param exchange_id: The exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param metric_id: The metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_exchange_current_get_serialize(
            exchange_id=exchange_id,
            metric_id=metric_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1GeneralData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_exchange_current_get_without_preload_content(
        self,
        exchange_id: Annotated[StrictStr, Field(description="The exchange identifier (from the Metadata -> Exchanges)")],
        metric_id: Annotated[Optional[StrictStr], Field(description="The metric identifier (from the Metrics -> Listing)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Current metrics for given exchange

        Get current exchange metrics values.

        :param exchange_id: The exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param metric_id: The metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_exchange_current_get_serialize(
            exchange_id=exchange_id,
            metric_id=metric_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1GeneralData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_exchange_current_get_serialize(
        self,
        exchange_id,
        metric_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/exchange/current',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v1_metrics_exchange_history_get(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (from the Metrics -> Listing)")],
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (from the Metadata -> Exchanges)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1MetricData]:
        """Historical metrics for the exchange

        Get exchange metrics history.

        :param metric_id: Metric identifier (from the Metrics -> Listing) (required)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_exchange_history_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_exchange_history_get_with_http_info(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (from the Metrics -> Listing)")],
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (from the Metadata -> Exchanges)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1MetricData]]:
        """Historical metrics for the exchange

        Get exchange metrics history.

        :param metric_id: Metric identifier (from the Metrics -> Listing) (required)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_exchange_history_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_exchange_history_get_without_preload_content(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (from the Metrics -> Listing)")],
        exchange_id: Annotated[StrictStr, Field(description="Exchange identifier (from the Metadata -> Exchanges)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Historical metrics for the exchange

        Get exchange metrics history.

        :param metric_id: Metric identifier (from the Metrics -> Listing) (required)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_exchange_history_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_exchange_history_get_serialize(
        self,
        metric_id,
        exchange_id,
        time_start,
        time_end,
        time_format,
        period_id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        if time_start is not None:
            if isinstance(time_start, datetime):
                _query_params.append(
                    (
                        'time_start',
                        time_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_start', time_start))
            
        if time_end is not None:
            if isinstance(time_end, datetime):
                _query_params.append(
                    (
                        'time_end',
                        time_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_end', time_end))
            
        if time_format is not None:
            
            _query_params.append(('time_format', time_format))
            
        if period_id is not None:
            
            _query_params.append(('period_id', period_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/exchange/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v1_metrics_exchange_listing_get(
        self,
        exchange_id: Annotated[StrictStr, Field(description="The exchange identifier (from the Metadata -> Exchanges)")],
        metric_id: Annotated[Optional[StrictStr], Field(description="The metric identifier (from the Metrics -> Listing)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1ListingItem]:
        """Listing of all supported exchange metrics

        Get data metrics for exchange.

        :param exchange_id: The exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param metric_id: The metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_exchange_listing_get_serialize(
            exchange_id=exchange_id,
            metric_id=metric_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1ListingItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_exchange_listing_get_with_http_info(
        self,
        exchange_id: Annotated[StrictStr, Field(description="The exchange identifier (from the Metadata -> Exchanges)")],
        metric_id: Annotated[Optional[StrictStr], Field(description="The metric identifier (from the Metrics -> Listing)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1ListingItem]]:
        """Listing of all supported exchange metrics

        Get data metrics for exchange.

        :param exchange_id: The exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param metric_id: The metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_exchange_listing_get_serialize(
            exchange_id=exchange_id,
            metric_id=metric_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1ListingItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_exchange_listing_get_without_preload_content(
        self,
        exchange_id: Annotated[StrictStr, Field(description="The exchange identifier (from the Metadata -> Exchanges)")],
        metric_id: Annotated[Optional[StrictStr], Field(description="The metric identifier (from the Metrics -> Listing)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Listing of all supported exchange metrics

        Get data metrics for exchange.

        :param exchange_id: The exchange identifier (from the Metadata -> Exchanges) (required)
        :type exchange_id: str
        :param metric_id: The metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_exchange_listing_get_serialize(
            exchange_id=exchange_id,
            metric_id=metric_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1ListingItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_exchange_listing_get_serialize(
        self,
        exchange_id,
        metric_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/exchange/listing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v1_metrics_listing_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1Metric]:
        """Listing of all supported metrics by CoinAPI

        Get all data metrics.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_listing_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1Metric]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_listing_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1Metric]]:
        """Listing of all supported metrics by CoinAPI

        Get all data metrics.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_listing_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1Metric]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_listing_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Listing of all supported metrics by CoinAPI

        Get all data metrics.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_listing_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1Metric]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_listing_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/listing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v1_metrics_symbol_current_get(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        symbol_id: Annotated[Optional[StrictStr], Field(description="Symbol identifier (from the Metadata -> Symbols)")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange id (from the Metadata -> Exchanges)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1GeneralData]:
        """Current metrics for given symbol

        Get current symbol metrics.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param symbol_id: Symbol identifier (from the Metadata -> Symbols)
        :type symbol_id: str
        :param exchange_id: Exchange id (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_symbol_current_get_serialize(
            metric_id=metric_id,
            symbol_id=symbol_id,
            exchange_id=exchange_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1GeneralData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_symbol_current_get_with_http_info(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        symbol_id: Annotated[Optional[StrictStr], Field(description="Symbol identifier (from the Metadata -> Symbols)")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange id (from the Metadata -> Exchanges)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1GeneralData]]:
        """Current metrics for given symbol

        Get current symbol metrics.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param symbol_id: Symbol identifier (from the Metadata -> Symbols)
        :type symbol_id: str
        :param exchange_id: Exchange id (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_symbol_current_get_serialize(
            metric_id=metric_id,
            symbol_id=symbol_id,
            exchange_id=exchange_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1GeneralData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_symbol_current_get_without_preload_content(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        symbol_id: Annotated[Optional[StrictStr], Field(description="Symbol identifier (from the Metadata -> Symbols)")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange id (from the Metadata -> Exchanges)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Current metrics for given symbol

        Get current symbol metrics.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param symbol_id: Symbol identifier (from the Metadata -> Symbols)
        :type symbol_id: str
        :param exchange_id: Exchange id (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_symbol_current_get_serialize(
            metric_id=metric_id,
            symbol_id=symbol_id,
            exchange_id=exchange_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1GeneralData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_symbol_current_get_serialize(
        self,
        metric_id,
        symbol_id,
        exchange_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if symbol_id is not None:
            
            _query_params.append(('symbol_id', symbol_id))
            
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/symbol/current',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v1_metrics_symbol_history_get(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (from the Metrics -> Listing)")],
        symbol_id: Annotated[StrictStr, Field(description="Symbol identifier (from the Metadata -> Symbols)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1MetricData]:
        """Historical metrics for symbol

        Get symbol metrics history.

        :param metric_id: Metric identifier (from the Metrics -> Listing) (required)
        :type metric_id: str
        :param symbol_id: Symbol identifier (from the Metadata -> Symbols) (required)
        :type symbol_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_symbol_history_get_serialize(
            metric_id=metric_id,
            symbol_id=symbol_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_symbol_history_get_with_http_info(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (from the Metrics -> Listing)")],
        symbol_id: Annotated[StrictStr, Field(description="Symbol identifier (from the Metadata -> Symbols)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1MetricData]]:
        """Historical metrics for symbol

        Get symbol metrics history.

        :param metric_id: Metric identifier (from the Metrics -> Listing) (required)
        :type metric_id: str
        :param symbol_id: Symbol identifier (from the Metadata -> Symbols) (required)
        :type symbol_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_symbol_history_get_serialize(
            metric_id=metric_id,
            symbol_id=symbol_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_symbol_history_get_without_preload_content(
        self,
        metric_id: Annotated[StrictStr, Field(description="Metric identifier (from the Metrics -> Listing)")],
        symbol_id: Annotated[StrictStr, Field(description="Symbol identifier (from the Metadata -> Symbols)")],
        time_start: Annotated[Optional[datetime], Field(description="Starting time in ISO 8601")] = None,
        time_end: Annotated[Optional[datetime], Field(description="Ending time in ISO 8601")] = None,
        time_format: Annotated[Optional[StrictStr], Field(description="If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)")] = None,
        period_id: Annotated[Optional[StrictStr], Field(description="Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Historical metrics for symbol

        Get symbol metrics history.

        :param metric_id: Metric identifier (from the Metrics -> Listing) (required)
        :type metric_id: str
        :param symbol_id: Symbol identifier (from the Metadata -> Symbols) (required)
        :type symbol_id: str
        :param time_start: Starting time in ISO 8601
        :type time_start: datetime
        :param time_end: Ending time in ISO 8601
        :type time_end: datetime
        :param time_format: If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
        :type time_format: str
        :param period_id: Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`
        :type period_id: str
        :param limit: Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_symbol_history_get_serialize(
            metric_id=metric_id,
            symbol_id=symbol_id,
            time_start=time_start,
            time_end=time_end,
            time_format=time_format,
            period_id=period_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1MetricData]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_symbol_history_get_serialize(
        self,
        metric_id,
        symbol_id,
        time_start,
        time_end,
        time_format,
        period_id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if symbol_id is not None:
            
            _query_params.append(('symbol_id', symbol_id))
            
        if time_start is not None:
            if isinstance(time_start, datetime):
                _query_params.append(
                    (
                        'time_start',
                        time_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_start', time_start))
            
        if time_end is not None:
            if isinstance(time_end, datetime):
                _query_params.append(
                    (
                        'time_end',
                        time_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('time_end', time_end))
            
        if time_format is not None:
            
            _query_params.append(('time_format', time_format))
            
        if period_id is not None:
            
            _query_params.append(('period_id', period_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/symbol/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def v1_metrics_symbol_listing_get(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange identifier (from the Metadata -> Exchanges)")] = None,
        symbol_id: Annotated[Optional[StrictStr], Field(description="Symbol identifier (from the Metadata -> Symbols)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[V1ListingItem]:
        """Listing of all supported metrics for symbol

        Get data metrics for symbol.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param symbol_id: Symbol identifier (from the Metadata -> Symbols)
        :type symbol_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_symbol_listing_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            symbol_id=symbol_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1ListingItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def v1_metrics_symbol_listing_get_with_http_info(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange identifier (from the Metadata -> Exchanges)")] = None,
        symbol_id: Annotated[Optional[StrictStr], Field(description="Symbol identifier (from the Metadata -> Symbols)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[V1ListingItem]]:
        """Listing of all supported metrics for symbol

        Get data metrics for symbol.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param symbol_id: Symbol identifier (from the Metadata -> Symbols)
        :type symbol_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_symbol_listing_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            symbol_id=symbol_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1ListingItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def v1_metrics_symbol_listing_get_without_preload_content(
        self,
        metric_id: Annotated[Optional[StrictStr], Field(description="Metric identifier (from the Metrics -> Listing)")] = None,
        exchange_id: Annotated[Optional[StrictStr], Field(description="Exchange identifier (from the Metadata -> Exchanges)")] = None,
        symbol_id: Annotated[Optional[StrictStr], Field(description="Symbol identifier (from the Metadata -> Symbols)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Listing of all supported metrics for symbol

        Get data metrics for symbol.

        :param metric_id: Metric identifier (from the Metrics -> Listing)
        :type metric_id: str
        :param exchange_id: Exchange identifier (from the Metadata -> Exchanges)
        :type exchange_id: str
        :param symbol_id: Symbol identifier (from the Metadata -> Symbols)
        :type symbol_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._v1_metrics_symbol_listing_get_serialize(
            metric_id=metric_id,
            exchange_id=exchange_id,
            symbol_id=symbol_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[V1ListingItem]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v1_metrics_symbol_listing_get_serialize(
        self,
        metric_id,
        exchange_id,
        symbol_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if metric_id is not None:
            
            _query_params.append(('metric_id', metric_id))
            
        if exchange_id is not None:
            
            _query_params.append(('exchange_id', exchange_id))
            
        if symbol_id is not None:
            
            _query_params.append(('symbol_id', symbol_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json', 
                    'application/x-msgpack'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKey', 
            'JWT'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/metrics/symbol/listing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


