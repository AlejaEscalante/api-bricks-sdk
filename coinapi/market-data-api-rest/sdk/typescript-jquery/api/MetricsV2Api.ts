/**
 * CoinAPI Market Data REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as $ from 'jquery';
import * as models from '../model/models';
import { COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


export class MetricsV2Api {
    protected basePath = 'https://rest.coinapi.io';
    public defaultHeaders: Array<string> = [];
    public defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings = undefined;
    public configuration: Configuration = new Configuration();

    constructor(basePath?: string, configuration?: Configuration, defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
        if (defaultExtraJQueryAjaxSettings) {
            this.defaultExtraJQueryAjaxSettings = defaultExtraJQueryAjaxSettings;
        }
    }

    private extendObj<T1 extends object, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * Get asset metrics history.
     * @summary Historical metrics for the asset
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param assetId Asset identifier (e.g., &#x60;USDC&#x60;, &#x60;USDT&#x60;)
     * @param timeStart Starting time in ISO 8601
     * @param timeEnd Ending time in ISO 8601
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     */
    public v2MetricsAssetHistoryGet(metricId: string, assetId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<object>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v2/metrics/asset/history';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'metricId' is not null or undefined
        if (metricId === null || metricId === undefined) {
            throw new Error('Required parameter metricId was null or undefined when calling v2MetricsAssetHistoryGet.');
        }

        // verify required parameter 'assetId' is not null or undefined
        if (assetId === null || assetId === undefined) {
            throw new Error('Required parameter assetId was null or undefined when calling v2MetricsAssetHistoryGet.');
        }

        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (assetId !== null && assetId !== undefined) {
            queryParameters['asset_id'] = <string><any>assetId;
        }
        if (timeStart !== null && timeStart !== undefined) {
            queryParameters['time_start'] = timeStart.toISOString();
        }
        if (timeEnd !== null && timeEnd !== undefined) {
            queryParameters['time_end'] = timeEnd.toISOString();
        }
        if (timeFormat !== null && timeFormat !== undefined) {
            queryParameters['time_format'] = <string><any>timeFormat;
        }
        if (periodId !== null && periodId !== undefined) {
            queryParameters['period_id'] = <string><any>periodId;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<object>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<object>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get all metrics that are actually available for the specified asset.
     * @summary Listing of metrics available for specific asset
     * @param assetId Asset identifier (e.g., USDC, USDT)
     */
    public v2MetricsAssetListingGet(assetId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1MetricInfo>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v2/metrics/asset/listing';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'assetId' is not null or undefined
        if (assetId === null || assetId === undefined) {
            throw new Error('Required parameter assetId was null or undefined when calling v2MetricsAssetListingGet.');
        }

        if (assetId !== null && assetId !== undefined) {
            queryParameters['asset_id'] = <string><any>assetId;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1MetricInfo>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1MetricInfo>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get chain metrics history.
     * @summary Historical metrics for the chain
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param chainId Chain identifier (e.g., &#x60;Ethereum&#x60;, &#x60;Arbitrum&#x60;)
     * @param timeStart Starting time in ISO 8601
     * @param timeEnd Ending time in ISO 8601
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     */
    public v2MetricsChainHistoryGet(metricId: string, chainId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<object>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v2/metrics/chain/history';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'metricId' is not null or undefined
        if (metricId === null || metricId === undefined) {
            throw new Error('Required parameter metricId was null or undefined when calling v2MetricsChainHistoryGet.');
        }

        // verify required parameter 'chainId' is not null or undefined
        if (chainId === null || chainId === undefined) {
            throw new Error('Required parameter chainId was null or undefined when calling v2MetricsChainHistoryGet.');
        }

        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (chainId !== null && chainId !== undefined) {
            queryParameters['chain_id'] = <string><any>chainId;
        }
        if (timeStart !== null && timeStart !== undefined) {
            queryParameters['time_start'] = timeStart.toISOString();
        }
        if (timeEnd !== null && timeEnd !== undefined) {
            queryParameters['time_end'] = timeEnd.toISOString();
        }
        if (timeFormat !== null && timeFormat !== undefined) {
            queryParameters['time_format'] = <string><any>timeFormat;
        }
        if (periodId !== null && periodId !== undefined) {
            queryParameters['period_id'] = <string><any>periodId;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<object>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<object>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get all metrics that are actually available for the specified blockchain chain.
     * @summary Listing of metrics available for specific chain
     * @param chainId Chain identifier (e.g., ETHEREUM, ARBITRUM)
     */
    public v2MetricsChainListingGet(chainId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1MetricInfo>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v2/metrics/chain/listing';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'chainId' is not null or undefined
        if (chainId === null || chainId === undefined) {
            throw new Error('Required parameter chainId was null or undefined when calling v2MetricsChainListingGet.');
        }

        if (chainId !== null && chainId !== undefined) {
            queryParameters['chain_id'] = <string><any>chainId;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1MetricInfo>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1MetricInfo>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get exchange metrics history.
     * @summary Historical metrics for the exchange
     * @param metricId Metric identifier (e.g., &#x60;TVL&#x60;, &#x60;STABLES_BRIDGED_USD&#x60;)
     * @param exchangeId Exchange identifier (e.g., &#x60;BINANCE&#x60;, &#x60;UNISWAP-V3-ETHEREUM&#x60;)
     * @param timeStart Starting time in ISO 8601
     * @param timeEnd Ending time in ISO 8601
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;1MIN&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1MIN&#x60;
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     */
    public v2MetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<object>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v2/metrics/exchange/history';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'metricId' is not null or undefined
        if (metricId === null || metricId === undefined) {
            throw new Error('Required parameter metricId was null or undefined when calling v2MetricsExchangeHistoryGet.');
        }

        // verify required parameter 'exchangeId' is not null or undefined
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v2MetricsExchangeHistoryGet.');
        }

        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }
        if (timeStart !== null && timeStart !== undefined) {
            queryParameters['time_start'] = timeStart.toISOString();
        }
        if (timeEnd !== null && timeEnd !== undefined) {
            queryParameters['time_end'] = timeEnd.toISOString();
        }
        if (timeFormat !== null && timeFormat !== undefined) {
            queryParameters['time_format'] = <string><any>timeFormat;
        }
        if (periodId !== null && periodId !== undefined) {
            queryParameters['period_id'] = <string><any>periodId;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<object>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<object>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get all metrics that are actually available for the specified exchange.
     * @summary Listing of metrics available for specific exchange
     * @param exchangeId Exchange identifier (e.g., BINANCE, UNISWAP-V3-ETHEREUM)
     */
    public v2MetricsExchangeListingGet(exchangeId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1MetricInfo>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v2/metrics/exchange/listing';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'exchangeId' is not null or undefined
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v2MetricsExchangeListingGet.');
        }

        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1MetricInfo>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1MetricInfo>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get all metrics available in the system.
     * @summary Listing of all supported metrics
     */
    public v2MetricsListingGet(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1MetricInfo>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v2/metrics/listing';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1MetricInfo>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1MetricInfo>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

}
