/**
 * REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as $ from 'jquery';
import * as models from '../model/models';
import { COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


export class MetricsApi {
    protected basePath = 'https://rest.coinapi.io';
    public defaultHeaders: Array<string> = [];
    public defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings = undefined;
    public configuration: Configuration = new Configuration();

    constructor(basePath?: string, configuration?: Configuration, defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
        if (defaultExtraJQueryAjaxSettings) {
            this.defaultExtraJQueryAjaxSettings = defaultExtraJQueryAjaxSettings;
        }
    }

    private extendObj<T1 extends object, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * Get current asset metrics.
     * @summary Current metrics for given asset
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets)
     * @param assetIdExternal Exchange asset identifier
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     */
    public v1MetricsAssetCurrentGet(metricId?: string, assetId?: string, assetIdExternal?: string, exchangeId?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1GeneralData>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/asset/current';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (assetId !== null && assetId !== undefined) {
            queryParameters['asset_id'] = <string><any>assetId;
        }
        if (assetIdExternal !== null && assetIdExternal !== undefined) {
            queryParameters['asset_id_external'] = <string><any>assetIdExternal;
        }
        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1GeneralData>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1GeneralData>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get asset metrics history.
     * @summary Historical metrics for asset
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param assetId Asset identifier (from the Metadata -&gt; Assets)
     * @param assetIdExternal Exchange asset identifier
     * @param timeStart Starting time in ISO 8601
     * @param timeEnd Ending time in ISO 8601
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     */
    public v1MetricsAssetHistoryGet(metricId: string, exchangeId: string, assetId?: string, assetIdExternal?: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1MetricData>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/asset/history';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'metricId' is not null or undefined
        if (metricId === null || metricId === undefined) {
            throw new Error('Required parameter metricId was null or undefined when calling v1MetricsAssetHistoryGet.');
        }

        // verify required parameter 'exchangeId' is not null or undefined
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v1MetricsAssetHistoryGet.');
        }

        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (assetId !== null && assetId !== undefined) {
            queryParameters['asset_id'] = <string><any>assetId;
        }
        if (assetIdExternal !== null && assetIdExternal !== undefined) {
            queryParameters['asset_id_external'] = <string><any>assetIdExternal;
        }
        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }
        if (timeStart !== null && timeStart !== undefined) {
            queryParameters['time_start'] = timeStart.toISOString();
        }
        if (timeEnd !== null && timeEnd !== undefined) {
            queryParameters['time_end'] = timeEnd.toISOString();
        }
        if (timeFormat !== null && timeFormat !== undefined) {
            queryParameters['time_format'] = <string><any>timeFormat;
        }
        if (periodId !== null && periodId !== undefined) {
            queryParameters['period_id'] = <string><any>periodId;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1MetricData>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1MetricData>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get data metrics for asset.
     * @summary Listing of all supported metrics for asset
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param chainId Chain identifier
     * @param networkId Network identifier
     * @param assetId Asset identifier (from the Metadata -&gt; Assets)
     * @param assetIdExternal The asset external identifier
     */
    public v1MetricsAssetListingGet(metricId?: string, exchangeId?: string, chainId?: string, networkId?: string, assetId?: string, assetIdExternal?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1ListingItem>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/asset/listing';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }
        if (chainId !== null && chainId !== undefined) {
            queryParameters['chain_id'] = <string><any>chainId;
        }
        if (networkId !== null && networkId !== undefined) {
            queryParameters['network_id'] = <string><any>networkId;
        }
        if (assetId !== null && assetId !== undefined) {
            queryParameters['asset_id'] = <string><any>assetId;
        }
        if (assetIdExternal !== null && assetIdExternal !== undefined) {
            queryParameters['asset_id_external'] = <string><any>assetIdExternal;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1ListingItem>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1ListingItem>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get current exchange metrics values.
     * @summary Current metrics for given exchange
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing)
     */
    public v1MetricsExchangeCurrentGet(exchangeId: string, metricId?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1GeneralData>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/exchange/current';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'exchangeId' is not null or undefined
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v1MetricsExchangeCurrentGet.');
        }

        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1GeneralData>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1GeneralData>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get exchange metrics history.
     * @summary Historical metrics for the exchange
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param timeStart Starting time in ISO 8601
     * @param timeEnd Ending time in ISO 8601
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     */
    public v1MetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1MetricData>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/exchange/history';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'metricId' is not null or undefined
        if (metricId === null || metricId === undefined) {
            throw new Error('Required parameter metricId was null or undefined when calling v1MetricsExchangeHistoryGet.');
        }

        // verify required parameter 'exchangeId' is not null or undefined
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v1MetricsExchangeHistoryGet.');
        }

        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }
        if (timeStart !== null && timeStart !== undefined) {
            queryParameters['time_start'] = timeStart.toISOString();
        }
        if (timeEnd !== null && timeEnd !== undefined) {
            queryParameters['time_end'] = timeEnd.toISOString();
        }
        if (timeFormat !== null && timeFormat !== undefined) {
            queryParameters['time_format'] = <string><any>timeFormat;
        }
        if (periodId !== null && periodId !== undefined) {
            queryParameters['period_id'] = <string><any>periodId;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1MetricData>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1MetricData>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get data metrics for exchange.
     * @summary Listing of all supported exchange metrics
     * @param exchangeId The exchange identifier (from the Metadata -&gt; Exchanges)
     * @param metricId The metric identifier (from the Metrics -&gt; Listing)
     */
    public v1MetricsExchangeListingGet(exchangeId: string, metricId?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1ListingItem>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/exchange/listing';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'exchangeId' is not null or undefined
        if (exchangeId === null || exchangeId === undefined) {
            throw new Error('Required parameter exchangeId was null or undefined when calling v1MetricsExchangeListingGet.');
        }

        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1ListingItem>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1ListingItem>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get all data metrics.
     * @summary Listing of all supported metrics by CoinAPI
     */
    public v1MetricsListingGet(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1Metric>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/listing';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1Metric>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1Metric>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get current symbol metrics.
     * @summary Current metrics for given symbol
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols)
     * @param exchangeId Exchange id (from the Metadata -&gt; Exchanges)
     */
    public v1MetricsSymbolCurrentGet(metricId?: string, symbolId?: string, exchangeId?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1GeneralData>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/symbol/current';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (symbolId !== null && symbolId !== undefined) {
            queryParameters['symbol_id'] = <string><any>symbolId;
        }
        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1GeneralData>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1GeneralData>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get symbol metrics history.
     * @summary Historical metrics for symbol
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols)
     * @param timeStart Starting time in ISO 8601
     * @param timeEnd Ending time in ISO 8601
     * @param timeFormat If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60;
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     */
    public v1MetricsSymbolHistoryGet(metricId: string, symbolId: string, timeStart?: string, timeEnd?: string, timeFormat?: string, periodId?: string, limit?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1MetricData>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/symbol/history';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'metricId' is not null or undefined
        if (metricId === null || metricId === undefined) {
            throw new Error('Required parameter metricId was null or undefined when calling v1MetricsSymbolHistoryGet.');
        }

        // verify required parameter 'symbolId' is not null or undefined
        if (symbolId === null || symbolId === undefined) {
            throw new Error('Required parameter symbolId was null or undefined when calling v1MetricsSymbolHistoryGet.');
        }

        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (symbolId !== null && symbolId !== undefined) {
            queryParameters['symbol_id'] = <string><any>symbolId;
        }
        if (timeStart !== null && timeStart !== undefined) {
            queryParameters['time_start'] = timeStart.toISOString();
        }
        if (timeEnd !== null && timeEnd !== undefined) {
            queryParameters['time_end'] = timeEnd.toISOString();
        }
        if (timeFormat !== null && timeFormat !== undefined) {
            queryParameters['time_format'] = <string><any>timeFormat;
        }
        if (periodId !== null && periodId !== undefined) {
            queryParameters['period_id'] = <string><any>periodId;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1MetricData>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1MetricData>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * Get data metrics for symbol.
     * @summary Listing of all supported metrics for symbol
     * @param metricId Metric identifier (from the Metrics -&gt; Listing)
     * @param exchangeId Exchange identifier (from the Metadata -&gt; Exchanges)
     * @param symbolId Symbol identifier (from the Metadata -&gt; Symbols)
     */
    public v1MetricsSymbolListingGet(metricId?: string, exchangeId?: string, symbolId?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.V1ListingItem>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/metrics/symbol/listing';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (metricId !== null && metricId !== undefined) {
            queryParameters['metric_id'] = <string><any>metricId;
        }
        if (exchangeId !== null && exchangeId !== undefined) {
            queryParameters['exchange_id'] = <string><any>exchangeId;
        }
        if (symbolId !== null && symbolId !== undefined) {
            queryParameters['symbol_id'] = <string><any>symbolId;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (ApiKey) required
        if (this.configuration.apiKey) {
            headerParams['X-CoinAPI-Key'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.V1ListingItem>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.V1ListingItem>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

}
