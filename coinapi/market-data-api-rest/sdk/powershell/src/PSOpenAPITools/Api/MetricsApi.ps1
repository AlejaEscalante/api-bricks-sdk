#
# REST API
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
# Version: v1
# Contact: support@apibricks.io
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

Current metrics for given asset

.DESCRIPTION

No description available.

.PARAMETER MetricId
Metric identifier (from the Metrics -> Listing)

.PARAMETER AssetId
Asset identifier (from the Metadata -> Assets)

.PARAMETER AssetIdExternal
Exchange asset identifier

.PARAMETER ExchangeId
Exchange identifier (from the Metadata -> Exchanges)

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1GeneralData[]
#>
function Invoke-V1MetricsAssetCurrentGet {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${MetricId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AssetId},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AssetIdExternal},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ExchangeId},
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsAssetCurrentGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/asset/current'

        if ($MetricId) {
            $LocalVarQueryParameters['metric_id'] = $MetricId
        }

        if ($AssetId) {
            $LocalVarQueryParameters['asset_id'] = $AssetId
        }

        if ($AssetIdExternal) {
            $LocalVarQueryParameters['asset_id_external'] = $AssetIdExternal
        }

        if ($ExchangeId) {
            $LocalVarQueryParameters['exchange_id'] = $ExchangeId
        }

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1GeneralData[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Historical metrics for asset

.DESCRIPTION

No description available.

.PARAMETER MetricId
Metric identifier (from the Metrics -> Listing)

.PARAMETER ExchangeId
Exchange identifier (from the Metadata -> Exchanges)

.PARAMETER AssetId
Asset identifier (from the Metadata -> Assets)

.PARAMETER AssetIdExternal
Exchange asset identifier

.PARAMETER TimeStart
Starting time in ISO 8601

.PARAMETER TimeEnd
Ending time in ISO 8601

.PARAMETER TimeFormat
If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)

.PARAMETER PeriodId
Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`

.PARAMETER Limit
Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1MetricData[]
#>
function Invoke-V1MetricsAssetHistoryGet {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${MetricId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ExchangeId},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AssetId},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AssetIdExternal},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[System.DateTime]]
        ${TimeStart},
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[System.DateTime]]
        ${TimeEnd},
        [Parameter(Position = 6, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${TimeFormat},
        [Parameter(Position = 7, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${PeriodId},
        [Parameter(Position = 8, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[Int32]]
        ${Limit},
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsAssetHistoryGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/asset/history'

        if (!$MetricId) {
            throw "Error! The required parameter `MetricId` missing when calling v1MetricsAssetHistoryGet."
        }
        $LocalVarQueryParameters['metric_id'] = $MetricId

        if ($AssetId) {
            $LocalVarQueryParameters['asset_id'] = $AssetId
        }

        if ($AssetIdExternal) {
            $LocalVarQueryParameters['asset_id_external'] = $AssetIdExternal
        }

        if (!$ExchangeId) {
            throw "Error! The required parameter `ExchangeId` missing when calling v1MetricsAssetHistoryGet."
        }
        $LocalVarQueryParameters['exchange_id'] = $ExchangeId

        if ($TimeStart) {
            $LocalVarQueryParameters['time_start'] = $TimeStart
        }

        if ($TimeEnd) {
            $LocalVarQueryParameters['time_end'] = $TimeEnd
        }

        if ($TimeFormat) {
            $LocalVarQueryParameters['time_format'] = $TimeFormat
        }

        if ($PeriodId) {
            $LocalVarQueryParameters['period_id'] = $PeriodId
        }

        if ($Limit) {
            $LocalVarQueryParameters['limit'] = $Limit
        }

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1MetricData[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Listing of all supported metrics for asset

.DESCRIPTION

No description available.

.PARAMETER MetricId
Metric identifier (from the Metrics -> Listing)

.PARAMETER ExchangeId
Exchange identifier (from the Metadata -> Exchanges)

.PARAMETER ChainId
Chain identifier

.PARAMETER NetworkId
Network identifier

.PARAMETER AssetId
Asset identifier (from the Metadata -> Assets)

.PARAMETER AssetIdExternal
The asset external identifier

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1ListingItem[]
#>
function Invoke-V1MetricsAssetListingGet {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${MetricId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ExchangeId},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ChainId},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${NetworkId},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AssetId},
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${AssetIdExternal},
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsAssetListingGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/asset/listing'

        if ($MetricId) {
            $LocalVarQueryParameters['metric_id'] = $MetricId
        }

        if ($ExchangeId) {
            $LocalVarQueryParameters['exchange_id'] = $ExchangeId
        }

        if ($ChainId) {
            $LocalVarQueryParameters['chain_id'] = $ChainId
        }

        if ($NetworkId) {
            $LocalVarQueryParameters['network_id'] = $NetworkId
        }

        if ($AssetId) {
            $LocalVarQueryParameters['asset_id'] = $AssetId
        }

        if ($AssetIdExternal) {
            $LocalVarQueryParameters['asset_id_external'] = $AssetIdExternal
        }

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1ListingItem[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Current metrics for given exchange

.DESCRIPTION

No description available.

.PARAMETER ExchangeId
The exchange identifier (from the Metadata -> Exchanges)

.PARAMETER MetricId
The metric identifier (from the Metrics -> Listing)

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1GeneralData[]
#>
function Invoke-V1MetricsExchangeCurrentGet {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ExchangeId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${MetricId},
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsExchangeCurrentGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/exchange/current'

        if ($MetricId) {
            $LocalVarQueryParameters['metric_id'] = $MetricId
        }

        if (!$ExchangeId) {
            throw "Error! The required parameter `ExchangeId` missing when calling v1MetricsExchangeCurrentGet."
        }
        $LocalVarQueryParameters['exchange_id'] = $ExchangeId

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1GeneralData[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Historical metrics for the exchange

.DESCRIPTION

No description available.

.PARAMETER MetricId
Metric identifier (from the Metrics -> Listing)

.PARAMETER ExchangeId
Exchange identifier (from the Metadata -> Exchanges)

.PARAMETER TimeStart
Starting time in ISO 8601

.PARAMETER TimeEnd
Ending time in ISO 8601

.PARAMETER TimeFormat
If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)

.PARAMETER PeriodId
Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`

.PARAMETER Limit
Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1MetricData[]
#>
function Invoke-V1MetricsExchangeHistoryGet {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${MetricId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ExchangeId},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[System.DateTime]]
        ${TimeStart},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[System.DateTime]]
        ${TimeEnd},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${TimeFormat},
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${PeriodId},
        [Parameter(Position = 6, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[Int32]]
        ${Limit},
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsExchangeHistoryGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/exchange/history'

        if (!$MetricId) {
            throw "Error! The required parameter `MetricId` missing when calling v1MetricsExchangeHistoryGet."
        }
        $LocalVarQueryParameters['metric_id'] = $MetricId

        if (!$ExchangeId) {
            throw "Error! The required parameter `ExchangeId` missing when calling v1MetricsExchangeHistoryGet."
        }
        $LocalVarQueryParameters['exchange_id'] = $ExchangeId

        if ($TimeStart) {
            $LocalVarQueryParameters['time_start'] = $TimeStart
        }

        if ($TimeEnd) {
            $LocalVarQueryParameters['time_end'] = $TimeEnd
        }

        if ($TimeFormat) {
            $LocalVarQueryParameters['time_format'] = $TimeFormat
        }

        if ($PeriodId) {
            $LocalVarQueryParameters['period_id'] = $PeriodId
        }

        if ($Limit) {
            $LocalVarQueryParameters['limit'] = $Limit
        }

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1MetricData[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Listing of all supported exchange metrics

.DESCRIPTION

No description available.

.PARAMETER ExchangeId
The exchange identifier (from the Metadata -> Exchanges)

.PARAMETER MetricId
The metric identifier (from the Metrics -> Listing)

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1ListingItem[]
#>
function Invoke-V1MetricsExchangeListingGet {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ExchangeId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${MetricId},
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsExchangeListingGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/exchange/listing'

        if ($MetricId) {
            $LocalVarQueryParameters['metric_id'] = $MetricId
        }

        if (!$ExchangeId) {
            throw "Error! The required parameter `ExchangeId` missing when calling v1MetricsExchangeListingGet."
        }
        $LocalVarQueryParameters['exchange_id'] = $ExchangeId

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1ListingItem[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Listing of all supported metrics by CoinAPI

.DESCRIPTION

No description available.

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1Metric[]
#>
function Invoke-V1MetricsListingGet {
    [CmdletBinding()]
    Param (
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsListingGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/listing'

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1Metric[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Current metrics for given symbol

.DESCRIPTION

No description available.

.PARAMETER MetricId
Metric identifier (from the Metrics -> Listing)

.PARAMETER SymbolId
Symbol identifier (from the Metadata -> Symbols)

.PARAMETER ExchangeId
Exchange id (from the Metadata -> Exchanges)

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1GeneralData[]
#>
function Invoke-V1MetricsSymbolCurrentGet {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${MetricId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${SymbolId},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ExchangeId},
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsSymbolCurrentGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/symbol/current'

        if ($MetricId) {
            $LocalVarQueryParameters['metric_id'] = $MetricId
        }

        if ($SymbolId) {
            $LocalVarQueryParameters['symbol_id'] = $SymbolId
        }

        if ($ExchangeId) {
            $LocalVarQueryParameters['exchange_id'] = $ExchangeId
        }

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1GeneralData[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Historical metrics for symbol

.DESCRIPTION

No description available.

.PARAMETER MetricId
Metric identifier (from the Metrics -> Listing)

.PARAMETER SymbolId
Symbol identifier (from the Metadata -> Symbols)

.PARAMETER TimeStart
Starting time in ISO 8601

.PARAMETER TimeEnd
Ending time in ISO 8601

.PARAMETER TimeFormat
If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec)

.PARAMETER PeriodId
Identifier of requested timeseries period (e.g. `5SEC` or `2MTH`), default value is `1SEC`

.PARAMETER Limit
Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1MetricData[]
#>
function Invoke-V1MetricsSymbolHistoryGet {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${MetricId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${SymbolId},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[System.DateTime]]
        ${TimeStart},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[System.DateTime]]
        ${TimeEnd},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${TimeFormat},
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${PeriodId},
        [Parameter(Position = 6, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [System.Nullable[Int32]]
        ${Limit},
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsSymbolHistoryGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/symbol/history'

        if (!$MetricId) {
            throw "Error! The required parameter `MetricId` missing when calling v1MetricsSymbolHistoryGet."
        }
        $LocalVarQueryParameters['metric_id'] = $MetricId

        if (!$SymbolId) {
            throw "Error! The required parameter `SymbolId` missing when calling v1MetricsSymbolHistoryGet."
        }
        $LocalVarQueryParameters['symbol_id'] = $SymbolId

        if ($TimeStart) {
            $LocalVarQueryParameters['time_start'] = $TimeStart
        }

        if ($TimeEnd) {
            $LocalVarQueryParameters['time_end'] = $TimeEnd
        }

        if ($TimeFormat) {
            $LocalVarQueryParameters['time_format'] = $TimeFormat
        }

        if ($PeriodId) {
            $LocalVarQueryParameters['period_id'] = $PeriodId
        }

        if ($Limit) {
            $LocalVarQueryParameters['limit'] = $Limit
        }

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1MetricData[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

<#
.SYNOPSIS

Listing of all supported metrics for symbol

.DESCRIPTION

No description available.

.PARAMETER MetricId
Metric identifier (from the Metrics -> Listing)

.PARAMETER ExchangeId
Exchange identifier (from the Metadata -> Exchanges)

.PARAMETER SymbolId
Symbol identifier (from the Metadata -> Symbols)

.PARAMETER ReturnType

Select the return type (optional): text/plain, application/json, text/json, application/x-msgpack

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

V1ListingItem[]
#>
function Invoke-V1MetricsSymbolListingGet {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${MetricId},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${ExchangeId},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
        [String]
        ${SymbolId},
        [String]
        [ValidateSet("text/plain", "application/json", "text/json", "application/x-msgpack")]
        $ReturnType,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-V1MetricsSymbolListingGet' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $Configuration = Get-Configuration
        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('text/plain', 'application/json', 'text/json', 'application/x-msgpack')

        if ($ReturnType) {
            # use the return type (MIME) provided by the user
            $LocalVarAccepts = @($ReturnType)
        }

        $LocalVarUri = '/v1/metrics/symbol/listing'

        if ($MetricId) {
            $LocalVarQueryParameters['metric_id'] = $MetricId
        }

        if ($ExchangeId) {
            $LocalVarQueryParameters['exchange_id'] = $ExchangeId
        }

        if ($SymbolId) {
            $LocalVarQueryParameters['symbol_id'] = $SymbolId
        }

        if ($Configuration["ApiKeyPrefix"] -and $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]) {
            $apiKeyPrefix = $Configuration["ApiKeyPrefix"]["X-CoinAPI-Key"]
        } else {
            $apiKeyPrefix = ""
        }
        if ($Configuration["ApiKey"] -and $Configuration["ApiKey"]["X-CoinAPI-Key"]) {
            $LocalVarHeaderParameters['X-CoinAPI-Key'] = $apiKeyPrefix + $Configuration["ApiKey"]["X-CoinAPI-Key"]
            Write-Verbose ("Using API key 'X-CoinAPI-Key' in the header for authentication in {0}" -f $MyInvocation.MyCommand)
        }

        $LocalVarResult = Invoke-ApiClient -Method 'GET' `
                                -Uri $LocalVarUri `
                                -Accepts $LocalVarAccepts `
                                -ContentTypes $LocalVarContentTypes `
                                -Body $LocalVarBodyParameter `
                                -HeaderParameters $LocalVarHeaderParameters `
                                -QueryParameters $LocalVarQueryParameters `
                                -FormParameters $LocalVarFormParameters `
                                -CookieParameters $LocalVarCookieParameters `
                                -ReturnType "V1ListingItem[]" `
                                -IsBodyNullable $false

        if ($WithHttpInfo.IsPresent) {
            return $LocalVarResult
        } else {
            return $LocalVarResult["Response"]
        }
    }
}

