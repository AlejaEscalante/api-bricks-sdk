<?php
/**
 * MetricsApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * MetricsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MetricsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'v1MetricsAssetCurrentGet' => [
            'application/json',
        ],
        'v1MetricsAssetHistoryGet' => [
            'application/json',
        ],
        'v1MetricsAssetListingGet' => [
            'application/json',
        ],
        'v1MetricsExchangeCurrentGet' => [
            'application/json',
        ],
        'v1MetricsExchangeHistoryGet' => [
            'application/json',
        ],
        'v1MetricsExchangeListingGet' => [
            'application/json',
        ],
        'v1MetricsListingGet' => [
            'application/json',
        ],
        'v1MetricsSymbolCurrentGet' => [
            'application/json',
        ],
        'v1MetricsSymbolHistoryGet' => [
            'application/json',
        ],
        'v1MetricsSymbolListingGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation v1MetricsAssetCurrentGet
     *
     * Current metrics for given asset
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetCurrentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1GeneralData[]
     */
    public function v1MetricsAssetCurrentGet($metric_id = null, $asset_id = null, $asset_id_external = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsAssetCurrentGet'][0])
    {
        list($response) = $this->v1MetricsAssetCurrentGetWithHttpInfo($metric_id, $asset_id, $asset_id_external, $exchange_id, $contentType);
        return $response;
    }

    /**
     * Operation v1MetricsAssetCurrentGetWithHttpInfo
     *
     * Current metrics for given asset
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetCurrentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1GeneralData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsAssetCurrentGetWithHttpInfo($metric_id = null, $asset_id = null, $asset_id_external = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsAssetCurrentGet'][0])
    {
        $request = $this->v1MetricsAssetCurrentGetRequest($metric_id, $asset_id, $asset_id_external, $exchange_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1GeneralData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1GeneralData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1GeneralData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsAssetCurrentGetAsync
     *
     * Current metrics for given asset
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsAssetCurrentGetAsync($metric_id = null, $asset_id = null, $asset_id_external = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsAssetCurrentGet'][0])
    {
        return $this->v1MetricsAssetCurrentGetAsyncWithHttpInfo($metric_id, $asset_id, $asset_id_external, $exchange_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsAssetCurrentGetAsyncWithHttpInfo
     *
     * Current metrics for given asset
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsAssetCurrentGetAsyncWithHttpInfo($metric_id = null, $asset_id = null, $asset_id_external = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsAssetCurrentGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1GeneralData[]';
        $request = $this->v1MetricsAssetCurrentGetRequest($metric_id, $asset_id, $asset_id_external, $exchange_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsAssetCurrentGet'
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsAssetCurrentGetRequest($metric_id = null, $asset_id = null, $asset_id_external = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsAssetCurrentGet'][0])
    {






        $resourcePath = '/v1/metrics/asset/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metric_id,
            'metric_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id,
            'asset_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id_external,
            'asset_id_external', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exchange_id,
            'exchange_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1MetricsAssetHistoryGet
     *
     * Historical metrics for asset
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetHistoryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1MetricData[]
     */
    public function v1MetricsAssetHistoryGet($metric_id, $exchange_id, $asset_id = null, $asset_id_external = null, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsAssetHistoryGet'][0])
    {
        list($response) = $this->v1MetricsAssetHistoryGetWithHttpInfo($metric_id, $exchange_id, $asset_id, $asset_id_external, $time_start, $time_end, $time_format, $period_id, $limit, $contentType);
        return $response;
    }

    /**
     * Operation v1MetricsAssetHistoryGetWithHttpInfo
     *
     * Historical metrics for asset
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetHistoryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1MetricData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsAssetHistoryGetWithHttpInfo($metric_id, $exchange_id, $asset_id = null, $asset_id_external = null, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsAssetHistoryGet'][0])
    {
        $request = $this->v1MetricsAssetHistoryGetRequest($metric_id, $exchange_id, $asset_id, $asset_id_external, $time_start, $time_end, $time_format, $period_id, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1MetricData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1MetricData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1MetricData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsAssetHistoryGetAsync
     *
     * Historical metrics for asset
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsAssetHistoryGetAsync($metric_id, $exchange_id, $asset_id = null, $asset_id_external = null, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsAssetHistoryGet'][0])
    {
        return $this->v1MetricsAssetHistoryGetAsyncWithHttpInfo($metric_id, $exchange_id, $asset_id, $asset_id_external, $time_start, $time_end, $time_format, $period_id, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsAssetHistoryGetAsyncWithHttpInfo
     *
     * Historical metrics for asset
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsAssetHistoryGetAsyncWithHttpInfo($metric_id, $exchange_id, $asset_id = null, $asset_id_external = null, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsAssetHistoryGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1MetricData[]';
        $request = $this->v1MetricsAssetHistoryGetRequest($metric_id, $exchange_id, $asset_id, $asset_id_external, $time_start, $time_end, $time_format, $period_id, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsAssetHistoryGet'
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external Exchange asset identifier (optional)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsAssetHistoryGetRequest($metric_id, $exchange_id, $asset_id = null, $asset_id_external = null, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsAssetHistoryGet'][0])
    {

        // verify the required parameter 'metric_id' is set
        if ($metric_id === null || (is_array($metric_id) && count($metric_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $metric_id when calling v1MetricsAssetHistoryGet'
            );
        }

        // verify the required parameter 'exchange_id' is set
        if ($exchange_id === null || (is_array($exchange_id) && count($exchange_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange_id when calling v1MetricsAssetHistoryGet'
            );
        }









        $resourcePath = '/v1/metrics/asset/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metric_id,
            'metric_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id,
            'asset_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id_external,
            'asset_id_external', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exchange_id,
            'exchange_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_start,
            'time_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_end,
            'time_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_format,
            'time_format', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period_id,
            'period_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1MetricsAssetListingGet
     *
     * Listing of all supported metrics for asset
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $chain_id Chain identifier (optional)
     * @param  string|null $network_id Network identifier (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external The asset external identifier (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetListingGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1ListingItem[]
     */
    public function v1MetricsAssetListingGet($metric_id = null, $exchange_id = null, $chain_id = null, $network_id = null, $asset_id = null, $asset_id_external = null, string $contentType = self::contentTypes['v1MetricsAssetListingGet'][0])
    {
        list($response) = $this->v1MetricsAssetListingGetWithHttpInfo($metric_id, $exchange_id, $chain_id, $network_id, $asset_id, $asset_id_external, $contentType);
        return $response;
    }

    /**
     * Operation v1MetricsAssetListingGetWithHttpInfo
     *
     * Listing of all supported metrics for asset
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $chain_id Chain identifier (optional)
     * @param  string|null $network_id Network identifier (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external The asset external identifier (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetListingGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1ListingItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsAssetListingGetWithHttpInfo($metric_id = null, $exchange_id = null, $chain_id = null, $network_id = null, $asset_id = null, $asset_id_external = null, string $contentType = self::contentTypes['v1MetricsAssetListingGet'][0])
    {
        $request = $this->v1MetricsAssetListingGetRequest($metric_id, $exchange_id, $chain_id, $network_id, $asset_id, $asset_id_external, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1ListingItem[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1ListingItem[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1ListingItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsAssetListingGetAsync
     *
     * Listing of all supported metrics for asset
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $chain_id Chain identifier (optional)
     * @param  string|null $network_id Network identifier (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external The asset external identifier (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsAssetListingGetAsync($metric_id = null, $exchange_id = null, $chain_id = null, $network_id = null, $asset_id = null, $asset_id_external = null, string $contentType = self::contentTypes['v1MetricsAssetListingGet'][0])
    {
        return $this->v1MetricsAssetListingGetAsyncWithHttpInfo($metric_id, $exchange_id, $chain_id, $network_id, $asset_id, $asset_id_external, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsAssetListingGetAsyncWithHttpInfo
     *
     * Listing of all supported metrics for asset
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $chain_id Chain identifier (optional)
     * @param  string|null $network_id Network identifier (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external The asset external identifier (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsAssetListingGetAsyncWithHttpInfo($metric_id = null, $exchange_id = null, $chain_id = null, $network_id = null, $asset_id = null, $asset_id_external = null, string $contentType = self::contentTypes['v1MetricsAssetListingGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1ListingItem[]';
        $request = $this->v1MetricsAssetListingGetRequest($metric_id, $exchange_id, $chain_id, $network_id, $asset_id, $asset_id_external, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsAssetListingGet'
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $chain_id Chain identifier (optional)
     * @param  string|null $network_id Network identifier (optional)
     * @param  string|null $asset_id Asset identifier (from the Metadata -&gt; Assets) (optional)
     * @param  string|null $asset_id_external The asset external identifier (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsAssetListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsAssetListingGetRequest($metric_id = null, $exchange_id = null, $chain_id = null, $network_id = null, $asset_id = null, $asset_id_external = null, string $contentType = self::contentTypes['v1MetricsAssetListingGet'][0])
    {








        $resourcePath = '/v1/metrics/asset/listing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metric_id,
            'metric_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exchange_id,
            'exchange_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $chain_id,
            'chain_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_id,
            'network_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id,
            'asset_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id_external,
            'asset_id_external', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1MetricsExchangeCurrentGet
     *
     * Current metrics for given exchange
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeCurrentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1GeneralData[]
     */
    public function v1MetricsExchangeCurrentGet($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeCurrentGet'][0])
    {
        list($response) = $this->v1MetricsExchangeCurrentGetWithHttpInfo($exchange_id, $metric_id, $contentType);
        return $response;
    }

    /**
     * Operation v1MetricsExchangeCurrentGetWithHttpInfo
     *
     * Current metrics for given exchange
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeCurrentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1GeneralData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsExchangeCurrentGetWithHttpInfo($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeCurrentGet'][0])
    {
        $request = $this->v1MetricsExchangeCurrentGetRequest($exchange_id, $metric_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1GeneralData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1GeneralData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1GeneralData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsExchangeCurrentGetAsync
     *
     * Current metrics for given exchange
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsExchangeCurrentGetAsync($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeCurrentGet'][0])
    {
        return $this->v1MetricsExchangeCurrentGetAsyncWithHttpInfo($exchange_id, $metric_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsExchangeCurrentGetAsyncWithHttpInfo
     *
     * Current metrics for given exchange
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsExchangeCurrentGetAsyncWithHttpInfo($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeCurrentGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1GeneralData[]';
        $request = $this->v1MetricsExchangeCurrentGetRequest($exchange_id, $metric_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsExchangeCurrentGet'
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsExchangeCurrentGetRequest($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeCurrentGet'][0])
    {

        // verify the required parameter 'exchange_id' is set
        if ($exchange_id === null || (is_array($exchange_id) && count($exchange_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange_id when calling v1MetricsExchangeCurrentGet'
            );
        }



        $resourcePath = '/v1/metrics/exchange/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metric_id,
            'metric_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exchange_id,
            'exchange_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1MetricsExchangeHistoryGet
     *
     * Historical metrics for the exchange
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeHistoryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1MetricData[]
     */
    public function v1MetricsExchangeHistoryGet($metric_id, $exchange_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsExchangeHistoryGet'][0])
    {
        list($response) = $this->v1MetricsExchangeHistoryGetWithHttpInfo($metric_id, $exchange_id, $time_start, $time_end, $time_format, $period_id, $limit, $contentType);
        return $response;
    }

    /**
     * Operation v1MetricsExchangeHistoryGetWithHttpInfo
     *
     * Historical metrics for the exchange
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeHistoryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1MetricData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsExchangeHistoryGetWithHttpInfo($metric_id, $exchange_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsExchangeHistoryGet'][0])
    {
        $request = $this->v1MetricsExchangeHistoryGetRequest($metric_id, $exchange_id, $time_start, $time_end, $time_format, $period_id, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1MetricData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1MetricData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1MetricData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsExchangeHistoryGetAsync
     *
     * Historical metrics for the exchange
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsExchangeHistoryGetAsync($metric_id, $exchange_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsExchangeHistoryGet'][0])
    {
        return $this->v1MetricsExchangeHistoryGetAsyncWithHttpInfo($metric_id, $exchange_id, $time_start, $time_end, $time_format, $period_id, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsExchangeHistoryGetAsyncWithHttpInfo
     *
     * Historical metrics for the exchange
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsExchangeHistoryGetAsyncWithHttpInfo($metric_id, $exchange_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsExchangeHistoryGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1MetricData[]';
        $request = $this->v1MetricsExchangeHistoryGetRequest($metric_id, $exchange_id, $time_start, $time_end, $time_format, $period_id, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsExchangeHistoryGet'
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsExchangeHistoryGetRequest($metric_id, $exchange_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsExchangeHistoryGet'][0])
    {

        // verify the required parameter 'metric_id' is set
        if ($metric_id === null || (is_array($metric_id) && count($metric_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $metric_id when calling v1MetricsExchangeHistoryGet'
            );
        }

        // verify the required parameter 'exchange_id' is set
        if ($exchange_id === null || (is_array($exchange_id) && count($exchange_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange_id when calling v1MetricsExchangeHistoryGet'
            );
        }







        $resourcePath = '/v1/metrics/exchange/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metric_id,
            'metric_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exchange_id,
            'exchange_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_start,
            'time_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_end,
            'time_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_format,
            'time_format', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period_id,
            'period_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1MetricsExchangeListingGet
     *
     * Listing of all supported exchange metrics
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeListingGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1ListingItem[]
     */
    public function v1MetricsExchangeListingGet($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeListingGet'][0])
    {
        list($response) = $this->v1MetricsExchangeListingGetWithHttpInfo($exchange_id, $metric_id, $contentType);
        return $response;
    }

    /**
     * Operation v1MetricsExchangeListingGetWithHttpInfo
     *
     * Listing of all supported exchange metrics
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeListingGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1ListingItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsExchangeListingGetWithHttpInfo($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeListingGet'][0])
    {
        $request = $this->v1MetricsExchangeListingGetRequest($exchange_id, $metric_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1ListingItem[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1ListingItem[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1ListingItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsExchangeListingGetAsync
     *
     * Listing of all supported exchange metrics
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsExchangeListingGetAsync($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeListingGet'][0])
    {
        return $this->v1MetricsExchangeListingGetAsyncWithHttpInfo($exchange_id, $metric_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsExchangeListingGetAsyncWithHttpInfo
     *
     * Listing of all supported exchange metrics
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsExchangeListingGetAsyncWithHttpInfo($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeListingGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1ListingItem[]';
        $request = $this->v1MetricsExchangeListingGetRequest($exchange_id, $metric_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsExchangeListingGet'
     *
     * @param  string $exchange_id The exchange identifier (from the Metadata -&gt; Exchanges) (required)
     * @param  string|null $metric_id The metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsExchangeListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsExchangeListingGetRequest($exchange_id, $metric_id = null, string $contentType = self::contentTypes['v1MetricsExchangeListingGet'][0])
    {

        // verify the required parameter 'exchange_id' is set
        if ($exchange_id === null || (is_array($exchange_id) && count($exchange_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange_id when calling v1MetricsExchangeListingGet'
            );
        }



        $resourcePath = '/v1/metrics/exchange/listing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metric_id,
            'metric_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exchange_id,
            'exchange_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1MetricsListingGet
     *
     * Listing of all supported metrics by CoinAPI
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsListingGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1Metric[]
     */
    public function v1MetricsListingGet(string $contentType = self::contentTypes['v1MetricsListingGet'][0])
    {
        list($response) = $this->v1MetricsListingGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation v1MetricsListingGetWithHttpInfo
     *
     * Listing of all supported metrics by CoinAPI
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsListingGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1Metric[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsListingGetWithHttpInfo(string $contentType = self::contentTypes['v1MetricsListingGet'][0])
    {
        $request = $this->v1MetricsListingGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1Metric[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1Metric[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1Metric[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsListingGetAsync
     *
     * Listing of all supported metrics by CoinAPI
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsListingGetAsync(string $contentType = self::contentTypes['v1MetricsListingGet'][0])
    {
        return $this->v1MetricsListingGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsListingGetAsyncWithHttpInfo
     *
     * Listing of all supported metrics by CoinAPI
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsListingGetAsyncWithHttpInfo(string $contentType = self::contentTypes['v1MetricsListingGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1Metric[]';
        $request = $this->v1MetricsListingGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsListingGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsListingGetRequest(string $contentType = self::contentTypes['v1MetricsListingGet'][0])
    {


        $resourcePath = '/v1/metrics/listing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1MetricsSymbolCurrentGet
     *
     * Current metrics for given symbol
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string|null $exchange_id Exchange id (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolCurrentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1GeneralData[]
     */
    public function v1MetricsSymbolCurrentGet($metric_id = null, $symbol_id = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsSymbolCurrentGet'][0])
    {
        list($response) = $this->v1MetricsSymbolCurrentGetWithHttpInfo($metric_id, $symbol_id, $exchange_id, $contentType);
        return $response;
    }

    /**
     * Operation v1MetricsSymbolCurrentGetWithHttpInfo
     *
     * Current metrics for given symbol
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string|null $exchange_id Exchange id (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolCurrentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1GeneralData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsSymbolCurrentGetWithHttpInfo($metric_id = null, $symbol_id = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsSymbolCurrentGet'][0])
    {
        $request = $this->v1MetricsSymbolCurrentGetRequest($metric_id, $symbol_id, $exchange_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1GeneralData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1GeneralData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1GeneralData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsSymbolCurrentGetAsync
     *
     * Current metrics for given symbol
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string|null $exchange_id Exchange id (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsSymbolCurrentGetAsync($metric_id = null, $symbol_id = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsSymbolCurrentGet'][0])
    {
        return $this->v1MetricsSymbolCurrentGetAsyncWithHttpInfo($metric_id, $symbol_id, $exchange_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsSymbolCurrentGetAsyncWithHttpInfo
     *
     * Current metrics for given symbol
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string|null $exchange_id Exchange id (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsSymbolCurrentGetAsyncWithHttpInfo($metric_id = null, $symbol_id = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsSymbolCurrentGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1GeneralData[]';
        $request = $this->v1MetricsSymbolCurrentGetRequest($metric_id, $symbol_id, $exchange_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsSymbolCurrentGet'
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string|null $exchange_id Exchange id (from the Metadata -&gt; Exchanges) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsSymbolCurrentGetRequest($metric_id = null, $symbol_id = null, $exchange_id = null, string $contentType = self::contentTypes['v1MetricsSymbolCurrentGet'][0])
    {





        $resourcePath = '/v1/metrics/symbol/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metric_id,
            'metric_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol_id,
            'symbol_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exchange_id,
            'exchange_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1MetricsSymbolHistoryGet
     *
     * Historical metrics for symbol
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolHistoryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1MetricData[]
     */
    public function v1MetricsSymbolHistoryGet($metric_id, $symbol_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsSymbolHistoryGet'][0])
    {
        list($response) = $this->v1MetricsSymbolHistoryGetWithHttpInfo($metric_id, $symbol_id, $time_start, $time_end, $time_format, $period_id, $limit, $contentType);
        return $response;
    }

    /**
     * Operation v1MetricsSymbolHistoryGetWithHttpInfo
     *
     * Historical metrics for symbol
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolHistoryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1MetricData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsSymbolHistoryGetWithHttpInfo($metric_id, $symbol_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsSymbolHistoryGet'][0])
    {
        $request = $this->v1MetricsSymbolHistoryGetRequest($metric_id, $symbol_id, $time_start, $time_end, $time_format, $period_id, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1MetricData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1MetricData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1MetricData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsSymbolHistoryGetAsync
     *
     * Historical metrics for symbol
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsSymbolHistoryGetAsync($metric_id, $symbol_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsSymbolHistoryGet'][0])
    {
        return $this->v1MetricsSymbolHistoryGetAsyncWithHttpInfo($metric_id, $symbol_id, $time_start, $time_end, $time_format, $period_id, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsSymbolHistoryGetAsyncWithHttpInfo
     *
     * Historical metrics for symbol
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsSymbolHistoryGetAsyncWithHttpInfo($metric_id, $symbol_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsSymbolHistoryGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1MetricData[]';
        $request = $this->v1MetricsSymbolHistoryGetRequest($metric_id, $symbol_id, $time_start, $time_end, $time_format, $period_id, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsSymbolHistoryGet'
     *
     * @param  string $metric_id Metric identifier (from the Metrics -&gt; Listing) (required)
     * @param  string $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (required)
     * @param  \DateTime|null $time_start Starting time in ISO 8601 (optional)
     * @param  \DateTime|null $time_end Ending time in ISO 8601 (optional)
     * @param  string|null $time_format If set, returned values will be in unix timestamp format (valid values: unix_sec, unix_millisec, unix_microsec, unix_nanosec) (optional)
     * @param  string|null $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;2MTH&#x60;), default value is &#x60;1SEC&#x60; (optional)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsSymbolHistoryGetRequest($metric_id, $symbol_id, $time_start = null, $time_end = null, $time_format = null, $period_id = null, $limit = 100, string $contentType = self::contentTypes['v1MetricsSymbolHistoryGet'][0])
    {

        // verify the required parameter 'metric_id' is set
        if ($metric_id === null || (is_array($metric_id) && count($metric_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $metric_id when calling v1MetricsSymbolHistoryGet'
            );
        }

        // verify the required parameter 'symbol_id' is set
        if ($symbol_id === null || (is_array($symbol_id) && count($symbol_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol_id when calling v1MetricsSymbolHistoryGet'
            );
        }







        $resourcePath = '/v1/metrics/symbol/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metric_id,
            'metric_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol_id,
            'symbol_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_start,
            'time_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_end,
            'time_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_format,
            'time_format', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period_id,
            'period_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1MetricsSymbolListingGet
     *
     * Listing of all supported metrics for symbol
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolListingGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V1ListingItem[]
     */
    public function v1MetricsSymbolListingGet($metric_id = null, $exchange_id = null, $symbol_id = null, string $contentType = self::contentTypes['v1MetricsSymbolListingGet'][0])
    {
        list($response) = $this->v1MetricsSymbolListingGetWithHttpInfo($metric_id, $exchange_id, $symbol_id, $contentType);
        return $response;
    }

    /**
     * Operation v1MetricsSymbolListingGetWithHttpInfo
     *
     * Listing of all supported metrics for symbol
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolListingGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V1ListingItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1MetricsSymbolListingGetWithHttpInfo($metric_id = null, $exchange_id = null, $symbol_id = null, string $contentType = self::contentTypes['v1MetricsSymbolListingGet'][0])
    {
        $request = $this->v1MetricsSymbolListingGetRequest($metric_id, $exchange_id, $symbol_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\V1ListingItem[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\V1ListingItem[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V1ListingItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1MetricsSymbolListingGetAsync
     *
     * Listing of all supported metrics for symbol
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsSymbolListingGetAsync($metric_id = null, $exchange_id = null, $symbol_id = null, string $contentType = self::contentTypes['v1MetricsSymbolListingGet'][0])
    {
        return $this->v1MetricsSymbolListingGetAsyncWithHttpInfo($metric_id, $exchange_id, $symbol_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1MetricsSymbolListingGetAsyncWithHttpInfo
     *
     * Listing of all supported metrics for symbol
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1MetricsSymbolListingGetAsyncWithHttpInfo($metric_id = null, $exchange_id = null, $symbol_id = null, string $contentType = self::contentTypes['v1MetricsSymbolListingGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V1ListingItem[]';
        $request = $this->v1MetricsSymbolListingGetRequest($metric_id, $exchange_id, $symbol_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1MetricsSymbolListingGet'
     *
     * @param  string|null $metric_id Metric identifier (from the Metrics -&gt; Listing) (optional)
     * @param  string|null $exchange_id Exchange identifier (from the Metadata -&gt; Exchanges) (optional)
     * @param  string|null $symbol_id Symbol identifier (from the Metadata -&gt; Symbols) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1MetricsSymbolListingGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1MetricsSymbolListingGetRequest($metric_id = null, $exchange_id = null, $symbol_id = null, string $contentType = self::contentTypes['v1MetricsSymbolListingGet'][0])
    {





        $resourcePath = '/v1/metrics/symbol/listing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metric_id,
            'metric_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exchange_id,
            'exchange_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol_id,
            'symbol_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-CoinAPI-Key');
        if ($apiKey !== null) {
            $headers['X-CoinAPI-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
