/**
 * CoinAPI Indexes REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as $ from 'jquery';
import * as models from '../model/models';
import { COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


export class IndexesApi {
    protected basePath = 'https://rest-api.indexes.coinapi.io';
    public defaultHeaders: Array<string> = [];
    public defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings = undefined;
    public configuration: Configuration = new Configuration();

    constructor(basePath?: string, configuration?: Configuration, defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
        if (defaultExtraJQueryAjaxSettings) {
            this.defaultExtraJQueryAjaxSettings = defaultExtraJQueryAjaxSettings;
        }
    }

    private extendObj<T1 extends object, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * 
     * @summary Returns all data inputs for a specific index definition
     * @param indexDefinitionId 
     */
    public v1IndexdefInputDataIndexDefinitionIdAllGet(indexDefinitionId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.IndexesIndexDefinitionInputData>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexdef/input-data/{index_definition_id}/all'.replace('{' + 'index_definition_id' + '}', encodeURIComponent(String(indexDefinitionId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'indexDefinitionId' is not null or undefined
        if (indexDefinitionId === null || indexDefinitionId === undefined) {
            throw new Error('Required parameter indexDefinitionId was null or undefined when calling v1IndexdefInputDataIndexDefinitionIdAllGet.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.IndexesIndexDefinitionInputData>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.IndexesIndexDefinitionInputData>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Returns data inputs for certain index definition and time
     * @param indexDefinitionId 
     * @param time 
     * @param enabledOnly 
     * @param pendingOnly 
     * @param filterAssetId 
     * @param withStatusInfo 
     */
    public v1IndexdefInputDataIndexDefinitionIdGet(indexDefinitionId: string, time?: string, enabledOnly?: boolean, pendingOnly?: boolean, filterAssetId?: string, withStatusInfo?: boolean, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.IndexesIndexDefinitionSnapshotEntry>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexdef/input-data/{index_definition_id}'.replace('{' + 'index_definition_id' + '}', encodeURIComponent(String(indexDefinitionId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'indexDefinitionId' is not null or undefined
        if (indexDefinitionId === null || indexDefinitionId === undefined) {
            throw new Error('Required parameter indexDefinitionId was null or undefined when calling v1IndexdefInputDataIndexDefinitionIdGet.');
        }

        if (time !== null && time !== undefined) {
            queryParameters['time'] = time.toISOString();
        }
        if (enabledOnly !== null && enabledOnly !== undefined) {
            queryParameters['enabled_only'] = <string><any>enabledOnly;
        }
        if (pendingOnly !== null && pendingOnly !== undefined) {
            queryParameters['pending_only'] = <string><any>pendingOnly;
        }
        if (filterAssetId !== null && filterAssetId !== undefined) {
            queryParameters['filter_asset_id'] = <string><any>filterAssetId;
        }
        if (withStatusInfo !== null && withStatusInfo !== undefined) {
            queryParameters['with_status_info'] = <string><any>withStatusInfo;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.IndexesIndexDefinitionSnapshotEntry>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.IndexesIndexDefinitionSnapshotEntry>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get all multi-asset weights
     */
    public v1IndexdefMultiassetGet(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.IndexesIndexMultiAssetWeight>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexdef/multiasset';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.IndexesIndexMultiAssetWeight>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.IndexesIndexMultiAssetWeight>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get multi-asset weights for specific index
     * @param indexId 
     */
    public v1IndexdefMultiassetIndexIdGet(indexId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.IndexesIndexMultiAssetWeight>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexdef/multiasset/{index_id}'.replace('{' + 'index_id' + '}', encodeURIComponent(String(indexId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'indexId' is not null or undefined
        if (indexId === null || indexId === undefined) {
            throw new Error('Required parameter indexId was null or undefined when calling v1IndexdefMultiassetIndexIdGet.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.IndexesIndexMultiAssetWeight>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.IndexesIndexMultiAssetWeight>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary List indexes
     */
    public v1IndexesGet(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.IndexesIndexIdentifier>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexes';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.IndexesIndexIdentifier>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.IndexesIndexIdentifier>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Current Index Values for index definition
     * @param indexDefinitionId 
     */
    public v1IndexesIndexDefinitionIdCurrentSnapshotGet(indexDefinitionId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.IndexesIndexDefinitionSnapshotEntry>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexes/{index_definition_id}/currentSnapshot'.replace('{' + 'index_definition_id' + '}', encodeURIComponent(String(indexDefinitionId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'indexDefinitionId' is not null or undefined
        if (indexDefinitionId === null || indexDefinitionId === undefined) {
            throw new Error('Required parameter indexDefinitionId was null or undefined when calling v1IndexesIndexDefinitionIdCurrentSnapshotGet.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.IndexesIndexDefinitionSnapshotEntry>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.IndexesIndexDefinitionSnapshotEntry>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Historical Index Values for index definition
     * @param indexDefinitionId 
     * @param time 
     */
    public v1IndexesIndexDefinitionIdHistorySnapshotGet(indexDefinitionId: string, time?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.IndexesIndexDefinitionSnapshotEntry>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexes/{index_definition_id}/historySnapshot'.replace('{' + 'index_definition_id' + '}', encodeURIComponent(String(indexDefinitionId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'indexDefinitionId' is not null or undefined
        if (indexDefinitionId === null || indexDefinitionId === undefined) {
            throw new Error('Required parameter indexDefinitionId was null or undefined when calling v1IndexesIndexDefinitionIdHistorySnapshotGet.');
        }

        if (time !== null && time !== undefined) {
            queryParameters['time'] = time.toISOString();
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.IndexesIndexDefinitionSnapshotEntry>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.IndexesIndexDefinitionSnapshotEntry>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Current Index Value
     * @param indexId 
     */
    public v1IndexesIndexIdCurrentGet(indexId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.IndexesIndexValue;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexes/{index_id}/current'.replace('{' + 'index_id' + '}', encodeURIComponent(String(indexId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'indexId' is not null or undefined
        if (indexId === null || indexId === undefined) {
            throw new Error('Required parameter indexId was null or undefined when calling v1IndexesIndexIdCurrentGet.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.IndexesIndexValue;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.IndexesIndexValue, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Historical Index Value w/Composition
     * @param indexId 
     * @param timeStart 
     * @param timeEnd 
     * @param limit 
     */
    public v1IndexesIndexIdHistoryGet(indexId: string, timeStart?: string, timeEnd?: string, limit?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.IndexesIndexValue>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexes/{index_id}/history'.replace('{' + 'index_id' + '}', encodeURIComponent(String(indexId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'indexId' is not null or undefined
        if (indexId === null || indexId === undefined) {
            throw new Error('Required parameter indexId was null or undefined when calling v1IndexesIndexIdHistoryGet.');
        }

        if (timeStart !== null && timeStart !== undefined) {
            queryParameters['time_start'] = timeStart.toISOString();
        }
        if (timeEnd !== null && timeEnd !== undefined) {
            queryParameters['time_end'] = timeEnd.toISOString();
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.IndexesIndexValue>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.IndexesIndexValue>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Timeseries Index Value
     * @param indexId 
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;)
     * @param timeStart Timeseries starting time in ISO 8601
     * @param timeEnd Timeseries ending time in ISO 8601
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
     */
    public v1IndexesIndexIdTimeseriesGet(indexId: string, periodId: string, timeStart: string, timeEnd: string, limit?: number, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: Array<models.IndexesIndexTimeseriesItem>;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/v1/indexes/{index_id}/timeseries'.replace('{' + 'index_id' + '}', encodeURIComponent(String(indexId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'indexId' is not null or undefined
        if (indexId === null || indexId === undefined) {
            throw new Error('Required parameter indexId was null or undefined when calling v1IndexesIndexIdTimeseriesGet.');
        }

        // verify required parameter 'periodId' is not null or undefined
        if (periodId === null || periodId === undefined) {
            throw new Error('Required parameter periodId was null or undefined when calling v1IndexesIndexIdTimeseriesGet.');
        }

        // verify required parameter 'timeStart' is not null or undefined
        if (timeStart === null || timeStart === undefined) {
            throw new Error('Required parameter timeStart was null or undefined when calling v1IndexesIndexIdTimeseriesGet.');
        }

        // verify required parameter 'timeEnd' is not null or undefined
        if (timeEnd === null || timeEnd === undefined) {
            throw new Error('Required parameter timeEnd was null or undefined when calling v1IndexesIndexIdTimeseriesGet.');
        }

        if (periodId !== null && periodId !== undefined) {
            queryParameters['period_id'] = <string><any>periodId;
        }
        if (timeStart !== null && timeStart !== undefined) {
            queryParameters['time_start'] = <string><any>timeStart;
        }
        if (timeEnd !== null && timeEnd !== undefined) {
            queryParameters['time_end'] = <string><any>timeEnd;
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json', 
            'application/x-msgpack'
        ];

        // authentication (APIKey) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }

        // authentication (JWT) required
        if (this.configuration.apiKey) {
            headerParams['Authorization'] = this.configuration.apiKey;
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: Array<models.IndexesIndexTimeseriesItem>;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: Array<models.IndexesIndexTimeseriesItem>, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

}
