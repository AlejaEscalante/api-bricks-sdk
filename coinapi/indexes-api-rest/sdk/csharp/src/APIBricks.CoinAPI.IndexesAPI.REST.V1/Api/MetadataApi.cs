// <auto-generated>
/*
 * Indexes REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using APIBricks.CoinAPI.IndexesAPI.REST.V1.Client;
using APIBricks.CoinAPI.IndexesAPI.REST.V1.Model;
using System.Diagnostics.CodeAnalysis;

namespace APIBricks.CoinAPI.IndexesAPI.REST.V1.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IMetadataApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        MetadataApiEvents Events { get; }

        /// <summary>
        /// List all exchanges by exchange_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The ID of the exchange.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiMetadataExchangesExchangeIdGetApiResponse"/>&gt;</returns>
        Task<IApiMetadataExchangesExchangeIdGetApiResponse> ApiMetadataExchangesExchangeIdGetAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchanges by exchange_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="exchangeId">The ID of the exchange.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiMetadataExchangesExchangeIdGetApiResponse"/>?&gt;</returns>
        Task<IApiMetadataExchangesExchangeIdGetApiResponse?> ApiMetadataExchangesExchangeIdGetOrDefaultAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchanges
        /// </summary>
        /// <remarks>
        /// Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterExchangeId">Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiMetadataExchangesGetApiResponse"/>&gt;</returns>
        Task<IApiMetadataExchangesGetApiResponse> ApiMetadataExchangesGetAsync(Option<string> filterExchangeId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchanges
        /// </summary>
        /// <remarks>
        /// Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </remarks>
        /// <param name="filterExchangeId">Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiMetadataExchangesGetApiResponse"/>?&gt;</returns>
        Task<IApiMetadataExchangesGetApiResponse?> ApiMetadataExchangesGetOrDefaultAsync(Option<string> filterExchangeId = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IApiMetadataExchangesExchangeIdGetApiResponse"/>
    /// </summary>
    public interface IApiMetadataExchangesExchangeIdGetApiResponse : APIBricks.CoinAPI.IndexesAPI.REST.V1.Client.IApiResponse, IOk<List<MetadataExchange>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiMetadataExchangesGetApiResponse"/>
    /// </summary>
    public interface IApiMetadataExchangesGetApiResponse : APIBricks.CoinAPI.IndexesAPI.REST.V1.Client.IApiResponse, IOk<List<MetadataExchange>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class MetadataApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiMetadataExchangesExchangeIdGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiMetadataExchangesExchangeIdGet;

        internal void ExecuteOnApiMetadataExchangesExchangeIdGet(MetadataApi.ApiMetadataExchangesExchangeIdGetApiResponse apiResponse)
        {
            OnApiMetadataExchangesExchangeIdGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiMetadataExchangesExchangeIdGet(Exception exception)
        {
            OnErrorApiMetadataExchangesExchangeIdGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiMetadataExchangesGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiMetadataExchangesGet;

        internal void ExecuteOnApiMetadataExchangesGet(MetadataApi.ApiMetadataExchangesGetApiResponse apiResponse)
        {
            OnApiMetadataExchangesGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiMetadataExchangesGet(Exception exception)
        {
            OnErrorApiMetadataExchangesGet?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class MetadataApi : IMetadataApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<MetadataApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public MetadataApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MetadataApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MetadataApi(ILogger<MetadataApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, MetadataApiEvents metadataApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<MetadataApi>();
            HttpClient = httpClient;
            Events = metadataApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatApiMetadataExchangesExchangeIdGet(ref string exchangeId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="exchangeId"></param>
        /// <returns></returns>
        private void ValidateApiMetadataExchangesExchangeIdGet(string exchangeId)
        {
            if (exchangeId == null)
                throw new ArgumentNullException(nameof(exchangeId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        private void AfterApiMetadataExchangesExchangeIdGetDefaultImplementation(IApiMetadataExchangesExchangeIdGetApiResponse apiResponseLocalVar, string exchangeId)
        {
            bool suppressDefaultLog = false;
            AfterApiMetadataExchangesExchangeIdGet(ref suppressDefaultLog, apiResponseLocalVar, exchangeId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="exchangeId"></param>
        partial void AfterApiMetadataExchangesExchangeIdGet(ref bool suppressDefaultLog, IApiMetadataExchangesExchangeIdGetApiResponse apiResponseLocalVar, string exchangeId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        private void OnErrorApiMetadataExchangesExchangeIdGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiMetadataExchangesExchangeIdGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, exchangeId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="exchangeId"></param>
        partial void OnErrorApiMetadataExchangesExchangeIdGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string exchangeId);

        /// <summary>
        /// List all exchanges by exchange_id 
        /// </summary>
        /// <param name="exchangeId">The ID of the exchange.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiMetadataExchangesExchangeIdGetApiResponse"/>&gt;</returns>
        public async Task<IApiMetadataExchangesExchangeIdGetApiResponse?> ApiMetadataExchangesExchangeIdGetOrDefaultAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiMetadataExchangesExchangeIdGetAsync(exchangeId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all exchanges by exchange_id 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="exchangeId">The ID of the exchange.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiMetadataExchangesExchangeIdGetApiResponse"/>&gt;</returns>
        public async Task<IApiMetadataExchangesExchangeIdGetApiResponse> ApiMetadataExchangesExchangeIdGetAsync(string exchangeId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiMetadataExchangesExchangeIdGet(exchangeId);

                FormatApiMetadataExchangesExchangeIdGet(ref exchangeId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/metadata/exchanges/{exchange_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/metadata/exchanges/{exchange_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bexchange_id%7D", Uri.EscapeDataString(exchangeId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ApiMetadataExchangesExchangeIdGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiMetadataExchangesExchangeIdGetApiResponse>();

                        ApiMetadataExchangesExchangeIdGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/metadata/exchanges/{exchange_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterApiMetadataExchangesExchangeIdGetDefaultImplementation(apiResponseLocalVar, exchangeId);

                        Events.ExecuteOnApiMetadataExchangesExchangeIdGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiMetadataExchangesExchangeIdGetDefaultImplementation(e, "/api/metadata/exchanges/{exchange_id}", uriBuilderLocalVar.Path, exchangeId);
                Events.ExecuteOnErrorApiMetadataExchangesExchangeIdGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiMetadataExchangesExchangeIdGetApiResponse"/>
        /// </summary>
        public partial class ApiMetadataExchangesExchangeIdGetApiResponse : APIBricks.CoinAPI.IndexesAPI.REST.V1.Client.ApiResponse, IApiMetadataExchangesExchangeIdGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiMetadataExchangesExchangeIdGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiMetadataExchangesExchangeIdGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiMetadataExchangesExchangeIdGetApiResponse(ILogger<ApiMetadataExchangesExchangeIdGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MetadataExchange>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MetadataExchange>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MetadataExchange>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiMetadataExchangesGet(ref Option<string> filterExchangeId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="filterExchangeId"></param>
        /// <returns></returns>
        private void ValidateApiMetadataExchangesGet(Option<string> filterExchangeId)
        {
            if (filterExchangeId.IsSet && filterExchangeId.Value == null)
                throw new ArgumentNullException(nameof(filterExchangeId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="filterExchangeId"></param>
        private void AfterApiMetadataExchangesGetDefaultImplementation(IApiMetadataExchangesGetApiResponse apiResponseLocalVar, Option<string> filterExchangeId)
        {
            bool suppressDefaultLog = false;
            AfterApiMetadataExchangesGet(ref suppressDefaultLog, apiResponseLocalVar, filterExchangeId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="filterExchangeId"></param>
        partial void AfterApiMetadataExchangesGet(ref bool suppressDefaultLog, IApiMetadataExchangesGetApiResponse apiResponseLocalVar, Option<string> filterExchangeId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="filterExchangeId"></param>
        private void OnErrorApiMetadataExchangesGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> filterExchangeId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiMetadataExchangesGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, filterExchangeId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="filterExchangeId"></param>
        partial void OnErrorApiMetadataExchangesGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> filterExchangeId);

        /// <summary>
        /// List all exchanges Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </summary>
        /// <param name="filterExchangeId">Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiMetadataExchangesGetApiResponse"/>&gt;</returns>
        public async Task<IApiMetadataExchangesGetApiResponse?> ApiMetadataExchangesGetOrDefaultAsync(Option<string> filterExchangeId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiMetadataExchangesGetAsync(filterExchangeId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all exchanges Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterExchangeId">Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiMetadataExchangesGetApiResponse"/>&gt;</returns>
        public async Task<IApiMetadataExchangesGetApiResponse> ApiMetadataExchangesGetAsync(Option<string> filterExchangeId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiMetadataExchangesGet(filterExchangeId);

                FormatApiMetadataExchangesGet(ref filterExchangeId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/metadata/exchanges"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/metadata/exchanges");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (filterExchangeId.IsSet)
                        parseQueryStringLocalVar["filter_exchange_id"] = ClientUtils.ParameterToString(filterExchangeId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ApiMetadataExchangesGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiMetadataExchangesGetApiResponse>();

                        ApiMetadataExchangesGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/metadata/exchanges", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterApiMetadataExchangesGetDefaultImplementation(apiResponseLocalVar, filterExchangeId);

                        Events.ExecuteOnApiMetadataExchangesGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiMetadataExchangesGetDefaultImplementation(e, "/api/metadata/exchanges", uriBuilderLocalVar.Path, filterExchangeId);
                Events.ExecuteOnErrorApiMetadataExchangesGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiMetadataExchangesGetApiResponse"/>
        /// </summary>
        public partial class ApiMetadataExchangesGetApiResponse : APIBricks.CoinAPI.IndexesAPI.REST.V1.Client.ApiResponse, IApiMetadataExchangesGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiMetadataExchangesGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiMetadataExchangesGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiMetadataExchangesGetApiResponse(ILogger<ApiMetadataExchangesGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MetadataExchange>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MetadataExchange>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MetadataExchange>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
