// @flow
/* eslint-disable no-use-before-define */
/**
 * CoinAPI Indexes REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://rest-api.indexes.coinapi.io".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type IndexesIndexDefinitionInputData = {
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexDefinitionInputData
     */
    exchangeId?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexDefinitionInputData
     */
    exchangeSymbolId?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexDefinitionInputData
     */
    baseAssetId?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexDefinitionInputData
     */
    quoteAssetId?: string;
    /**
     * 
     * @type {Date}
     * @memberof IndexesIndexDefinitionInputData
     */
    beginDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof IndexesIndexDefinitionInputData
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexDefinitionInputData
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexDefinitionInputData
     */
    statusInfo?: string;
    /**
     * 
     * @type {Date}
     * @memberof IndexesIndexDefinitionInputData
     */
    lastModificationTime?: Date;
}

/**
 * 
 * @export
 */
export type IndexesIndexDefinitionSnapshotEntry = {
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexDefinitionSnapshotEntry
     */
    index_id?: string;
    /**
     * 
     * @type {Date}
     * @memberof IndexesIndexDefinitionSnapshotEntry
     */
    timestamp?: Date;
    /**
     * 
     * @type {number}
     * @memberof IndexesIndexDefinitionSnapshotEntry
     */
    value?: number;
}

/**
 * Represents an index id
 * @export
 */
export type IndexesIndexIdentifier = {
    /**
     * Index ID
     * @type {string}
     * @memberof IndexesIndexIdentifier
     */
    id?: string;
}

/**
 * 
 * @export
 */
export type IndexesIndexMultiAssetWeight = {
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexMultiAssetWeight
     */
    indexId?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexMultiAssetWeight
     */
    assetId?: string;
    /**
     * 
     * @type {number}
     * @memberof IndexesIndexMultiAssetWeight
     */
    weight?: number;
}

/**
 * Represents a timeseries item with value information.
 * @export
 */
export type IndexesIndexTimeseriesItem = {
    /**
     * Gets or sets the start time of the time period.
     * @type {Date}
     * @memberof IndexesIndexTimeseriesItem
     */
    time_period_start?: Date;
    /**
     * Gets or sets the end time of the time period.
     * @type {Date}
     * @memberof IndexesIndexTimeseriesItem
     */
    time_period_end?: Date;
    /**
     * Gets or sets the time when the value opened.
     * @type {Date}
     * @memberof IndexesIndexTimeseriesItem
     */
    time_open?: Date;
    /**
     * Gets or sets the time when the value closed.
     * @type {Date}
     * @memberof IndexesIndexTimeseriesItem
     */
    time_close?: Date;
    /**
     * Gets or sets the opening value.
     * @type {number}
     * @memberof IndexesIndexTimeseriesItem
     */
    value_open?: number;
    /**
     * Gets or sets the highest value during the time period.
     * @type {number}
     * @memberof IndexesIndexTimeseriesItem
     */
    value_high?: number;
    /**
     * Gets or sets the lowest value during the time period.
     * @type {number}
     * @memberof IndexesIndexTimeseriesItem
     */
    value_low?: number;
    /**
     * Gets or sets the closing value.
     * @type {number}
     * @memberof IndexesIndexTimeseriesItem
     */
    value_close?: number;
    /**
     * Gets or sets the number of values during the time period.
     * @type {number}
     * @memberof IndexesIndexTimeseriesItem
     */
    value_count?: number;
}

/**
 * 
 * @export
 */
export type IndexesIndexValue = {
    /**
     * 
     * @type {Date}
     * @memberof IndexesIndexValue
     */
    timestamp?: Date;
    /**
     * 
     * @type {number}
     * @memberof IndexesIndexValue
     */
    value?: number;
    /**
     * 
     * @type {Array<IndexesIndexValueComponent>}
     * @memberof IndexesIndexValue
     */
    composition?: Array<IndexesIndexValueComponent>;
}

/**
 * 
 * @export
 */
export type IndexesIndexValueComponent = {
    /**
     * 
     * @type {string}
     * @memberof IndexesIndexValueComponent
     */
    component_id?: string;
    /**
     * 
     * @type {number}
     * @memberof IndexesIndexValueComponent
     */
    component_value?: number;
}

/**
 * Represents an exchange.
 * @export
 */
export type MetadataExchange = {
    /**
     * Gets or sets the exchange ID.
     * @type {string}
     * @memberof MetadataExchange
     */
    exchange_id?: string;
    /**
     * Gets or sets the website URL of the exchange.
     * @type {string}
     * @memberof MetadataExchange
     */
    website?: string;
    /**
     * Gets or sets the name of the exchange.
     * @type {string}
     * @memberof MetadataExchange
     */
    name?: string;
}

/**
 * Represents a timeseries period used in exchange rate data.
 * @export
 */
export type MetadataTimeseriesPeriod = {
    /**
     * Gets or sets the period ID.
     * @type {string}
     * @memberof MetadataTimeseriesPeriod
     */
    period_id?: string;
    /**
     * Gets or sets the length of the period in seconds.
     * @type {number}
     * @memberof MetadataTimeseriesPeriod
     */
    length_seconds?: number;
    /**
     * Gets or sets the length of the period in months.
     * @type {number}
     * @memberof MetadataTimeseriesPeriod
     */
    length_months?: number;
    /**
     * Gets or sets the unit count.
     * @type {number}
     * @memberof MetadataTimeseriesPeriod
     */
    unit_count?: number;
    /**
     * Gets or sets the unit name.
     * @type {string}
     * @memberof MetadataTimeseriesPeriod
     */
    unit_name?: string;
    /**
     * Gets or sets the display name of the timeseries period.
     * @type {string}
     * @memberof MetadataTimeseriesPeriod
     */
    display_name?: string;
}



/**
 * IndexesApi - fetch parameter creator
 * @export
 */
export const IndexesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all data inputs for a specific index definition
         * @throws {RequiredError}
         */
        v1IndexdefInputDataIndexDefinitionIdAllGet(indexDefinitionId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'indexDefinitionId' is not null or undefined
            if (indexDefinitionId === null || indexDefinitionId === undefined) {
                throw new RequiredError('indexDefinitionId','Required parameter indexDefinitionId was null or undefined when calling v1IndexdefInputDataIndexDefinitionIdAllGet.');
            }
            const localVarPath = `/v1/indexdef/input-data/{index_definition_id}/all`
                .replace(`{${"index_definition_id"}}`, encodeURIComponent(String(indexDefinitionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns data inputs for certain index definition and time
         * @throws {RequiredError}
         */
        v1IndexdefInputDataIndexDefinitionIdGet(indexDefinitionId: string, time?: Date, enabledOnly?: boolean, pendingOnly?: boolean, filterAssetId?: string, withStatusInfo?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'indexDefinitionId' is not null or undefined
            if (indexDefinitionId === null || indexDefinitionId === undefined) {
                throw new RequiredError('indexDefinitionId','Required parameter indexDefinitionId was null or undefined when calling v1IndexdefInputDataIndexDefinitionIdGet.');
            }
            const localVarPath = `/v1/indexdef/input-data/{index_definition_id}`
                .replace(`{${"index_definition_id"}}`, encodeURIComponent(String(indexDefinitionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = ((time:any):Date).toISOString();
            }

            if (enabledOnly !== undefined) {
                localVarQueryParameter['enabled_only'] = ((enabledOnly:any):string);
            }

            if (pendingOnly !== undefined) {
                localVarQueryParameter['pending_only'] = ((pendingOnly:any):string);
            }

            if (filterAssetId !== undefined) {
                localVarQueryParameter['filter_asset_id'] = ((filterAssetId:any):string);
            }

            if (withStatusInfo !== undefined) {
                localVarQueryParameter['with_status_info'] = ((withStatusInfo:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all multi-asset weights
         * @throws {RequiredError}
         */
        v1IndexdefMultiassetGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/indexdef/multiasset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get multi-asset weights for specific index
         * @throws {RequiredError}
         */
        v1IndexdefMultiassetIndexIdGet(indexId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'indexId' is not null or undefined
            if (indexId === null || indexId === undefined) {
                throw new RequiredError('indexId','Required parameter indexId was null or undefined when calling v1IndexdefMultiassetIndexIdGet.');
            }
            const localVarPath = `/v1/indexdef/multiasset/{index_id}`
                .replace(`{${"index_id"}}`, encodeURIComponent(String(indexId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List indexes
         * @throws {RequiredError}
         */
        v1IndexesGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/indexes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Current Index Values for index definition
         * @throws {RequiredError}
         */
        v1IndexesIndexDefinitionIdCurrentSnapshotGet(indexDefinitionId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'indexDefinitionId' is not null or undefined
            if (indexDefinitionId === null || indexDefinitionId === undefined) {
                throw new RequiredError('indexDefinitionId','Required parameter indexDefinitionId was null or undefined when calling v1IndexesIndexDefinitionIdCurrentSnapshotGet.');
            }
            const localVarPath = `/v1/indexes/{index_definition_id}/currentSnapshot`
                .replace(`{${"index_definition_id"}}`, encodeURIComponent(String(indexDefinitionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Historical Index Values for index definition
         * @throws {RequiredError}
         */
        v1IndexesIndexDefinitionIdHistorySnapshotGet(indexDefinitionId: string, time?: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'indexDefinitionId' is not null or undefined
            if (indexDefinitionId === null || indexDefinitionId === undefined) {
                throw new RequiredError('indexDefinitionId','Required parameter indexDefinitionId was null or undefined when calling v1IndexesIndexDefinitionIdHistorySnapshotGet.');
            }
            const localVarPath = `/v1/indexes/{index_definition_id}/historySnapshot`
                .replace(`{${"index_definition_id"}}`, encodeURIComponent(String(indexDefinitionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = ((time:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Current Index Value
         * @throws {RequiredError}
         */
        v1IndexesIndexIdCurrentGet(indexId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'indexId' is not null or undefined
            if (indexId === null || indexId === undefined) {
                throw new RequiredError('indexId','Required parameter indexId was null or undefined when calling v1IndexesIndexIdCurrentGet.');
            }
            const localVarPath = `/v1/indexes/{index_id}/current`
                .replace(`{${"index_id"}}`, encodeURIComponent(String(indexId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Historical Index Value w/Composition
         * @throws {RequiredError}
         */
        v1IndexesIndexIdHistoryGet(indexId: string, timeStart?: Date, timeEnd?: Date, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'indexId' is not null or undefined
            if (indexId === null || indexId === undefined) {
                throw new RequiredError('indexId','Required parameter indexId was null or undefined when calling v1IndexesIndexIdHistoryGet.');
            }
            const localVarPath = `/v1/indexes/{index_id}/history`
                .replace(`{${"index_id"}}`, encodeURIComponent(String(indexId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):Date).toISOString();
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):Date).toISOString();
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Timeseries Index Value
         * @throws {RequiredError}
         */
        v1IndexesIndexIdTimeseriesGet(indexId: string, periodId: string, timeStart: string, timeEnd: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'indexId' is not null or undefined
            if (indexId === null || indexId === undefined) {
                throw new RequiredError('indexId','Required parameter indexId was null or undefined when calling v1IndexesIndexIdTimeseriesGet.');
            }
            // verify required parameter 'periodId' is not null or undefined
            if (periodId === null || periodId === undefined) {
                throw new RequiredError('periodId','Required parameter periodId was null or undefined when calling v1IndexesIndexIdTimeseriesGet.');
            }
            // verify required parameter 'timeStart' is not null or undefined
            if (timeStart === null || timeStart === undefined) {
                throw new RequiredError('timeStart','Required parameter timeStart was null or undefined when calling v1IndexesIndexIdTimeseriesGet.');
            }
            // verify required parameter 'timeEnd' is not null or undefined
            if (timeEnd === null || timeEnd === undefined) {
                throw new RequiredError('timeEnd','Required parameter timeEnd was null or undefined when calling v1IndexesIndexIdTimeseriesGet.');
            }
            const localVarPath = `/v1/indexes/{index_id}/timeseries`
                .replace(`{${"index_id"}}`, encodeURIComponent(String(indexId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):string);
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type IndexesApiType = { 
    v1IndexdefInputDataIndexDefinitionIdAllGet(indexDefinitionId: string, options?: RequestOptions): Promise<Array<IndexesIndexDefinitionInputData>>,

    v1IndexdefInputDataIndexDefinitionIdGet(indexDefinitionId: string, time?: Date, enabledOnly?: boolean, pendingOnly?: boolean, filterAssetId?: string, withStatusInfo?: boolean, options?: RequestOptions): Promise<Array<IndexesIndexDefinitionSnapshotEntry>>,

    v1IndexdefMultiassetGet(options?: RequestOptions): Promise<Array<IndexesIndexMultiAssetWeight>>,

    v1IndexdefMultiassetIndexIdGet(indexId: string, options?: RequestOptions): Promise<Array<IndexesIndexMultiAssetWeight>>,

    v1IndexesGet(options?: RequestOptions): Promise<Array<IndexesIndexIdentifier>>,

    v1IndexesIndexDefinitionIdCurrentSnapshotGet(indexDefinitionId: string, options?: RequestOptions): Promise<Array<IndexesIndexDefinitionSnapshotEntry>>,

    v1IndexesIndexDefinitionIdHistorySnapshotGet(indexDefinitionId: string, time?: Date, options?: RequestOptions): Promise<Array<IndexesIndexDefinitionSnapshotEntry>>,

    v1IndexesIndexIdCurrentGet(indexId: string, options?: RequestOptions): Promise<IndexesIndexValue>,

    v1IndexesIndexIdHistoryGet(indexId: string, timeStart?: Date, timeEnd?: Date, limit?: number, options?: RequestOptions): Promise<Array<IndexesIndexValue>>,

    v1IndexesIndexIdTimeseriesGet(indexId: string, periodId: string, timeStart: string, timeEnd: string, limit?: number, options?: RequestOptions): Promise<Array<IndexesIndexTimeseriesItem>>,
}

/**
 * IndexesApi - factory function to inject configuration 
 * @export
 */
export const IndexesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): IndexesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Returns all data inputs for a specific index definition
         * @throws {RequiredError}
         */
        v1IndexdefInputDataIndexDefinitionIdAllGet(indexDefinitionId: string, options?: RequestOptions = {}): Promise<Array<IndexesIndexDefinitionInputData>> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexdefInputDataIndexDefinitionIdAllGet(indexDefinitionId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns data inputs for certain index definition and time
         * @throws {RequiredError}
         */
        v1IndexdefInputDataIndexDefinitionIdGet(indexDefinitionId: string, time?: Date, enabledOnly?: boolean, pendingOnly?: boolean, filterAssetId?: string, withStatusInfo?: boolean, options?: RequestOptions = {}): Promise<Array<IndexesIndexDefinitionSnapshotEntry>> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexdefInputDataIndexDefinitionIdGet(indexDefinitionId, time, enabledOnly, pendingOnly, filterAssetId, withStatusInfo, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get all multi-asset weights
         * @throws {RequiredError}
         */
        v1IndexdefMultiassetGet(options?: RequestOptions = {}): Promise<Array<IndexesIndexMultiAssetWeight>> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexdefMultiassetGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get multi-asset weights for specific index
         * @throws {RequiredError}
         */
        v1IndexdefMultiassetIndexIdGet(indexId: string, options?: RequestOptions = {}): Promise<Array<IndexesIndexMultiAssetWeight>> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexdefMultiassetIndexIdGet(indexId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List indexes
         * @throws {RequiredError}
         */
        v1IndexesGet(options?: RequestOptions = {}): Promise<Array<IndexesIndexIdentifier>> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexesGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Current Index Values for index definition
         * @throws {RequiredError}
         */
        v1IndexesIndexDefinitionIdCurrentSnapshotGet(indexDefinitionId: string, options?: RequestOptions = {}): Promise<Array<IndexesIndexDefinitionSnapshotEntry>> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexesIndexDefinitionIdCurrentSnapshotGet(indexDefinitionId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Historical Index Values for index definition
         * @throws {RequiredError}
         */
        v1IndexesIndexDefinitionIdHistorySnapshotGet(indexDefinitionId: string, time?: Date, options?: RequestOptions = {}): Promise<Array<IndexesIndexDefinitionSnapshotEntry>> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexesIndexDefinitionIdHistorySnapshotGet(indexDefinitionId, time, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Current Index Value
         * @throws {RequiredError}
         */
        v1IndexesIndexIdCurrentGet(indexId: string, options?: RequestOptions = {}): Promise<IndexesIndexValue> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexesIndexIdCurrentGet(indexId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Historical Index Value w/Composition
         * @throws {RequiredError}
         */
        v1IndexesIndexIdHistoryGet(indexId: string, timeStart?: Date, timeEnd?: Date, limit?: number, options?: RequestOptions = {}): Promise<Array<IndexesIndexValue>> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexesIndexIdHistoryGet(indexId, timeStart, timeEnd, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Timeseries Index Value
         * @throws {RequiredError}
         */
        v1IndexesIndexIdTimeseriesGet(indexId: string, periodId: string, timeStart: string, timeEnd: string, limit?: number, options?: RequestOptions = {}): Promise<Array<IndexesIndexTimeseriesItem>> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).v1IndexesIndexIdTimeseriesGet(indexId, periodId, timeStart, timeEnd, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MetadataApi - fetch parameter creator
 * @export
 */
export const MetadataApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all exchanges by exchange_id
         * @throws {RequiredError}
         */
        apiMetadataExchangesExchangeIdGet(exchangeId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling apiMetadataExchangesExchangeIdGet.');
            }
            const localVarPath = `/api/metadata/exchanges/{exchange_id}`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a detailed list of exchanges provided by the system.              :::info Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source. :::
         * @summary List all exchanges
         * @throws {RequiredError}
         */
        apiMetadataExchangesGet(filterExchangeId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/metadata/exchanges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filterExchangeId !== undefined) {
                localVarQueryParameter['filter_exchange_id'] = ((filterExchangeId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MetadataApiType = { 
    apiMetadataExchangesExchangeIdGet(exchangeId: string, options?: RequestOptions): Promise<Array<MetadataExchange>>,

    apiMetadataExchangesGet(filterExchangeId?: string, options?: RequestOptions): Promise<Array<MetadataExchange>>,
}

/**
 * MetadataApi - factory function to inject configuration 
 * @export
 */
export const MetadataApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MetadataApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List all exchanges by exchange_id
         * @throws {RequiredError}
         */
        apiMetadataExchangesExchangeIdGet(exchangeId: string, options?: RequestOptions = {}): Promise<Array<MetadataExchange>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).apiMetadataExchangesExchangeIdGet(exchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get a detailed list of exchanges provided by the system.              :::info Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source. :::
         * @summary List all exchanges
         * @throws {RequiredError}
         */
        apiMetadataExchangesGet(filterExchangeId?: string, options?: RequestOptions = {}): Promise<Array<MetadataExchange>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).apiMetadataExchangesGet(filterExchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * PeriodsApi - fetch parameter creator
 * @export
 */
export const PeriodsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get full list of supported time periods              ### Available periods              Time unit | Period identifiers --------- | ----------- Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY Month | 1MTH, 2MTH, 3MTH, 4MTH, 6MTH Year | 1YRS, 2YRS, 3YRS, 4YRS, 5YRS              :::tip You can assume that we will not remove any periods from this response, however, we may add new ones. :::
         * @summary List all periods
         * @throws {RequiredError}
         */
        v1MetadataPeriodsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/metadata/periods`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type PeriodsApiType = { 
    v1MetadataPeriodsGet(options?: RequestOptions): Promise<Array<MetadataTimeseriesPeriod>>,
}

/**
 * PeriodsApi - factory function to inject configuration 
 * @export
 */
export const PeriodsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): PeriodsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get full list of supported time periods              ### Available periods              Time unit | Period identifiers --------- | ----------- Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY Month | 1MTH, 2MTH, 3MTH, 4MTH, 6MTH Year | 1YRS, 2YRS, 3YRS, 4YRS, 5YRS              :::tip You can assume that we will not remove any periods from this response, however, we may add new ones. :::
         * @summary List all periods
         * @throws {RequiredError}
         */
        v1MetadataPeriodsGet(options?: RequestOptions = {}): Promise<Array<MetadataTimeseriesPeriod>> {
            const localVarFetchArgs = PeriodsApiFetchParamCreator(configuration).v1MetadataPeriodsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    IndexesApi: IndexesApiType,

    MetadataApi: MetadataApiType,

    PeriodsApi: PeriodsApiType,
 }
