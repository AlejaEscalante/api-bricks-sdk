<?php
/**
 * IndexesApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * CoinAPI Indexes REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * IndexesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class IndexesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'v1IndexdefInputDataIndexDefinitionIdAllGet' => [
            'application/json',
        ],
        'v1IndexdefInputDataIndexDefinitionIdGet' => [
            'application/json',
        ],
        'v1IndexdefMultiassetGet' => [
            'application/json',
        ],
        'v1IndexdefMultiassetIndexIdGet' => [
            'application/json',
        ],
        'v1IndexesGet' => [
            'application/json',
        ],
        'v1IndexesIndexDefinitionIdCurrentSnapshotGet' => [
            'application/json',
        ],
        'v1IndexesIndexDefinitionIdHistorySnapshotGet' => [
            'application/json',
        ],
        'v1IndexesIndexIdCurrentGet' => [
            'application/json',
        ],
        'v1IndexesIndexIdHistoryGet' => [
            'application/json',
        ],
        'v1IndexesIndexIdTimeseriesGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation v1IndexdefInputDataIndexDefinitionIdAllGet
     *
     * Returns all data inputs for a specific index definition
     *
     * @param  string $index_definition_id index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexDefinitionInputData[]
     */
    public function v1IndexdefInputDataIndexDefinitionIdAllGet($index_definition_id, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'][0])
    {
        list($response) = $this->v1IndexdefInputDataIndexDefinitionIdAllGetWithHttpInfo($index_definition_id, $contentType);
        return $response;
    }

    /**
     * Operation v1IndexdefInputDataIndexDefinitionIdAllGetWithHttpInfo
     *
     * Returns all data inputs for a specific index definition
     *
     * @param  string $index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexDefinitionInputData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexdefInputDataIndexDefinitionIdAllGetWithHttpInfo($index_definition_id, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'][0])
    {
        $request = $this->v1IndexdefInputDataIndexDefinitionIdAllGetRequest($index_definition_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexDefinitionInputData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexDefinitionInputData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexDefinitionInputData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexdefInputDataIndexDefinitionIdAllGetAsync
     *
     * Returns all data inputs for a specific index definition
     *
     * @param  string $index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexdefInputDataIndexDefinitionIdAllGetAsync($index_definition_id, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'][0])
    {
        return $this->v1IndexdefInputDataIndexDefinitionIdAllGetAsyncWithHttpInfo($index_definition_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexdefInputDataIndexDefinitionIdAllGetAsyncWithHttpInfo
     *
     * Returns all data inputs for a specific index definition
     *
     * @param  string $index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexdefInputDataIndexDefinitionIdAllGetAsyncWithHttpInfo($index_definition_id, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexDefinitionInputData[]';
        $request = $this->v1IndexdefInputDataIndexDefinitionIdAllGetRequest($index_definition_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexdefInputDataIndexDefinitionIdAllGet'
     *
     * @param  string $index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexdefInputDataIndexDefinitionIdAllGetRequest($index_definition_id, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdAllGet'][0])
    {

        // verify the required parameter 'index_definition_id' is set
        if ($index_definition_id === null || (is_array($index_definition_id) && count($index_definition_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index_definition_id when calling v1IndexdefInputDataIndexDefinitionIdAllGet'
            );
        }


        $resourcePath = '/v1/indexdef/input-data/{index_definition_id}/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($index_definition_id !== null) {
            $resourcePath = str_replace(
                '{' . 'index_definition_id' . '}',
                ObjectSerializer::toPathValue($index_definition_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1IndexdefInputDataIndexDefinitionIdGet
     *
     * Returns data inputs for certain index definition and time
     *
     * @param  string $index_definition_id index_definition_id (required)
     * @param  \DateTime|null $time time (optional)
     * @param  bool|null $enabled_only enabled_only (optional, default to false)
     * @param  bool|null $pending_only pending_only (optional, default to false)
     * @param  string|null $filter_asset_id filter_asset_id (optional)
     * @param  bool|null $with_status_info with_status_info (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]
     */
    public function v1IndexdefInputDataIndexDefinitionIdGet($index_definition_id, $time = null, $enabled_only = false, $pending_only = false, $filter_asset_id = null, $with_status_info = false, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'][0])
    {
        list($response) = $this->v1IndexdefInputDataIndexDefinitionIdGetWithHttpInfo($index_definition_id, $time, $enabled_only, $pending_only, $filter_asset_id, $with_status_info, $contentType);
        return $response;
    }

    /**
     * Operation v1IndexdefInputDataIndexDefinitionIdGetWithHttpInfo
     *
     * Returns data inputs for certain index definition and time
     *
     * @param  string $index_definition_id (required)
     * @param  \DateTime|null $time (optional)
     * @param  bool|null $enabled_only (optional, default to false)
     * @param  bool|null $pending_only (optional, default to false)
     * @param  string|null $filter_asset_id (optional)
     * @param  bool|null $with_status_info (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexdefInputDataIndexDefinitionIdGetWithHttpInfo($index_definition_id, $time = null, $enabled_only = false, $pending_only = false, $filter_asset_id = null, $with_status_info = false, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'][0])
    {
        $request = $this->v1IndexdefInputDataIndexDefinitionIdGetRequest($index_definition_id, $time, $enabled_only, $pending_only, $filter_asset_id, $with_status_info, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexdefInputDataIndexDefinitionIdGetAsync
     *
     * Returns data inputs for certain index definition and time
     *
     * @param  string $index_definition_id (required)
     * @param  \DateTime|null $time (optional)
     * @param  bool|null $enabled_only (optional, default to false)
     * @param  bool|null $pending_only (optional, default to false)
     * @param  string|null $filter_asset_id (optional)
     * @param  bool|null $with_status_info (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexdefInputDataIndexDefinitionIdGetAsync($index_definition_id, $time = null, $enabled_only = false, $pending_only = false, $filter_asset_id = null, $with_status_info = false, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'][0])
    {
        return $this->v1IndexdefInputDataIndexDefinitionIdGetAsyncWithHttpInfo($index_definition_id, $time, $enabled_only, $pending_only, $filter_asset_id, $with_status_info, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexdefInputDataIndexDefinitionIdGetAsyncWithHttpInfo
     *
     * Returns data inputs for certain index definition and time
     *
     * @param  string $index_definition_id (required)
     * @param  \DateTime|null $time (optional)
     * @param  bool|null $enabled_only (optional, default to false)
     * @param  bool|null $pending_only (optional, default to false)
     * @param  string|null $filter_asset_id (optional)
     * @param  bool|null $with_status_info (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexdefInputDataIndexDefinitionIdGetAsyncWithHttpInfo($index_definition_id, $time = null, $enabled_only = false, $pending_only = false, $filter_asset_id = null, $with_status_info = false, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]';
        $request = $this->v1IndexdefInputDataIndexDefinitionIdGetRequest($index_definition_id, $time, $enabled_only, $pending_only, $filter_asset_id, $with_status_info, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexdefInputDataIndexDefinitionIdGet'
     *
     * @param  string $index_definition_id (required)
     * @param  \DateTime|null $time (optional)
     * @param  bool|null $enabled_only (optional, default to false)
     * @param  bool|null $pending_only (optional, default to false)
     * @param  string|null $filter_asset_id (optional)
     * @param  bool|null $with_status_info (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexdefInputDataIndexDefinitionIdGetRequest($index_definition_id, $time = null, $enabled_only = false, $pending_only = false, $filter_asset_id = null, $with_status_info = false, string $contentType = self::contentTypes['v1IndexdefInputDataIndexDefinitionIdGet'][0])
    {

        // verify the required parameter 'index_definition_id' is set
        if ($index_definition_id === null || (is_array($index_definition_id) && count($index_definition_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index_definition_id when calling v1IndexdefInputDataIndexDefinitionIdGet'
            );
        }







        $resourcePath = '/v1/indexdef/input-data/{index_definition_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time,
            'time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enabled_only,
            'enabled_only', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pending_only,
            'pending_only', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_asset_id,
            'filter_asset_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_status_info,
            'with_status_info', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($index_definition_id !== null) {
            $resourcePath = str_replace(
                '{' . 'index_definition_id' . '}',
                ObjectSerializer::toPathValue($index_definition_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1IndexdefMultiassetGet
     *
     * Get all multi-asset weights
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]
     */
    public function v1IndexdefMultiassetGet(string $contentType = self::contentTypes['v1IndexdefMultiassetGet'][0])
    {
        list($response) = $this->v1IndexdefMultiassetGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation v1IndexdefMultiassetGetWithHttpInfo
     *
     * Get all multi-asset weights
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexdefMultiassetGetWithHttpInfo(string $contentType = self::contentTypes['v1IndexdefMultiassetGet'][0])
    {
        $request = $this->v1IndexdefMultiassetGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexdefMultiassetGetAsync
     *
     * Get all multi-asset weights
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexdefMultiassetGetAsync(string $contentType = self::contentTypes['v1IndexdefMultiassetGet'][0])
    {
        return $this->v1IndexdefMultiassetGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexdefMultiassetGetAsyncWithHttpInfo
     *
     * Get all multi-asset weights
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexdefMultiassetGetAsyncWithHttpInfo(string $contentType = self::contentTypes['v1IndexdefMultiassetGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]';
        $request = $this->v1IndexdefMultiassetGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexdefMultiassetGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexdefMultiassetGetRequest(string $contentType = self::contentTypes['v1IndexdefMultiassetGet'][0])
    {


        $resourcePath = '/v1/indexdef/multiasset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1IndexdefMultiassetIndexIdGet
     *
     * Get multi-asset weights for specific index
     *
     * @param  string $index_id index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetIndexIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]
     */
    public function v1IndexdefMultiassetIndexIdGet($index_id, string $contentType = self::contentTypes['v1IndexdefMultiassetIndexIdGet'][0])
    {
        list($response) = $this->v1IndexdefMultiassetIndexIdGetWithHttpInfo($index_id, $contentType);
        return $response;
    }

    /**
     * Operation v1IndexdefMultiassetIndexIdGetWithHttpInfo
     *
     * Get multi-asset weights for specific index
     *
     * @param  string $index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetIndexIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexdefMultiassetIndexIdGetWithHttpInfo($index_id, string $contentType = self::contentTypes['v1IndexdefMultiassetIndexIdGet'][0])
    {
        $request = $this->v1IndexdefMultiassetIndexIdGetRequest($index_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexdefMultiassetIndexIdGetAsync
     *
     * Get multi-asset weights for specific index
     *
     * @param  string $index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetIndexIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexdefMultiassetIndexIdGetAsync($index_id, string $contentType = self::contentTypes['v1IndexdefMultiassetIndexIdGet'][0])
    {
        return $this->v1IndexdefMultiassetIndexIdGetAsyncWithHttpInfo($index_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexdefMultiassetIndexIdGetAsyncWithHttpInfo
     *
     * Get multi-asset weights for specific index
     *
     * @param  string $index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetIndexIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexdefMultiassetIndexIdGetAsyncWithHttpInfo($index_id, string $contentType = self::contentTypes['v1IndexdefMultiassetIndexIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexMultiAssetWeight[]';
        $request = $this->v1IndexdefMultiassetIndexIdGetRequest($index_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexdefMultiassetIndexIdGet'
     *
     * @param  string $index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexdefMultiassetIndexIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexdefMultiassetIndexIdGetRequest($index_id, string $contentType = self::contentTypes['v1IndexdefMultiassetIndexIdGet'][0])
    {

        // verify the required parameter 'index_id' is set
        if ($index_id === null || (is_array($index_id) && count($index_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index_id when calling v1IndexdefMultiassetIndexIdGet'
            );
        }


        $resourcePath = '/v1/indexdef/multiasset/{index_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($index_id !== null) {
            $resourcePath = str_replace(
                '{' . 'index_id' . '}',
                ObjectSerializer::toPathValue($index_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1IndexesGet
     *
     * List indexes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexIdentifier[]
     */
    public function v1IndexesGet(string $contentType = self::contentTypes['v1IndexesGet'][0])
    {
        list($response) = $this->v1IndexesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation v1IndexesGetWithHttpInfo
     *
     * List indexes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexIdentifier[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexesGetWithHttpInfo(string $contentType = self::contentTypes['v1IndexesGet'][0])
    {
        $request = $this->v1IndexesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexIdentifier[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexIdentifier[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexIdentifier[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexesGetAsync
     *
     * List indexes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesGetAsync(string $contentType = self::contentTypes['v1IndexesGet'][0])
    {
        return $this->v1IndexesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexesGetAsyncWithHttpInfo
     *
     * List indexes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesGetAsyncWithHttpInfo(string $contentType = self::contentTypes['v1IndexesGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexIdentifier[]';
        $request = $this->v1IndexesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexesGetRequest(string $contentType = self::contentTypes['v1IndexesGet'][0])
    {


        $resourcePath = '/v1/indexes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1IndexesIndexDefinitionIdCurrentSnapshotGet
     *
     * Current Index Values for index definition
     *
     * @param  string $index_definition_id index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]
     */
    public function v1IndexesIndexDefinitionIdCurrentSnapshotGet($index_definition_id, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'][0])
    {
        list($response) = $this->v1IndexesIndexDefinitionIdCurrentSnapshotGetWithHttpInfo($index_definition_id, $contentType);
        return $response;
    }

    /**
     * Operation v1IndexesIndexDefinitionIdCurrentSnapshotGetWithHttpInfo
     *
     * Current Index Values for index definition
     *
     * @param  string $index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexesIndexDefinitionIdCurrentSnapshotGetWithHttpInfo($index_definition_id, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'][0])
    {
        $request = $this->v1IndexesIndexDefinitionIdCurrentSnapshotGetRequest($index_definition_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexesIndexDefinitionIdCurrentSnapshotGetAsync
     *
     * Current Index Values for index definition
     *
     * @param  string $index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexDefinitionIdCurrentSnapshotGetAsync($index_definition_id, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'][0])
    {
        return $this->v1IndexesIndexDefinitionIdCurrentSnapshotGetAsyncWithHttpInfo($index_definition_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexesIndexDefinitionIdCurrentSnapshotGetAsyncWithHttpInfo
     *
     * Current Index Values for index definition
     *
     * @param  string $index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexDefinitionIdCurrentSnapshotGetAsyncWithHttpInfo($index_definition_id, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]';
        $request = $this->v1IndexesIndexDefinitionIdCurrentSnapshotGetRequest($index_definition_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexesIndexDefinitionIdCurrentSnapshotGet'
     *
     * @param  string $index_definition_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexesIndexDefinitionIdCurrentSnapshotGetRequest($index_definition_id, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdCurrentSnapshotGet'][0])
    {

        // verify the required parameter 'index_definition_id' is set
        if ($index_definition_id === null || (is_array($index_definition_id) && count($index_definition_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index_definition_id when calling v1IndexesIndexDefinitionIdCurrentSnapshotGet'
            );
        }


        $resourcePath = '/v1/indexes/{index_definition_id}/currentSnapshot';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($index_definition_id !== null) {
            $resourcePath = str_replace(
                '{' . 'index_definition_id' . '}',
                ObjectSerializer::toPathValue($index_definition_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1IndexesIndexDefinitionIdHistorySnapshotGet
     *
     * Historical Index Values for index definition
     *
     * @param  string $index_definition_id index_definition_id (required)
     * @param  \DateTime|null $time time (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]
     */
    public function v1IndexesIndexDefinitionIdHistorySnapshotGet($index_definition_id, $time = null, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'][0])
    {
        list($response) = $this->v1IndexesIndexDefinitionIdHistorySnapshotGetWithHttpInfo($index_definition_id, $time, $contentType);
        return $response;
    }

    /**
     * Operation v1IndexesIndexDefinitionIdHistorySnapshotGetWithHttpInfo
     *
     * Historical Index Values for index definition
     *
     * @param  string $index_definition_id (required)
     * @param  \DateTime|null $time (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexesIndexDefinitionIdHistorySnapshotGetWithHttpInfo($index_definition_id, $time = null, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'][0])
    {
        $request = $this->v1IndexesIndexDefinitionIdHistorySnapshotGetRequest($index_definition_id, $time, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexesIndexDefinitionIdHistorySnapshotGetAsync
     *
     * Historical Index Values for index definition
     *
     * @param  string $index_definition_id (required)
     * @param  \DateTime|null $time (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexDefinitionIdHistorySnapshotGetAsync($index_definition_id, $time = null, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'][0])
    {
        return $this->v1IndexesIndexDefinitionIdHistorySnapshotGetAsyncWithHttpInfo($index_definition_id, $time, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexesIndexDefinitionIdHistorySnapshotGetAsyncWithHttpInfo
     *
     * Historical Index Values for index definition
     *
     * @param  string $index_definition_id (required)
     * @param  \DateTime|null $time (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexDefinitionIdHistorySnapshotGetAsyncWithHttpInfo($index_definition_id, $time = null, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexDefinitionSnapshotEntry[]';
        $request = $this->v1IndexesIndexDefinitionIdHistorySnapshotGetRequest($index_definition_id, $time, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexesIndexDefinitionIdHistorySnapshotGet'
     *
     * @param  string $index_definition_id (required)
     * @param  \DateTime|null $time (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexesIndexDefinitionIdHistorySnapshotGetRequest($index_definition_id, $time = null, string $contentType = self::contentTypes['v1IndexesIndexDefinitionIdHistorySnapshotGet'][0])
    {

        // verify the required parameter 'index_definition_id' is set
        if ($index_definition_id === null || (is_array($index_definition_id) && count($index_definition_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index_definition_id when calling v1IndexesIndexDefinitionIdHistorySnapshotGet'
            );
        }



        $resourcePath = '/v1/indexes/{index_definition_id}/historySnapshot';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time,
            'time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($index_definition_id !== null) {
            $resourcePath = str_replace(
                '{' . 'index_definition_id' . '}',
                ObjectSerializer::toPathValue($index_definition_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1IndexesIndexIdCurrentGet
     *
     * Current Index Value
     *
     * @param  string $index_id index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdCurrentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexValue
     */
    public function v1IndexesIndexIdCurrentGet($index_id, string $contentType = self::contentTypes['v1IndexesIndexIdCurrentGet'][0])
    {
        list($response) = $this->v1IndexesIndexIdCurrentGetWithHttpInfo($index_id, $contentType);
        return $response;
    }

    /**
     * Operation v1IndexesIndexIdCurrentGetWithHttpInfo
     *
     * Current Index Value
     *
     * @param  string $index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdCurrentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexesIndexIdCurrentGetWithHttpInfo($index_id, string $contentType = self::contentTypes['v1IndexesIndexIdCurrentGet'][0])
    {
        $request = $this->v1IndexesIndexIdCurrentGetRequest($index_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexValue',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexValue',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexesIndexIdCurrentGetAsync
     *
     * Current Index Value
     *
     * @param  string $index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexIdCurrentGetAsync($index_id, string $contentType = self::contentTypes['v1IndexesIndexIdCurrentGet'][0])
    {
        return $this->v1IndexesIndexIdCurrentGetAsyncWithHttpInfo($index_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexesIndexIdCurrentGetAsyncWithHttpInfo
     *
     * Current Index Value
     *
     * @param  string $index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexIdCurrentGetAsyncWithHttpInfo($index_id, string $contentType = self::contentTypes['v1IndexesIndexIdCurrentGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexValue';
        $request = $this->v1IndexesIndexIdCurrentGetRequest($index_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexesIndexIdCurrentGet'
     *
     * @param  string $index_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdCurrentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexesIndexIdCurrentGetRequest($index_id, string $contentType = self::contentTypes['v1IndexesIndexIdCurrentGet'][0])
    {

        // verify the required parameter 'index_id' is set
        if ($index_id === null || (is_array($index_id) && count($index_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index_id when calling v1IndexesIndexIdCurrentGet'
            );
        }


        $resourcePath = '/v1/indexes/{index_id}/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($index_id !== null) {
            $resourcePath = str_replace(
                '{' . 'index_id' . '}',
                ObjectSerializer::toPathValue($index_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1IndexesIndexIdHistoryGet
     *
     * Historical Index Value w/Composition
     *
     * @param  string $index_id index_id (required)
     * @param  \DateTime|null $time_start time_start (optional)
     * @param  \DateTime|null $time_end time_end (optional)
     * @param  int|null $limit limit (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdHistoryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexValue[]
     */
    public function v1IndexesIndexIdHistoryGet($index_id, $time_start = null, $time_end = null, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdHistoryGet'][0])
    {
        list($response) = $this->v1IndexesIndexIdHistoryGetWithHttpInfo($index_id, $time_start, $time_end, $limit, $contentType);
        return $response;
    }

    /**
     * Operation v1IndexesIndexIdHistoryGetWithHttpInfo
     *
     * Historical Index Value w/Composition
     *
     * @param  string $index_id (required)
     * @param  \DateTime|null $time_start (optional)
     * @param  \DateTime|null $time_end (optional)
     * @param  int|null $limit (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdHistoryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexValue[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexesIndexIdHistoryGetWithHttpInfo($index_id, $time_start = null, $time_end = null, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdHistoryGet'][0])
    {
        $request = $this->v1IndexesIndexIdHistoryGetRequest($index_id, $time_start, $time_end, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexValue[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexValue[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexesIndexIdHistoryGetAsync
     *
     * Historical Index Value w/Composition
     *
     * @param  string $index_id (required)
     * @param  \DateTime|null $time_start (optional)
     * @param  \DateTime|null $time_end (optional)
     * @param  int|null $limit (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexIdHistoryGetAsync($index_id, $time_start = null, $time_end = null, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdHistoryGet'][0])
    {
        return $this->v1IndexesIndexIdHistoryGetAsyncWithHttpInfo($index_id, $time_start, $time_end, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexesIndexIdHistoryGetAsyncWithHttpInfo
     *
     * Historical Index Value w/Composition
     *
     * @param  string $index_id (required)
     * @param  \DateTime|null $time_start (optional)
     * @param  \DateTime|null $time_end (optional)
     * @param  int|null $limit (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexIdHistoryGetAsyncWithHttpInfo($index_id, $time_start = null, $time_end = null, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdHistoryGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexValue[]';
        $request = $this->v1IndexesIndexIdHistoryGetRequest($index_id, $time_start, $time_end, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexesIndexIdHistoryGet'
     *
     * @param  string $index_id (required)
     * @param  \DateTime|null $time_start (optional)
     * @param  \DateTime|null $time_end (optional)
     * @param  int|null $limit (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdHistoryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexesIndexIdHistoryGetRequest($index_id, $time_start = null, $time_end = null, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdHistoryGet'][0])
    {

        // verify the required parameter 'index_id' is set
        if ($index_id === null || (is_array($index_id) && count($index_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index_id when calling v1IndexesIndexIdHistoryGet'
            );
        }





        $resourcePath = '/v1/indexes/{index_id}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_start,
            'time_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_end,
            'time_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($index_id !== null) {
            $resourcePath = str_replace(
                '{' . 'index_id' . '}',
                ObjectSerializer::toPathValue($index_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1IndexesIndexIdTimeseriesGet
     *
     * Timeseries Index Value
     *
     * @param  string $index_id  (required)
     * @param  string $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;) (required)
     * @param  string $time_start Timeseries starting time in ISO 8601 (required)
     * @param  string $time_end Timeseries ending time in ISO 8601 (required)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdTimeseriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\IndexesIndexTimeseriesItem[]
     */
    public function v1IndexesIndexIdTimeseriesGet($index_id, $period_id, $time_start, $time_end, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdTimeseriesGet'][0])
    {
        list($response) = $this->v1IndexesIndexIdTimeseriesGetWithHttpInfo($index_id, $period_id, $time_start, $time_end, $limit, $contentType);
        return $response;
    }

    /**
     * Operation v1IndexesIndexIdTimeseriesGetWithHttpInfo
     *
     * Timeseries Index Value
     *
     * @param  string $index_id  (required)
     * @param  string $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;) (required)
     * @param  string $time_start Timeseries starting time in ISO 8601 (required)
     * @param  string $time_end Timeseries ending time in ISO 8601 (required)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdTimeseriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\IndexesIndexTimeseriesItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v1IndexesIndexIdTimeseriesGetWithHttpInfo($index_id, $period_id, $time_start, $time_end, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdTimeseriesGet'][0])
    {
        $request = $this->v1IndexesIndexIdTimeseriesGetRequest($index_id, $period_id, $time_start, $time_end, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\IndexesIndexTimeseriesItem[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\IndexesIndexTimeseriesItem[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\IndexesIndexTimeseriesItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation v1IndexesIndexIdTimeseriesGetAsync
     *
     * Timeseries Index Value
     *
     * @param  string $index_id  (required)
     * @param  string $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;) (required)
     * @param  string $time_start Timeseries starting time in ISO 8601 (required)
     * @param  string $time_end Timeseries ending time in ISO 8601 (required)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdTimeseriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexIdTimeseriesGetAsync($index_id, $period_id, $time_start, $time_end, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdTimeseriesGet'][0])
    {
        return $this->v1IndexesIndexIdTimeseriesGetAsyncWithHttpInfo($index_id, $period_id, $time_start, $time_end, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1IndexesIndexIdTimeseriesGetAsyncWithHttpInfo
     *
     * Timeseries Index Value
     *
     * @param  string $index_id  (required)
     * @param  string $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;) (required)
     * @param  string $time_start Timeseries starting time in ISO 8601 (required)
     * @param  string $time_end Timeseries ending time in ISO 8601 (required)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdTimeseriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1IndexesIndexIdTimeseriesGetAsyncWithHttpInfo($index_id, $period_id, $time_start, $time_end, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdTimeseriesGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\IndexesIndexTimeseriesItem[]';
        $request = $this->v1IndexesIndexIdTimeseriesGetRequest($index_id, $period_id, $time_start, $time_end, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1IndexesIndexIdTimeseriesGet'
     *
     * @param  string $index_id  (required)
     * @param  string $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;) (required)
     * @param  string $time_start Timeseries starting time in ISO 8601 (required)
     * @param  string $time_end Timeseries ending time in ISO 8601 (required)
     * @param  int|null $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1IndexesIndexIdTimeseriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1IndexesIndexIdTimeseriesGetRequest($index_id, $period_id, $time_start, $time_end, $limit = 100, string $contentType = self::contentTypes['v1IndexesIndexIdTimeseriesGet'][0])
    {

        // verify the required parameter 'index_id' is set
        if ($index_id === null || (is_array($index_id) && count($index_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index_id when calling v1IndexesIndexIdTimeseriesGet'
            );
        }

        // verify the required parameter 'period_id' is set
        if ($period_id === null || (is_array($period_id) && count($period_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period_id when calling v1IndexesIndexIdTimeseriesGet'
            );
        }

        // verify the required parameter 'time_start' is set
        if ($time_start === null || (is_array($time_start) && count($time_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $time_start when calling v1IndexesIndexIdTimeseriesGet'
            );
        }

        // verify the required parameter 'time_end' is set
        if ($time_end === null || (is_array($time_end) && count($time_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $time_end when calling v1IndexesIndexIdTimeseriesGet'
            );
        }



        $resourcePath = '/v1/indexes/{index_id}/timeseries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period_id,
            'period_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_start,
            'time_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_end,
            'time_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($index_id !== null) {
            $resourcePath = str_replace(
                '{' . 'index_id' . '}',
                ObjectSerializer::toPathValue($index_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/x-msgpack', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
