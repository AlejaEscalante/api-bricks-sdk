/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.IndexesIndexDefinitionInputData
import org.openapitools.client.models.IndexesIndexDefinitionSnapshotEntry
import org.openapitools.client.models.IndexesIndexIdentifier
import org.openapitools.client.models.IndexesIndexMultiAssetWeight
import org.openapitools.client.models.IndexesIndexTimeseriesItem
import org.openapitools.client.models.IndexesIndexValue

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class IndexesApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://rest-api.indexes.coinapi.io")
        }
    }

    /**
     * GET /v1/indexdef/input-data/{index_definition_id}/all
     * Returns all data inputs for a specific index definition
     * 
     * @param indexDefinitionId 
     * @return kotlin.collections.List<IndexesIndexDefinitionInputData>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexdefInputDataIndexDefinitionIdAllGet(indexDefinitionId: kotlin.String) : kotlin.collections.List<IndexesIndexDefinitionInputData> {
        val localVarResponse = v1IndexdefInputDataIndexDefinitionIdAllGetWithHttpInfo(indexDefinitionId = indexDefinitionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IndexesIndexDefinitionInputData>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexdef/input-data/{index_definition_id}/all
     * Returns all data inputs for a specific index definition
     * 
     * @param indexDefinitionId 
     * @return ApiResponse<kotlin.collections.List<IndexesIndexDefinitionInputData>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexdefInputDataIndexDefinitionIdAllGetWithHttpInfo(indexDefinitionId: kotlin.String) : ApiResponse<kotlin.collections.List<IndexesIndexDefinitionInputData>?> {
        val localVariableConfig = v1IndexdefInputDataIndexDefinitionIdAllGetRequestConfig(indexDefinitionId = indexDefinitionId)

        return request<Unit, kotlin.collections.List<IndexesIndexDefinitionInputData>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexdefInputDataIndexDefinitionIdAllGet
     *
     * @param indexDefinitionId 
     * @return RequestConfig
     */
    fun v1IndexdefInputDataIndexDefinitionIdAllGetRequestConfig(indexDefinitionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexdef/input-data/{index_definition_id}/all".replace("{"+"index_definition_id"+"}", encodeURIComponent(indexDefinitionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/indexdef/input-data/{index_definition_id}
     * Returns data inputs for certain index definition and time
     * 
     * @param indexDefinitionId 
     * @param time  (optional)
     * @param enabledOnly  (optional, default to false)
     * @param pendingOnly  (optional, default to false)
     * @param filterAssetId  (optional)
     * @param withStatusInfo  (optional, default to false)
     * @return kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexdefInputDataIndexDefinitionIdGet(indexDefinitionId: kotlin.String, time: java.time.OffsetDateTime? = null, enabledOnly: kotlin.Boolean? = false, pendingOnly: kotlin.Boolean? = false, filterAssetId: kotlin.String? = null, withStatusInfo: kotlin.Boolean? = false) : kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry> {
        val localVarResponse = v1IndexdefInputDataIndexDefinitionIdGetWithHttpInfo(indexDefinitionId = indexDefinitionId, time = time, enabledOnly = enabledOnly, pendingOnly = pendingOnly, filterAssetId = filterAssetId, withStatusInfo = withStatusInfo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexdef/input-data/{index_definition_id}
     * Returns data inputs for certain index definition and time
     * 
     * @param indexDefinitionId 
     * @param time  (optional)
     * @param enabledOnly  (optional, default to false)
     * @param pendingOnly  (optional, default to false)
     * @param filterAssetId  (optional)
     * @param withStatusInfo  (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexdefInputDataIndexDefinitionIdGetWithHttpInfo(indexDefinitionId: kotlin.String, time: java.time.OffsetDateTime?, enabledOnly: kotlin.Boolean?, pendingOnly: kotlin.Boolean?, filterAssetId: kotlin.String?, withStatusInfo: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>?> {
        val localVariableConfig = v1IndexdefInputDataIndexDefinitionIdGetRequestConfig(indexDefinitionId = indexDefinitionId, time = time, enabledOnly = enabledOnly, pendingOnly = pendingOnly, filterAssetId = filterAssetId, withStatusInfo = withStatusInfo)

        return request<Unit, kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexdefInputDataIndexDefinitionIdGet
     *
     * @param indexDefinitionId 
     * @param time  (optional)
     * @param enabledOnly  (optional, default to false)
     * @param pendingOnly  (optional, default to false)
     * @param filterAssetId  (optional)
     * @param withStatusInfo  (optional, default to false)
     * @return RequestConfig
     */
    fun v1IndexdefInputDataIndexDefinitionIdGetRequestConfig(indexDefinitionId: kotlin.String, time: java.time.OffsetDateTime?, enabledOnly: kotlin.Boolean?, pendingOnly: kotlin.Boolean?, filterAssetId: kotlin.String?, withStatusInfo: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (time != null) {
                    put("time", listOf(parseDateToQueryString(time)))
                }
                if (enabledOnly != null) {
                    put("enabled_only", listOf(enabledOnly.toString()))
                }
                if (pendingOnly != null) {
                    put("pending_only", listOf(pendingOnly.toString()))
                }
                if (filterAssetId != null) {
                    put("filter_asset_id", listOf(filterAssetId.toString()))
                }
                if (withStatusInfo != null) {
                    put("with_status_info", listOf(withStatusInfo.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexdef/input-data/{index_definition_id}".replace("{"+"index_definition_id"+"}", encodeURIComponent(indexDefinitionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/indexdef/multiasset
     * Get all multi-asset weights
     * 
     * @return kotlin.collections.List<IndexesIndexMultiAssetWeight>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexdefMultiassetGet() : kotlin.collections.List<IndexesIndexMultiAssetWeight> {
        val localVarResponse = v1IndexdefMultiassetGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IndexesIndexMultiAssetWeight>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexdef/multiasset
     * Get all multi-asset weights
     * 
     * @return ApiResponse<kotlin.collections.List<IndexesIndexMultiAssetWeight>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexdefMultiassetGetWithHttpInfo() : ApiResponse<kotlin.collections.List<IndexesIndexMultiAssetWeight>?> {
        val localVariableConfig = v1IndexdefMultiassetGetRequestConfig()

        return request<Unit, kotlin.collections.List<IndexesIndexMultiAssetWeight>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexdefMultiassetGet
     *
     * @return RequestConfig
     */
    fun v1IndexdefMultiassetGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexdef/multiasset",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/indexdef/multiasset/{index_id}
     * Get multi-asset weights for specific index
     * 
     * @param indexId 
     * @return kotlin.collections.List<IndexesIndexMultiAssetWeight>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexdefMultiassetIndexIdGet(indexId: kotlin.String) : kotlin.collections.List<IndexesIndexMultiAssetWeight> {
        val localVarResponse = v1IndexdefMultiassetIndexIdGetWithHttpInfo(indexId = indexId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IndexesIndexMultiAssetWeight>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexdef/multiasset/{index_id}
     * Get multi-asset weights for specific index
     * 
     * @param indexId 
     * @return ApiResponse<kotlin.collections.List<IndexesIndexMultiAssetWeight>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexdefMultiassetIndexIdGetWithHttpInfo(indexId: kotlin.String) : ApiResponse<kotlin.collections.List<IndexesIndexMultiAssetWeight>?> {
        val localVariableConfig = v1IndexdefMultiassetIndexIdGetRequestConfig(indexId = indexId)

        return request<Unit, kotlin.collections.List<IndexesIndexMultiAssetWeight>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexdefMultiassetIndexIdGet
     *
     * @param indexId 
     * @return RequestConfig
     */
    fun v1IndexdefMultiassetIndexIdGetRequestConfig(indexId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexdef/multiasset/{index_id}".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/indexes
     * List indexes
     * 
     * @return kotlin.collections.List<IndexesIndexIdentifier>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexesGet() : kotlin.collections.List<IndexesIndexIdentifier> {
        val localVarResponse = v1IndexesGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IndexesIndexIdentifier>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexes
     * List indexes
     * 
     * @return ApiResponse<kotlin.collections.List<IndexesIndexIdentifier>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexesGetWithHttpInfo() : ApiResponse<kotlin.collections.List<IndexesIndexIdentifier>?> {
        val localVariableConfig = v1IndexesGetRequestConfig()

        return request<Unit, kotlin.collections.List<IndexesIndexIdentifier>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexesGet
     *
     * @return RequestConfig
     */
    fun v1IndexesGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/indexes/{index_definition_id}/currentSnapshot
     * Current Index Values for index definition
     * 
     * @param indexDefinitionId 
     * @return kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexesIndexDefinitionIdCurrentSnapshotGet(indexDefinitionId: kotlin.String) : kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry> {
        val localVarResponse = v1IndexesIndexDefinitionIdCurrentSnapshotGetWithHttpInfo(indexDefinitionId = indexDefinitionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexes/{index_definition_id}/currentSnapshot
     * Current Index Values for index definition
     * 
     * @param indexDefinitionId 
     * @return ApiResponse<kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexesIndexDefinitionIdCurrentSnapshotGetWithHttpInfo(indexDefinitionId: kotlin.String) : ApiResponse<kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>?> {
        val localVariableConfig = v1IndexesIndexDefinitionIdCurrentSnapshotGetRequestConfig(indexDefinitionId = indexDefinitionId)

        return request<Unit, kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexesIndexDefinitionIdCurrentSnapshotGet
     *
     * @param indexDefinitionId 
     * @return RequestConfig
     */
    fun v1IndexesIndexDefinitionIdCurrentSnapshotGetRequestConfig(indexDefinitionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexes/{index_definition_id}/currentSnapshot".replace("{"+"index_definition_id"+"}", encodeURIComponent(indexDefinitionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/indexes/{index_definition_id}/historySnapshot
     * Historical Index Values for index definition
     * 
     * @param indexDefinitionId 
     * @param time  (optional)
     * @return kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexesIndexDefinitionIdHistorySnapshotGet(indexDefinitionId: kotlin.String, time: java.time.OffsetDateTime? = null) : kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry> {
        val localVarResponse = v1IndexesIndexDefinitionIdHistorySnapshotGetWithHttpInfo(indexDefinitionId = indexDefinitionId, time = time)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexes/{index_definition_id}/historySnapshot
     * Historical Index Values for index definition
     * 
     * @param indexDefinitionId 
     * @param time  (optional)
     * @return ApiResponse<kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexesIndexDefinitionIdHistorySnapshotGetWithHttpInfo(indexDefinitionId: kotlin.String, time: java.time.OffsetDateTime?) : ApiResponse<kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>?> {
        val localVariableConfig = v1IndexesIndexDefinitionIdHistorySnapshotGetRequestConfig(indexDefinitionId = indexDefinitionId, time = time)

        return request<Unit, kotlin.collections.List<IndexesIndexDefinitionSnapshotEntry>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexesIndexDefinitionIdHistorySnapshotGet
     *
     * @param indexDefinitionId 
     * @param time  (optional)
     * @return RequestConfig
     */
    fun v1IndexesIndexDefinitionIdHistorySnapshotGetRequestConfig(indexDefinitionId: kotlin.String, time: java.time.OffsetDateTime?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (time != null) {
                    put("time", listOf(parseDateToQueryString(time)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexes/{index_definition_id}/historySnapshot".replace("{"+"index_definition_id"+"}", encodeURIComponent(indexDefinitionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/indexes/{index_id}/current
     * Current Index Value
     * 
     * @param indexId 
     * @return IndexesIndexValue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexesIndexIdCurrentGet(indexId: kotlin.String) : IndexesIndexValue {
        val localVarResponse = v1IndexesIndexIdCurrentGetWithHttpInfo(indexId = indexId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IndexesIndexValue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexes/{index_id}/current
     * Current Index Value
     * 
     * @param indexId 
     * @return ApiResponse<IndexesIndexValue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexesIndexIdCurrentGetWithHttpInfo(indexId: kotlin.String) : ApiResponse<IndexesIndexValue?> {
        val localVariableConfig = v1IndexesIndexIdCurrentGetRequestConfig(indexId = indexId)

        return request<Unit, IndexesIndexValue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexesIndexIdCurrentGet
     *
     * @param indexId 
     * @return RequestConfig
     */
    fun v1IndexesIndexIdCurrentGetRequestConfig(indexId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexes/{index_id}/current".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/indexes/{index_id}/history
     * Historical Index Value w/Composition
     * 
     * @param indexId 
     * @param timeStart  (optional)
     * @param timeEnd  (optional)
     * @param limit  (optional, default to 100)
     * @return kotlin.collections.List<IndexesIndexValue>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexesIndexIdHistoryGet(indexId: kotlin.String, timeStart: java.time.OffsetDateTime? = null, timeEnd: java.time.OffsetDateTime? = null, limit: kotlin.Int? = 100) : kotlin.collections.List<IndexesIndexValue> {
        val localVarResponse = v1IndexesIndexIdHistoryGetWithHttpInfo(indexId = indexId, timeStart = timeStart, timeEnd = timeEnd, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IndexesIndexValue>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexes/{index_id}/history
     * Historical Index Value w/Composition
     * 
     * @param indexId 
     * @param timeStart  (optional)
     * @param timeEnd  (optional)
     * @param limit  (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<IndexesIndexValue>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexesIndexIdHistoryGetWithHttpInfo(indexId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<IndexesIndexValue>?> {
        val localVariableConfig = v1IndexesIndexIdHistoryGetRequestConfig(indexId = indexId, timeStart = timeStart, timeEnd = timeEnd, limit = limit)

        return request<Unit, kotlin.collections.List<IndexesIndexValue>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexesIndexIdHistoryGet
     *
     * @param indexId 
     * @param timeStart  (optional)
     * @param timeEnd  (optional)
     * @param limit  (optional, default to 100)
     * @return RequestConfig
     */
    fun v1IndexesIndexIdHistoryGetRequestConfig(indexId: kotlin.String, timeStart: java.time.OffsetDateTime?, timeEnd: java.time.OffsetDateTime?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timeStart != null) {
                    put("time_start", listOf(parseDateToQueryString(timeStart)))
                }
                if (timeEnd != null) {
                    put("time_end", listOf(parseDateToQueryString(timeEnd)))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexes/{index_id}/history".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/indexes/{index_id}/timeseries
     * Timeseries Index Value
     * 
     * @param indexId 
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;)
     * @param timeStart Timeseries starting time in ISO 8601
     * @param timeEnd Timeseries ending time in ISO 8601
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return kotlin.collections.List<IndexesIndexTimeseriesItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1IndexesIndexIdTimeseriesGet(indexId: kotlin.String, periodId: kotlin.String, timeStart: kotlin.String, timeEnd: kotlin.String, limit: kotlin.Int? = 100) : kotlin.collections.List<IndexesIndexTimeseriesItem> {
        val localVarResponse = v1IndexesIndexIdTimeseriesGetWithHttpInfo(indexId = indexId, periodId = periodId, timeStart = timeStart, timeEnd = timeEnd, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IndexesIndexTimeseriesItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indexes/{index_id}/timeseries
     * Timeseries Index Value
     * 
     * @param indexId 
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;)
     * @param timeStart Timeseries starting time in ISO 8601
     * @param timeEnd Timeseries ending time in ISO 8601
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<IndexesIndexTimeseriesItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun v1IndexesIndexIdTimeseriesGetWithHttpInfo(indexId: kotlin.String, periodId: kotlin.String, timeStart: kotlin.String, timeEnd: kotlin.String, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<IndexesIndexTimeseriesItem>?> {
        val localVariableConfig = v1IndexesIndexIdTimeseriesGetRequestConfig(indexId = indexId, periodId = periodId, timeStart = timeStart, timeEnd = timeEnd, limit = limit)

        return request<Unit, kotlin.collections.List<IndexesIndexTimeseriesItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation v1IndexesIndexIdTimeseriesGet
     *
     * @param indexId 
     * @param periodId Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;)
     * @param timeStart Timeseries starting time in ISO 8601
     * @param timeEnd Timeseries ending time in ISO 8601
     * @param limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
     * @return RequestConfig
     */
    fun v1IndexesIndexIdTimeseriesGetRequestConfig(indexId: kotlin.String, periodId: kotlin.String, timeStart: kotlin.String, timeEnd: kotlin.String, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("period_id", listOf(periodId.toString()))
                put("time_start", listOf(timeStart.toString()))
                put("time_end", listOf(timeEnd.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indexes/{index_id}/timeseries".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
