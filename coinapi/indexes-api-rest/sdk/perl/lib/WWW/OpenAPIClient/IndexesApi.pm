=begin comment

Indexes REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: v1
Contact: support@apibricks.io
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::IndexesApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# v1_indexdef_input_data_index_definition_id_all_get
#
# Returns all data inputs for a specific index definition
#
# @param string $index_definition_id  (required)
{
    my $params = {
    'index_definition_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_indexdef_input_data_index_definition_id_all_get' } = {
        summary => 'Returns all data inputs for a specific index definition',
        params => $params,
        returns => 'ARRAY[IndexesIndexDefinitionInputData]',
        };
}
# @return ARRAY[IndexesIndexDefinitionInputData]
#
sub v1_indexdef_input_data_index_definition_id_all_get {
    my ($self, %args) = @_;

    # verify the required parameter 'index_definition_id' is set
    unless (exists $args{'index_definition_id'}) {
      croak("Missing the required parameter 'index_definition_id' when calling v1_indexdef_input_data_index_definition_id_all_get");
    }

    # parse inputs
    my $_resource_path = '/v1/indexdef/input-data/{index_definition_id}/all';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'index_definition_id'}) {
        my $_base_variable = "{" . "index_definition_id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'index_definition_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[IndexesIndexDefinitionInputData]', $response);
    return $_response_object;
}

#
# v1_indexdef_input_data_index_definition_id_get
#
# Returns data inputs for certain index definition and time
#
# @param string $index_definition_id  (required)
# @param DATE_TIME $time  (optional)
# @param boolean $enabled_only  (optional, default to false)
# @param boolean $pending_only  (optional, default to false)
# @param string $filter_asset_id  (optional)
# @param boolean $with_status_info  (optional, default to false)
{
    my $params = {
    'index_definition_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'time' => {
        data_type => 'DATE_TIME',
        description => '',
        required => '0',
    },
    'enabled_only' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'pending_only' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'filter_asset_id' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'with_status_info' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_indexdef_input_data_index_definition_id_get' } = {
        summary => 'Returns data inputs for certain index definition and time',
        params => $params,
        returns => 'ARRAY[IndexesIndexDefinitionSnapshotEntry]',
        };
}
# @return ARRAY[IndexesIndexDefinitionSnapshotEntry]
#
sub v1_indexdef_input_data_index_definition_id_get {
    my ($self, %args) = @_;

    # verify the required parameter 'index_definition_id' is set
    unless (exists $args{'index_definition_id'}) {
      croak("Missing the required parameter 'index_definition_id' when calling v1_indexdef_input_data_index_definition_id_get");
    }

    # parse inputs
    my $_resource_path = '/v1/indexdef/input-data/{index_definition_id}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'time'}) {
        $query_params->{'time'} = $self->{api_client}->to_query_value($args{'time'});
    }

    # query params
    if ( exists $args{'enabled_only'}) {
        $query_params->{'enabled_only'} = $self->{api_client}->to_query_value($args{'enabled_only'});
    }

    # query params
    if ( exists $args{'pending_only'}) {
        $query_params->{'pending_only'} = $self->{api_client}->to_query_value($args{'pending_only'});
    }

    # query params
    if ( exists $args{'filter_asset_id'}) {
        $query_params->{'filter_asset_id'} = $self->{api_client}->to_query_value($args{'filter_asset_id'});
    }

    # query params
    if ( exists $args{'with_status_info'}) {
        $query_params->{'with_status_info'} = $self->{api_client}->to_query_value($args{'with_status_info'});
    }

    # path params
    if ( exists $args{'index_definition_id'}) {
        my $_base_variable = "{" . "index_definition_id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'index_definition_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[IndexesIndexDefinitionSnapshotEntry]', $response);
    return $_response_object;
}

#
# v1_indexdef_multiasset_get
#
# Get all multi-asset weights
#
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'v1_indexdef_multiasset_get' } = {
        summary => 'Get all multi-asset weights',
        params => $params,
        returns => 'ARRAY[IndexesIndexMultiAssetWeight]',
        };
}
# @return ARRAY[IndexesIndexMultiAssetWeight]
#
sub v1_indexdef_multiasset_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/indexdef/multiasset';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[IndexesIndexMultiAssetWeight]', $response);
    return $_response_object;
}

#
# v1_indexdef_multiasset_index_id_get
#
# Get multi-asset weights for specific index
#
# @param string $index_id  (required)
{
    my $params = {
    'index_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_indexdef_multiasset_index_id_get' } = {
        summary => 'Get multi-asset weights for specific index',
        params => $params,
        returns => 'ARRAY[IndexesIndexMultiAssetWeight]',
        };
}
# @return ARRAY[IndexesIndexMultiAssetWeight]
#
sub v1_indexdef_multiasset_index_id_get {
    my ($self, %args) = @_;

    # verify the required parameter 'index_id' is set
    unless (exists $args{'index_id'}) {
      croak("Missing the required parameter 'index_id' when calling v1_indexdef_multiasset_index_id_get");
    }

    # parse inputs
    my $_resource_path = '/v1/indexdef/multiasset/{index_id}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'index_id'}) {
        my $_base_variable = "{" . "index_id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'index_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[IndexesIndexMultiAssetWeight]', $response);
    return $_response_object;
}

#
# v1_indexes_get
#
# List indexes
#
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'v1_indexes_get' } = {
        summary => 'List indexes',
        params => $params,
        returns => 'ARRAY[IndexesIndexIdentifier]',
        };
}
# @return ARRAY[IndexesIndexIdentifier]
#
sub v1_indexes_get {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/v1/indexes';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[IndexesIndexIdentifier]', $response);
    return $_response_object;
}

#
# v1_indexes_index_definition_id_current_snapshot_get
#
# Current Index Values for index definition
#
# @param string $index_definition_id  (required)
{
    my $params = {
    'index_definition_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_indexes_index_definition_id_current_snapshot_get' } = {
        summary => 'Current Index Values for index definition',
        params => $params,
        returns => 'ARRAY[IndexesIndexDefinitionSnapshotEntry]',
        };
}
# @return ARRAY[IndexesIndexDefinitionSnapshotEntry]
#
sub v1_indexes_index_definition_id_current_snapshot_get {
    my ($self, %args) = @_;

    # verify the required parameter 'index_definition_id' is set
    unless (exists $args{'index_definition_id'}) {
      croak("Missing the required parameter 'index_definition_id' when calling v1_indexes_index_definition_id_current_snapshot_get");
    }

    # parse inputs
    my $_resource_path = '/v1/indexes/{index_definition_id}/currentSnapshot';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'index_definition_id'}) {
        my $_base_variable = "{" . "index_definition_id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'index_definition_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[IndexesIndexDefinitionSnapshotEntry]', $response);
    return $_response_object;
}

#
# v1_indexes_index_definition_id_history_snapshot_get
#
# Historical Index Values for index definition
#
# @param string $index_definition_id  (required)
# @param DATE_TIME $time  (optional)
{
    my $params = {
    'index_definition_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'time' => {
        data_type => 'DATE_TIME',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_indexes_index_definition_id_history_snapshot_get' } = {
        summary => 'Historical Index Values for index definition',
        params => $params,
        returns => 'ARRAY[IndexesIndexDefinitionSnapshotEntry]',
        };
}
# @return ARRAY[IndexesIndexDefinitionSnapshotEntry]
#
sub v1_indexes_index_definition_id_history_snapshot_get {
    my ($self, %args) = @_;

    # verify the required parameter 'index_definition_id' is set
    unless (exists $args{'index_definition_id'}) {
      croak("Missing the required parameter 'index_definition_id' when calling v1_indexes_index_definition_id_history_snapshot_get");
    }

    # parse inputs
    my $_resource_path = '/v1/indexes/{index_definition_id}/historySnapshot';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'time'}) {
        $query_params->{'time'} = $self->{api_client}->to_query_value($args{'time'});
    }

    # path params
    if ( exists $args{'index_definition_id'}) {
        my $_base_variable = "{" . "index_definition_id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'index_definition_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[IndexesIndexDefinitionSnapshotEntry]', $response);
    return $_response_object;
}

#
# v1_indexes_index_id_current_get
#
# Current Index Value
#
# @param string $index_id  (required)
{
    my $params = {
    'index_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_indexes_index_id_current_get' } = {
        summary => 'Current Index Value',
        params => $params,
        returns => 'IndexesIndexValue',
        };
}
# @return IndexesIndexValue
#
sub v1_indexes_index_id_current_get {
    my ($self, %args) = @_;

    # verify the required parameter 'index_id' is set
    unless (exists $args{'index_id'}) {
      croak("Missing the required parameter 'index_id' when calling v1_indexes_index_id_current_get");
    }

    # parse inputs
    my $_resource_path = '/v1/indexes/{index_id}/current';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'index_id'}) {
        my $_base_variable = "{" . "index_id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'index_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('IndexesIndexValue', $response);
    return $_response_object;
}

#
# v1_indexes_index_id_history_get
#
# Historical Index Value w/Composition
#
# @param string $index_id  (required)
# @param DATE_TIME $time_start  (optional)
# @param DATE_TIME $time_end  (optional)
# @param int $limit  (optional, default to 100)
{
    my $params = {
    'index_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'time_start' => {
        data_type => 'DATE_TIME',
        description => '',
        required => '0',
    },
    'time_end' => {
        data_type => 'DATE_TIME',
        description => '',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_indexes_index_id_history_get' } = {
        summary => 'Historical Index Value w/Composition',
        params => $params,
        returns => 'ARRAY[IndexesIndexValue]',
        };
}
# @return ARRAY[IndexesIndexValue]
#
sub v1_indexes_index_id_history_get {
    my ($self, %args) = @_;

    # verify the required parameter 'index_id' is set
    unless (exists $args{'index_id'}) {
      croak("Missing the required parameter 'index_id' when calling v1_indexes_index_id_history_get");
    }

    # parse inputs
    my $_resource_path = '/v1/indexes/{index_id}/history';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'time_start'}) {
        $query_params->{'time_start'} = $self->{api_client}->to_query_value($args{'time_start'});
    }

    # query params
    if ( exists $args{'time_end'}) {
        $query_params->{'time_end'} = $self->{api_client}->to_query_value($args{'time_end'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # path params
    if ( exists $args{'index_id'}) {
        my $_base_variable = "{" . "index_id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'index_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[IndexesIndexValue]', $response);
    return $_response_object;
}

#
# v1_indexes_index_id_timeseries_get
#
# Timeseries Index Value
#
# @param string $index_id  (required)
# @param string $period_id Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;) (required)
# @param string $time_start Timeseries starting time in ISO 8601 (required)
# @param string $time_end Timeseries ending time in ISO 8601 (required)
# @param int $limit Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)
{
    my $params = {
    'index_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'period_id' => {
        data_type => 'string',
        description => 'Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;)',
        required => '1',
    },
    'time_start' => {
        data_type => 'string',
        description => 'Timeseries starting time in ISO 8601',
        required => '1',
    },
    'time_end' => {
        data_type => 'string',
        description => 'Timeseries ending time in ISO 8601',
        required => '1',
    },
    'limit' => {
        data_type => 'int',
        description => 'Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'v1_indexes_index_id_timeseries_get' } = {
        summary => 'Timeseries Index Value',
        params => $params,
        returns => 'ARRAY[IndexesIndexTimeseriesItem]',
        };
}
# @return ARRAY[IndexesIndexTimeseriesItem]
#
sub v1_indexes_index_id_timeseries_get {
    my ($self, %args) = @_;

    # verify the required parameter 'index_id' is set
    unless (exists $args{'index_id'}) {
      croak("Missing the required parameter 'index_id' when calling v1_indexes_index_id_timeseries_get");
    }

    # verify the required parameter 'period_id' is set
    unless (exists $args{'period_id'}) {
      croak("Missing the required parameter 'period_id' when calling v1_indexes_index_id_timeseries_get");
    }

    # verify the required parameter 'time_start' is set
    unless (exists $args{'time_start'}) {
      croak("Missing the required parameter 'time_start' when calling v1_indexes_index_id_timeseries_get");
    }

    # verify the required parameter 'time_end' is set
    unless (exists $args{'time_end'}) {
      croak("Missing the required parameter 'time_end' when calling v1_indexes_index_id_timeseries_get");
    }

    # parse inputs
    my $_resource_path = '/v1/indexes/{index_id}/timeseries';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'text/json', 'application/x-msgpack');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'period_id'}) {
        $query_params->{'period_id'} = $self->{api_client}->to_query_value($args{'period_id'});
    }

    # query params
    if ( exists $args{'time_start'}) {
        $query_params->{'time_start'} = $self->{api_client}->to_query_value($args{'time_start'});
    }

    # query params
    if ( exists $args{'time_end'}) {
        $query_params->{'time_end'} = $self->{api_client}->to_query_value($args{'time_end'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # path params
    if ( exists $args{'index_id'}) {
        my $_base_variable = "{" . "index_id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'index_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(ApiKey )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[IndexesIndexTimeseriesItem]', $response);
    return $_response_object;
}

1;
