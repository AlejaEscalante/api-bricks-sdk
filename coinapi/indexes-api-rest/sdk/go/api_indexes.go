/*
Indexes REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: support@apibricks.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// IndexesAPIService IndexesAPI service
type IndexesAPIService service

type ApiV1IndexdefInputDataIndexDefinitionIdAllGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
	indexDefinitionId string
}

func (r ApiV1IndexdefInputDataIndexDefinitionIdAllGetRequest) Execute() ([]IndexesIndexDefinitionInputData, *http.Response, error) {
	return r.ApiService.V1IndexdefInputDataIndexDefinitionIdAllGetExecute(r)
}

/*
V1IndexdefInputDataIndexDefinitionIdAllGet Returns all data inputs for a specific index definition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexDefinitionId
 @return ApiV1IndexdefInputDataIndexDefinitionIdAllGetRequest
*/
func (a *IndexesAPIService) V1IndexdefInputDataIndexDefinitionIdAllGet(ctx context.Context, indexDefinitionId string) ApiV1IndexdefInputDataIndexDefinitionIdAllGetRequest {
	return ApiV1IndexdefInputDataIndexDefinitionIdAllGetRequest{
		ApiService: a,
		ctx: ctx,
		indexDefinitionId: indexDefinitionId,
	}
}

// Execute executes the request
//  @return []IndexesIndexDefinitionInputData
func (a *IndexesAPIService) V1IndexdefInputDataIndexDefinitionIdAllGetExecute(r ApiV1IndexdefInputDataIndexDefinitionIdAllGetRequest) ([]IndexesIndexDefinitionInputData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexesIndexDefinitionInputData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexdefInputDataIndexDefinitionIdAllGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexdef/input-data/{index_definition_id}/all"
	localVarPath = strings.Replace(localVarPath, "{"+"index_definition_id"+"}", url.PathEscape(parameterValueToString(r.indexDefinitionId, "indexDefinitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IndexdefInputDataIndexDefinitionIdGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
	indexDefinitionId string
	time *time.Time
	enabledOnly *bool
	pendingOnly *bool
	filterAssetId *string
	withStatusInfo *bool
}

func (r ApiV1IndexdefInputDataIndexDefinitionIdGetRequest) Time(time time.Time) ApiV1IndexdefInputDataIndexDefinitionIdGetRequest {
	r.time = &time
	return r
}

func (r ApiV1IndexdefInputDataIndexDefinitionIdGetRequest) EnabledOnly(enabledOnly bool) ApiV1IndexdefInputDataIndexDefinitionIdGetRequest {
	r.enabledOnly = &enabledOnly
	return r
}

func (r ApiV1IndexdefInputDataIndexDefinitionIdGetRequest) PendingOnly(pendingOnly bool) ApiV1IndexdefInputDataIndexDefinitionIdGetRequest {
	r.pendingOnly = &pendingOnly
	return r
}

func (r ApiV1IndexdefInputDataIndexDefinitionIdGetRequest) FilterAssetId(filterAssetId string) ApiV1IndexdefInputDataIndexDefinitionIdGetRequest {
	r.filterAssetId = &filterAssetId
	return r
}

func (r ApiV1IndexdefInputDataIndexDefinitionIdGetRequest) WithStatusInfo(withStatusInfo bool) ApiV1IndexdefInputDataIndexDefinitionIdGetRequest {
	r.withStatusInfo = &withStatusInfo
	return r
}

func (r ApiV1IndexdefInputDataIndexDefinitionIdGetRequest) Execute() ([]IndexesIndexDefinitionSnapshotEntry, *http.Response, error) {
	return r.ApiService.V1IndexdefInputDataIndexDefinitionIdGetExecute(r)
}

/*
V1IndexdefInputDataIndexDefinitionIdGet Returns data inputs for certain index definition and time

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexDefinitionId
 @return ApiV1IndexdefInputDataIndexDefinitionIdGetRequest
*/
func (a *IndexesAPIService) V1IndexdefInputDataIndexDefinitionIdGet(ctx context.Context, indexDefinitionId string) ApiV1IndexdefInputDataIndexDefinitionIdGetRequest {
	return ApiV1IndexdefInputDataIndexDefinitionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		indexDefinitionId: indexDefinitionId,
	}
}

// Execute executes the request
//  @return []IndexesIndexDefinitionSnapshotEntry
func (a *IndexesAPIService) V1IndexdefInputDataIndexDefinitionIdGetExecute(r ApiV1IndexdefInputDataIndexDefinitionIdGetRequest) ([]IndexesIndexDefinitionSnapshotEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexesIndexDefinitionSnapshotEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexdefInputDataIndexDefinitionIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexdef/input-data/{index_definition_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index_definition_id"+"}", url.PathEscape(parameterValueToString(r.indexDefinitionId, "indexDefinitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "form", "")
	}
	if r.enabledOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled_only", r.enabledOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.enabledOnly = &defaultValue
	}
	if r.pendingOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pending_only", r.pendingOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.pendingOnly = &defaultValue
	}
	if r.filterAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_asset_id", r.filterAssetId, "form", "")
	}
	if r.withStatusInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_status_info", r.withStatusInfo, "form", "")
	} else {
		var defaultValue bool = false
		r.withStatusInfo = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IndexdefMultiassetGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
}

func (r ApiV1IndexdefMultiassetGetRequest) Execute() ([]IndexesIndexMultiAssetWeight, *http.Response, error) {
	return r.ApiService.V1IndexdefMultiassetGetExecute(r)
}

/*
V1IndexdefMultiassetGet Get all multi-asset weights

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1IndexdefMultiassetGetRequest
*/
func (a *IndexesAPIService) V1IndexdefMultiassetGet(ctx context.Context) ApiV1IndexdefMultiassetGetRequest {
	return ApiV1IndexdefMultiassetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IndexesIndexMultiAssetWeight
func (a *IndexesAPIService) V1IndexdefMultiassetGetExecute(r ApiV1IndexdefMultiassetGetRequest) ([]IndexesIndexMultiAssetWeight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexesIndexMultiAssetWeight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexdefMultiassetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexdef/multiasset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IndexdefMultiassetIndexIdGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
	indexId string
}

func (r ApiV1IndexdefMultiassetIndexIdGetRequest) Execute() ([]IndexesIndexMultiAssetWeight, *http.Response, error) {
	return r.ApiService.V1IndexdefMultiassetIndexIdGetExecute(r)
}

/*
V1IndexdefMultiassetIndexIdGet Get multi-asset weights for specific index

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId
 @return ApiV1IndexdefMultiassetIndexIdGetRequest
*/
func (a *IndexesAPIService) V1IndexdefMultiassetIndexIdGet(ctx context.Context, indexId string) ApiV1IndexdefMultiassetIndexIdGetRequest {
	return ApiV1IndexdefMultiassetIndexIdGetRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
	}
}

// Execute executes the request
//  @return []IndexesIndexMultiAssetWeight
func (a *IndexesAPIService) V1IndexdefMultiassetIndexIdGetExecute(r ApiV1IndexdefMultiassetIndexIdGetRequest) ([]IndexesIndexMultiAssetWeight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexesIndexMultiAssetWeight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexdefMultiassetIndexIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexdef/multiasset/{index_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index_id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IndexesGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
}

func (r ApiV1IndexesGetRequest) Execute() ([]IndexesIndexIdentifier, *http.Response, error) {
	return r.ApiService.V1IndexesGetExecute(r)
}

/*
V1IndexesGet List indexes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1IndexesGetRequest
*/
func (a *IndexesAPIService) V1IndexesGet(ctx context.Context) ApiV1IndexesGetRequest {
	return ApiV1IndexesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IndexesIndexIdentifier
func (a *IndexesAPIService) V1IndexesGetExecute(r ApiV1IndexesGetRequest) ([]IndexesIndexIdentifier, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexesIndexIdentifier
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IndexesIndexDefinitionIdCurrentSnapshotGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
	indexDefinitionId string
}

func (r ApiV1IndexesIndexDefinitionIdCurrentSnapshotGetRequest) Execute() ([]IndexesIndexDefinitionSnapshotEntry, *http.Response, error) {
	return r.ApiService.V1IndexesIndexDefinitionIdCurrentSnapshotGetExecute(r)
}

/*
V1IndexesIndexDefinitionIdCurrentSnapshotGet Current Index Values for index definition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexDefinitionId
 @return ApiV1IndexesIndexDefinitionIdCurrentSnapshotGetRequest
*/
func (a *IndexesAPIService) V1IndexesIndexDefinitionIdCurrentSnapshotGet(ctx context.Context, indexDefinitionId string) ApiV1IndexesIndexDefinitionIdCurrentSnapshotGetRequest {
	return ApiV1IndexesIndexDefinitionIdCurrentSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
		indexDefinitionId: indexDefinitionId,
	}
}

// Execute executes the request
//  @return []IndexesIndexDefinitionSnapshotEntry
func (a *IndexesAPIService) V1IndexesIndexDefinitionIdCurrentSnapshotGetExecute(r ApiV1IndexesIndexDefinitionIdCurrentSnapshotGetRequest) ([]IndexesIndexDefinitionSnapshotEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexesIndexDefinitionSnapshotEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexesIndexDefinitionIdCurrentSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexes/{index_definition_id}/currentSnapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"index_definition_id"+"}", url.PathEscape(parameterValueToString(r.indexDefinitionId, "indexDefinitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IndexesIndexDefinitionIdHistorySnapshotGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
	indexDefinitionId string
	time *time.Time
}

func (r ApiV1IndexesIndexDefinitionIdHistorySnapshotGetRequest) Time(time time.Time) ApiV1IndexesIndexDefinitionIdHistorySnapshotGetRequest {
	r.time = &time
	return r
}

func (r ApiV1IndexesIndexDefinitionIdHistorySnapshotGetRequest) Execute() ([]IndexesIndexDefinitionSnapshotEntry, *http.Response, error) {
	return r.ApiService.V1IndexesIndexDefinitionIdHistorySnapshotGetExecute(r)
}

/*
V1IndexesIndexDefinitionIdHistorySnapshotGet Historical Index Values for index definition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexDefinitionId
 @return ApiV1IndexesIndexDefinitionIdHistorySnapshotGetRequest
*/
func (a *IndexesAPIService) V1IndexesIndexDefinitionIdHistorySnapshotGet(ctx context.Context, indexDefinitionId string) ApiV1IndexesIndexDefinitionIdHistorySnapshotGetRequest {
	return ApiV1IndexesIndexDefinitionIdHistorySnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
		indexDefinitionId: indexDefinitionId,
	}
}

// Execute executes the request
//  @return []IndexesIndexDefinitionSnapshotEntry
func (a *IndexesAPIService) V1IndexesIndexDefinitionIdHistorySnapshotGetExecute(r ApiV1IndexesIndexDefinitionIdHistorySnapshotGetRequest) ([]IndexesIndexDefinitionSnapshotEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexesIndexDefinitionSnapshotEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexesIndexDefinitionIdHistorySnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexes/{index_definition_id}/historySnapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"index_definition_id"+"}", url.PathEscape(parameterValueToString(r.indexDefinitionId, "indexDefinitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IndexesIndexIdCurrentGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
	indexId string
}

func (r ApiV1IndexesIndexIdCurrentGetRequest) Execute() (*IndexesIndexValue, *http.Response, error) {
	return r.ApiService.V1IndexesIndexIdCurrentGetExecute(r)
}

/*
V1IndexesIndexIdCurrentGet Current Index Value

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId
 @return ApiV1IndexesIndexIdCurrentGetRequest
*/
func (a *IndexesAPIService) V1IndexesIndexIdCurrentGet(ctx context.Context, indexId string) ApiV1IndexesIndexIdCurrentGetRequest {
	return ApiV1IndexesIndexIdCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
	}
}

// Execute executes the request
//  @return IndexesIndexValue
func (a *IndexesAPIService) V1IndexesIndexIdCurrentGetExecute(r ApiV1IndexesIndexIdCurrentGetRequest) (*IndexesIndexValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IndexesIndexValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexesIndexIdCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexes/{index_id}/current"
	localVarPath = strings.Replace(localVarPath, "{"+"index_id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IndexesIndexIdHistoryGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
	indexId string
	timeStart *time.Time
	timeEnd *time.Time
	limit *int32
}

func (r ApiV1IndexesIndexIdHistoryGetRequest) TimeStart(timeStart time.Time) ApiV1IndexesIndexIdHistoryGetRequest {
	r.timeStart = &timeStart
	return r
}

func (r ApiV1IndexesIndexIdHistoryGetRequest) TimeEnd(timeEnd time.Time) ApiV1IndexesIndexIdHistoryGetRequest {
	r.timeEnd = &timeEnd
	return r
}

func (r ApiV1IndexesIndexIdHistoryGetRequest) Limit(limit int32) ApiV1IndexesIndexIdHistoryGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1IndexesIndexIdHistoryGetRequest) Execute() ([]IndexesIndexValue, *http.Response, error) {
	return r.ApiService.V1IndexesIndexIdHistoryGetExecute(r)
}

/*
V1IndexesIndexIdHistoryGet Historical Index Value w/Composition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId
 @return ApiV1IndexesIndexIdHistoryGetRequest
*/
func (a *IndexesAPIService) V1IndexesIndexIdHistoryGet(ctx context.Context, indexId string) ApiV1IndexesIndexIdHistoryGetRequest {
	return ApiV1IndexesIndexIdHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
	}
}

// Execute executes the request
//  @return []IndexesIndexValue
func (a *IndexesAPIService) V1IndexesIndexIdHistoryGetExecute(r ApiV1IndexesIndexIdHistoryGetRequest) ([]IndexesIndexValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexesIndexValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexesIndexIdHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexes/{index_id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"index_id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IndexesIndexIdTimeseriesGetRequest struct {
	ctx context.Context
	ApiService *IndexesAPIService
	indexId string
	periodId *string
	timeStart *string
	timeEnd *string
	limit *int32
}

// Identifier of requested timeseries period (e.g. &#x60;5SEC&#x60; or &#x60;1DAY&#x60;)
func (r ApiV1IndexesIndexIdTimeseriesGetRequest) PeriodId(periodId string) ApiV1IndexesIndexIdTimeseriesGetRequest {
	r.periodId = &periodId
	return r
}

// Timeseries starting time in ISO 8601
func (r ApiV1IndexesIndexIdTimeseriesGetRequest) TimeStart(timeStart string) ApiV1IndexesIndexIdTimeseriesGetRequest {
	r.timeStart = &timeStart
	return r
}

// Timeseries ending time in ISO 8601
func (r ApiV1IndexesIndexIdTimeseriesGetRequest) TimeEnd(timeEnd string) ApiV1IndexesIndexIdTimeseriesGetRequest {
	r.timeEnd = &timeEnd
	return r
}

// Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request)
func (r ApiV1IndexesIndexIdTimeseriesGetRequest) Limit(limit int32) ApiV1IndexesIndexIdTimeseriesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV1IndexesIndexIdTimeseriesGetRequest) Execute() ([]IndexesIndexTimeseriesItem, *http.Response, error) {
	return r.ApiService.V1IndexesIndexIdTimeseriesGetExecute(r)
}

/*
V1IndexesIndexIdTimeseriesGet Timeseries Index Value

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId 
 @return ApiV1IndexesIndexIdTimeseriesGetRequest
*/
func (a *IndexesAPIService) V1IndexesIndexIdTimeseriesGet(ctx context.Context, indexId string) ApiV1IndexesIndexIdTimeseriesGetRequest {
	return ApiV1IndexesIndexIdTimeseriesGetRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
	}
}

// Execute executes the request
//  @return []IndexesIndexTimeseriesItem
func (a *IndexesAPIService) V1IndexesIndexIdTimeseriesGetExecute(r ApiV1IndexesIndexIdTimeseriesGetRequest) ([]IndexesIndexTimeseriesItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexesIndexTimeseriesItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexesAPIService.V1IndexesIndexIdTimeseriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexes/{index_id}/timeseries"
	localVarPath = strings.Replace(localVarPath, "{"+"index_id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.periodId == nil {
		return localVarReturnValue, nil, reportError("periodId is required and must be specified")
	}
	if r.timeStart == nil {
		return localVarReturnValue, nil, reportError("timeStart is required and must be specified")
	}
	if r.timeEnd == nil {
		return localVarReturnValue, nil, reportError("timeEnd is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "period_id", r.periodId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/x-msgpack"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-CoinAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
