{-
   Exchange Rates Realtime REST API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.4
   Exchange Rates Realtime REST API API version: v1
   Contact: support@apibricks.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : ExchangeRatesRealtimeREST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module ExchangeRatesRealtimeREST.Model where

import ExchangeRatesRealtimeREST.Core
import ExchangeRatesRealtimeREST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AssetId
newtype AssetId = AssetId { unAssetId :: Text } deriving (P.Eq, P.Show)

-- ** AssetIdBase
newtype AssetIdBase = AssetIdBase { unAssetIdBase :: Text } deriving (P.Eq, P.Show)

-- ** AssetIdQuote
newtype AssetIdQuote = AssetIdQuote { unAssetIdQuote :: Text } deriving (P.Eq, P.Show)

-- ** FilterAssetId
newtype FilterAssetId = FilterAssetId { unFilterAssetId :: Text } deriving (P.Eq, P.Show)

-- ** Invert
newtype Invert = Invert { unInvert :: Bool } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: Int } deriving (P.Eq, P.Show)

-- * Models


-- ** V1Asset
-- | V1Asset
-- Represents an asset.
data V1Asset = V1Asset
  { v1AssetAssetId :: !(Maybe Text) -- ^ "asset_id" - Gets or sets the asset ID.
  , v1AssetName :: !(Maybe Text) -- ^ "name" - Gets or sets the name of the asset.
  , v1AssetTypeIsCrypto :: !(Maybe Int) -- ^ "type_is_crypto" - Gets or sets a value indicating whether the asset is a cryptocurrency.
  , v1AssetDataQuoteStart :: !(Maybe DateTime) -- ^ "data_quote_start" - Gets or sets the start date of quote data.
  , v1AssetDataQuoteEnd :: !(Maybe DateTime) -- ^ "data_quote_end" - Gets or sets the end date of quote data.
  , v1AssetDataOrderbookStart :: !(Maybe DateTime) -- ^ "data_orderbook_start" - Gets or sets the start date of order book data.
  , v1AssetDataOrderbookEnd :: !(Maybe DateTime) -- ^ "data_orderbook_end" - Gets or sets the end date of order book data.
  , v1AssetDataTradeStart :: !(Maybe DateTime) -- ^ "data_trade_start" - Gets or sets the start date of trade data.
  , v1AssetDataTradeEnd :: !(Maybe DateTime) -- ^ "data_trade_end" - Gets or sets the end date of trade data.
  , v1AssetDataSymbolsCount :: !(Maybe Integer) -- ^ "data_symbols_count" - Gets or sets the number of symbols.
  , v1AssetVolume1hrsUsd :: !(Maybe Double) -- ^ "volume_1hrs_usd" - Gets or sets the USD volume in the last 1 hour.
  , v1AssetVolume1dayUsd :: !(Maybe Double) -- ^ "volume_1day_usd" - Gets or sets the USD volume in the last 1 day.
  , v1AssetVolume1mthUsd :: !(Maybe Double) -- ^ "volume_1mth_usd" - Gets or sets the USD volume in the last 1 month.
  , v1AssetPriceUsd :: !(Maybe Double) -- ^ "price_usd" - Gets or sets the USD price of the asset.
  , v1AssetIdIcon :: !(Maybe Text) -- ^ "id_icon" - Gets or sets the ID of the icon for the asset.
  , v1AssetSupplyCurrent :: !(Maybe Double) -- ^ "supply_current" - Gets or sets the current supply of the asset.
  , v1AssetSupplyTotal :: !(Maybe Double) -- ^ "supply_total" - Gets or sets the total supply of the asset.
  , v1AssetSupplyMax :: !(Maybe Double) -- ^ "supply_max" - Gets or sets the maximum supply of the asset.
  , v1AssetChainAddresses :: !(Maybe [V1ChainNetworkAddress]) -- ^ "chain_addresses" - 
  , v1AssetDataStart :: !(Maybe Text) -- ^ /ReadOnly/ "data_start"
  , v1AssetDataEnd :: !(Maybe Text) -- ^ /ReadOnly/ "data_end"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Asset
instance A.FromJSON V1Asset where
  parseJSON = A.withObject "V1Asset" $ \o ->
    V1Asset
      <$> (o .:? "asset_id")
      <*> (o .:? "name")
      <*> (o .:? "type_is_crypto")
      <*> (o .:? "data_quote_start")
      <*> (o .:? "data_quote_end")
      <*> (o .:? "data_orderbook_start")
      <*> (o .:? "data_orderbook_end")
      <*> (o .:? "data_trade_start")
      <*> (o .:? "data_trade_end")
      <*> (o .:? "data_symbols_count")
      <*> (o .:? "volume_1hrs_usd")
      <*> (o .:? "volume_1day_usd")
      <*> (o .:? "volume_1mth_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "id_icon")
      <*> (o .:? "supply_current")
      <*> (o .:? "supply_total")
      <*> (o .:? "supply_max")
      <*> (o .:? "chain_addresses")
      <*> (o .:? "data_start")
      <*> (o .:? "data_end")

-- | ToJSON V1Asset
instance A.ToJSON V1Asset where
  toJSON V1Asset {..} =
   _omitNulls
      [ "asset_id" .= v1AssetAssetId
      , "name" .= v1AssetName
      , "type_is_crypto" .= v1AssetTypeIsCrypto
      , "data_quote_start" .= v1AssetDataQuoteStart
      , "data_quote_end" .= v1AssetDataQuoteEnd
      , "data_orderbook_start" .= v1AssetDataOrderbookStart
      , "data_orderbook_end" .= v1AssetDataOrderbookEnd
      , "data_trade_start" .= v1AssetDataTradeStart
      , "data_trade_end" .= v1AssetDataTradeEnd
      , "data_symbols_count" .= v1AssetDataSymbolsCount
      , "volume_1hrs_usd" .= v1AssetVolume1hrsUsd
      , "volume_1day_usd" .= v1AssetVolume1dayUsd
      , "volume_1mth_usd" .= v1AssetVolume1mthUsd
      , "price_usd" .= v1AssetPriceUsd
      , "id_icon" .= v1AssetIdIcon
      , "supply_current" .= v1AssetSupplyCurrent
      , "supply_total" .= v1AssetSupplyTotal
      , "supply_max" .= v1AssetSupplyMax
      , "chain_addresses" .= v1AssetChainAddresses
      , "data_start" .= v1AssetDataStart
      , "data_end" .= v1AssetDataEnd
      ]


-- | Construct a value of type 'V1Asset' (by applying it's required fields, if any)
mkV1Asset
  :: V1Asset
mkV1Asset =
  V1Asset
  { v1AssetAssetId = Nothing
  , v1AssetName = Nothing
  , v1AssetTypeIsCrypto = Nothing
  , v1AssetDataQuoteStart = Nothing
  , v1AssetDataQuoteEnd = Nothing
  , v1AssetDataOrderbookStart = Nothing
  , v1AssetDataOrderbookEnd = Nothing
  , v1AssetDataTradeStart = Nothing
  , v1AssetDataTradeEnd = Nothing
  , v1AssetDataSymbolsCount = Nothing
  , v1AssetVolume1hrsUsd = Nothing
  , v1AssetVolume1dayUsd = Nothing
  , v1AssetVolume1mthUsd = Nothing
  , v1AssetPriceUsd = Nothing
  , v1AssetIdIcon = Nothing
  , v1AssetSupplyCurrent = Nothing
  , v1AssetSupplyTotal = Nothing
  , v1AssetSupplyMax = Nothing
  , v1AssetChainAddresses = Nothing
  , v1AssetDataStart = Nothing
  , v1AssetDataEnd = Nothing
  }

-- ** V1ChainNetworkAddress
-- | V1ChainNetworkAddress
-- Contains information about assets' chain network addresses
data V1ChainNetworkAddress = V1ChainNetworkAddress
  { v1ChainNetworkAddressChainId :: !(Maybe Text) -- ^ "chain_id" - Gets or sets chain id
  , v1ChainNetworkAddressNetworkId :: !(Maybe Text) -- ^ "network_id" - Gets or sets network id
  , v1ChainNetworkAddressAddress :: !(Maybe Text) -- ^ "address" - Gets or sets chain address
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ChainNetworkAddress
instance A.FromJSON V1ChainNetworkAddress where
  parseJSON = A.withObject "V1ChainNetworkAddress" $ \o ->
    V1ChainNetworkAddress
      <$> (o .:? "chain_id")
      <*> (o .:? "network_id")
      <*> (o .:? "address")

-- | ToJSON V1ChainNetworkAddress
instance A.ToJSON V1ChainNetworkAddress where
  toJSON V1ChainNetworkAddress {..} =
   _omitNulls
      [ "chain_id" .= v1ChainNetworkAddressChainId
      , "network_id" .= v1ChainNetworkAddressNetworkId
      , "address" .= v1ChainNetworkAddressAddress
      ]


-- | Construct a value of type 'V1ChainNetworkAddress' (by applying it's required fields, if any)
mkV1ChainNetworkAddress
  :: V1ChainNetworkAddress
mkV1ChainNetworkAddress =
  V1ChainNetworkAddress
  { v1ChainNetworkAddressChainId = Nothing
  , v1ChainNetworkAddressNetworkId = Nothing
  , v1ChainNetworkAddressAddress = Nothing
  }

-- ** V1ExchangeRate
-- | V1ExchangeRate
-- Represents an exchange rate.
data V1ExchangeRate = V1ExchangeRate
  { v1ExchangeRateTime :: !(Maybe DateTime) -- ^ "time" - Gets or sets the time of the exchange rate.
  , v1ExchangeRateAssetIdBase :: !(Maybe Text) -- ^ "asset_id_base" - Gets or sets the base asset ID of the exchange rate.
  , v1ExchangeRateAssetIdQuote :: !(Maybe Text) -- ^ "asset_id_quote" - Gets or sets the quote asset ID of the exchange rate.
  , v1ExchangeRateRate :: !(Maybe Double) -- ^ "rate" - Gets or sets the exchange rate value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ExchangeRate
instance A.FromJSON V1ExchangeRate where
  parseJSON = A.withObject "V1ExchangeRate" $ \o ->
    V1ExchangeRate
      <$> (o .:? "time")
      <*> (o .:? "asset_id_base")
      <*> (o .:? "asset_id_quote")
      <*> (o .:? "rate")

-- | ToJSON V1ExchangeRate
instance A.ToJSON V1ExchangeRate where
  toJSON V1ExchangeRate {..} =
   _omitNulls
      [ "time" .= v1ExchangeRateTime
      , "asset_id_base" .= v1ExchangeRateAssetIdBase
      , "asset_id_quote" .= v1ExchangeRateAssetIdQuote
      , "rate" .= v1ExchangeRateRate
      ]


-- | Construct a value of type 'V1ExchangeRate' (by applying it's required fields, if any)
mkV1ExchangeRate
  :: V1ExchangeRate
mkV1ExchangeRate =
  V1ExchangeRate
  { v1ExchangeRateTime = Nothing
  , v1ExchangeRateAssetIdBase = Nothing
  , v1ExchangeRateAssetIdQuote = Nothing
  , v1ExchangeRateRate = Nothing
  }

-- ** V1ExchangeRates
-- | V1ExchangeRates
-- Represents exchange rates for a specific base asset.
data V1ExchangeRates = V1ExchangeRates
  { v1ExchangeRatesAssetIdBase :: !(Maybe Text) -- ^ "asset_id_base" - Gets or sets the base asset ID.
  , v1ExchangeRatesRates :: !(Maybe [V1ExchangeRatesRate]) -- ^ "rates" - Gets or sets the list of exchange rates.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ExchangeRates
instance A.FromJSON V1ExchangeRates where
  parseJSON = A.withObject "V1ExchangeRates" $ \o ->
    V1ExchangeRates
      <$> (o .:? "asset_id_base")
      <*> (o .:? "rates")

-- | ToJSON V1ExchangeRates
instance A.ToJSON V1ExchangeRates where
  toJSON V1ExchangeRates {..} =
   _omitNulls
      [ "asset_id_base" .= v1ExchangeRatesAssetIdBase
      , "rates" .= v1ExchangeRatesRates
      ]


-- | Construct a value of type 'V1ExchangeRates' (by applying it's required fields, if any)
mkV1ExchangeRates
  :: V1ExchangeRates
mkV1ExchangeRates =
  V1ExchangeRates
  { v1ExchangeRatesAssetIdBase = Nothing
  , v1ExchangeRatesRates = Nothing
  }

-- ** V1ExchangeRatesRate
-- | V1ExchangeRatesRate
-- Represents an exchange rate within a collection of exchange rates.
data V1ExchangeRatesRate = V1ExchangeRatesRate
  { v1ExchangeRatesRateTime :: !(Maybe DateTime) -- ^ "time" - Gets or sets the time of the exchange rate.
  , v1ExchangeRatesRateAssetIdQuote :: !(Maybe Text) -- ^ "asset_id_quote" - Gets or sets the quote asset ID of the exchange rate.
  , v1ExchangeRatesRateRate :: !(Maybe Double) -- ^ "rate" - Gets or sets the exchange rate value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ExchangeRatesRate
instance A.FromJSON V1ExchangeRatesRate where
  parseJSON = A.withObject "V1ExchangeRatesRate" $ \o ->
    V1ExchangeRatesRate
      <$> (o .:? "time")
      <*> (o .:? "asset_id_quote")
      <*> (o .:? "rate")

-- | ToJSON V1ExchangeRatesRate
instance A.ToJSON V1ExchangeRatesRate where
  toJSON V1ExchangeRatesRate {..} =
   _omitNulls
      [ "time" .= v1ExchangeRatesRateTime
      , "asset_id_quote" .= v1ExchangeRatesRateAssetIdQuote
      , "rate" .= v1ExchangeRatesRateRate
      ]


-- | Construct a value of type 'V1ExchangeRatesRate' (by applying it's required fields, if any)
mkV1ExchangeRatesRate
  :: V1ExchangeRatesRate
mkV1ExchangeRatesRate =
  V1ExchangeRatesRate
  { v1ExchangeRatesRateTime = Nothing
  , v1ExchangeRatesRateAssetIdQuote = Nothing
  , v1ExchangeRatesRateRate = Nothing
  }

-- ** V1Icon
-- | V1Icon
-- Represents an icon.
data V1Icon = V1Icon
  { v1IconExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Gets or sets the exchange ID associated with the icon.
  , v1IconAssetId :: !(Maybe Text) -- ^ "asset_id" - Gets or sets the asset ID associated with the icon.
  , v1IconUrl :: !(Maybe Text) -- ^ "url" - Gets or sets the URL of the icon.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Icon
instance A.FromJSON V1Icon where
  parseJSON = A.withObject "V1Icon" $ \o ->
    V1Icon
      <$> (o .:? "exchange_id")
      <*> (o .:? "asset_id")
      <*> (o .:? "url")

-- | ToJSON V1Icon
instance A.ToJSON V1Icon where
  toJSON V1Icon {..} =
   _omitNulls
      [ "exchange_id" .= v1IconExchangeId
      , "asset_id" .= v1IconAssetId
      , "url" .= v1IconUrl
      ]


-- | Construct a value of type 'V1Icon' (by applying it's required fields, if any)
mkV1Icon
  :: V1Icon
mkV1Icon =
  V1Icon
  { v1IconExchangeId = Nothing
  , v1IconAssetId = Nothing
  , v1IconUrl = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyAPIKey
data AuthApiKeyAPIKey =
  AuthApiKeyAPIKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyAPIKey where
  applyAuthMethod _ a@(AuthApiKeyAPIKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


