// <auto-generated>
/*
 * Exchange Rates Realtime REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Client;
using APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Model;
using System.Diagnostics.CodeAnalysis;

namespace APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IExchangeRatesApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ExchangeRatesApiEvents Events { get; }

        /// <summary>
        /// Get specific rate
        /// </summary>
        /// <remarks>
        /// Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSpecificRateApiResponse"/>&gt;</returns>
        Task<IGetSpecificRateApiResponse> GetSpecificRateAsync(string assetIdBase, string assetIdQuote, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get specific rate
        /// </summary>
        /// <remarks>
        /// Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
        /// </remarks>
        /// <param name="assetIdBase">Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSpecificRateApiResponse"/>?&gt;</returns>
        Task<IGetSpecificRateApiResponse?> GetSpecificRateOrDefaultAsync(string assetIdBase, string assetIdQuote, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all current rates
        /// </summary>
        /// <remarks>
        /// Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response (optional) (optional)</param>
        /// <param name="invert">True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;) (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>&gt;</returns>
        Task<IV1ExchangerateAssetIdBaseGetApiResponse> V1ExchangerateAssetIdBaseGetAsync(string assetIdBase, Option<string> filterAssetId = default, Option<bool> invert = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all current rates
        /// </summary>
        /// <remarks>
        /// Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
        /// </remarks>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response (optional) (optional)</param>
        /// <param name="invert">True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;) (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>?&gt;</returns>
        Task<IV1ExchangerateAssetIdBaseGetApiResponse?> V1ExchangerateAssetIdBaseGetOrDefaultAsync(string assetIdBase, Option<string> filterAssetId = default, Option<bool> invert = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetSpecificRateApiResponse"/>
    /// </summary>
    public interface IGetSpecificRateApiResponse : APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Client.IApiResponse, IOk<APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Model.V1ExchangeRate?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>
    /// </summary>
    public interface IV1ExchangerateAssetIdBaseGetApiResponse : APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Client.IApiResponse, IOk<APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Model.V1ExchangeRates?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ExchangeRatesApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSpecificRate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSpecificRate;

        internal void ExecuteOnGetSpecificRate(ExchangeRatesApi.GetSpecificRateApiResponse apiResponse)
        {
            OnGetSpecificRate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSpecificRate(Exception exception)
        {
            OnErrorGetSpecificRate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExchangerateAssetIdBaseGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExchangerateAssetIdBaseGet;

        internal void ExecuteOnV1ExchangerateAssetIdBaseGet(ExchangeRatesApi.V1ExchangerateAssetIdBaseGetApiResponse apiResponse)
        {
            OnV1ExchangerateAssetIdBaseGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExchangerateAssetIdBaseGet(Exception exception)
        {
            OnErrorV1ExchangerateAssetIdBaseGet?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ExchangeRatesApi : IExchangeRatesApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ExchangeRatesApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ExchangeRatesApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExchangeRatesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ExchangeRatesApi(ILogger<ExchangeRatesApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ExchangeRatesApiEvents exchangeRatesApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ExchangeRatesApi>();
            HttpClient = httpClient;
            Events = exchangeRatesApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatGetSpecificRate(ref string assetIdBase, ref string assetIdQuote);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <returns></returns>
        private void ValidateGetSpecificRate(string assetIdBase, string assetIdQuote)
        {
            if (assetIdBase == null)
                throw new ArgumentNullException(nameof(assetIdBase));

            if (assetIdQuote == null)
                throw new ArgumentNullException(nameof(assetIdQuote));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        private void AfterGetSpecificRateDefaultImplementation(IGetSpecificRateApiResponse apiResponseLocalVar, string assetIdBase, string assetIdQuote)
        {
            bool suppressDefaultLog = false;
            AfterGetSpecificRate(ref suppressDefaultLog, apiResponseLocalVar, assetIdBase, assetIdQuote);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        partial void AfterGetSpecificRate(ref bool suppressDefaultLog, IGetSpecificRateApiResponse apiResponseLocalVar, string assetIdBase, string assetIdQuote);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        private void OnErrorGetSpecificRateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, string assetIdQuote)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSpecificRate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assetIdBase, assetIdQuote);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        partial void OnErrorGetSpecificRate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, string assetIdQuote);

        /// <summary>
        /// Get specific rate Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
        /// </summary>
        /// <param name="assetIdBase">Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSpecificRateApiResponse"/>&gt;</returns>
        public async Task<IGetSpecificRateApiResponse?> GetSpecificRateOrDefaultAsync(string assetIdBase, string assetIdQuote, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSpecificRateAsync(assetIdBase, assetIdQuote, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get specific rate Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSpecificRateApiResponse"/>&gt;</returns>
        public async Task<IGetSpecificRateApiResponse> GetSpecificRateAsync(string assetIdBase, string assetIdQuote, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSpecificRate(assetIdBase, assetIdQuote);

                FormatGetSpecificRate(ref assetIdBase, ref assetIdQuote);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchangerate/{asset_id_base}/{asset_id_quote}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchangerate/{asset_id_base}/{asset_id_quote}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id_base%7D", Uri.EscapeDataString(assetIdBase.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id_quote%7D", Uri.EscapeDataString(assetIdQuote.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSpecificRateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSpecificRateApiResponse>();

                        GetSpecificRateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchangerate/{asset_id_base}/{asset_id_quote}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSpecificRateDefaultImplementation(apiResponseLocalVar, assetIdBase, assetIdQuote);

                        Events.ExecuteOnGetSpecificRate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSpecificRateDefaultImplementation(e, "/v1/exchangerate/{asset_id_base}/{asset_id_quote}", uriBuilderLocalVar.Path, assetIdBase, assetIdQuote);
                Events.ExecuteOnErrorGetSpecificRate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSpecificRateApiResponse"/>
        /// </summary>
        public partial class GetSpecificRateApiResponse : APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Client.ApiResponse, IGetSpecificRateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSpecificRateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSpecificRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSpecificRateApiResponse(ILogger<GetSpecificRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Model.V1ExchangeRate? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Model.V1ExchangeRate>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Model.V1ExchangeRate? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExchangerateAssetIdBaseGet(ref string assetIdBase, ref Option<string> filterAssetId, ref Option<bool> invert);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <returns></returns>
        private void ValidateV1ExchangerateAssetIdBaseGet(string assetIdBase, Option<string> filterAssetId)
        {
            if (assetIdBase == null)
                throw new ArgumentNullException(nameof(assetIdBase));

            if (filterAssetId.IsSet && filterAssetId.Value == null)
                throw new ArgumentNullException(nameof(filterAssetId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <param name="invert"></param>
        private void AfterV1ExchangerateAssetIdBaseGetDefaultImplementation(IV1ExchangerateAssetIdBaseGetApiResponse apiResponseLocalVar, string assetIdBase, Option<string> filterAssetId, Option<bool> invert)
        {
            bool suppressDefaultLog = false;
            AfterV1ExchangerateAssetIdBaseGet(ref suppressDefaultLog, apiResponseLocalVar, assetIdBase, filterAssetId, invert);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <param name="invert"></param>
        partial void AfterV1ExchangerateAssetIdBaseGet(ref bool suppressDefaultLog, IV1ExchangerateAssetIdBaseGetApiResponse apiResponseLocalVar, string assetIdBase, Option<string> filterAssetId, Option<bool> invert);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <param name="invert"></param>
        private void OnErrorV1ExchangerateAssetIdBaseGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, Option<string> filterAssetId, Option<bool> invert)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExchangerateAssetIdBaseGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assetIdBase, filterAssetId, invert);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <param name="invert"></param>
        partial void OnErrorV1ExchangerateAssetIdBaseGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, Option<string> filterAssetId, Option<bool> invert);

        /// <summary>
        /// Get all current rates Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
        /// </summary>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response (optional) (optional)</param>
        /// <param name="invert">True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;) (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangerateAssetIdBaseGetApiResponse?> V1ExchangerateAssetIdBaseGetOrDefaultAsync(string assetIdBase, Option<string> filterAssetId = default, Option<bool> invert = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExchangerateAssetIdBaseGetAsync(assetIdBase, filterAssetId, invert, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all current rates Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response (optional) (optional)</param>
        /// <param name="invert">True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;) (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangerateAssetIdBaseGetApiResponse> V1ExchangerateAssetIdBaseGetAsync(string assetIdBase, Option<string> filterAssetId = default, Option<bool> invert = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExchangerateAssetIdBaseGet(assetIdBase, filterAssetId);

                FormatV1ExchangerateAssetIdBaseGet(ref assetIdBase, ref filterAssetId, ref invert);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchangerate/{asset_id_base}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchangerate/{asset_id_base}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id_base%7D", Uri.EscapeDataString(assetIdBase.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (filterAssetId.IsSet)
                        parseQueryStringLocalVar["filter_asset_id"] = ClientUtils.ParameterToString(filterAssetId.Value);

                    if (invert.IsSet)
                        parseQueryStringLocalVar["invert"] = ClientUtils.ParameterToString(invert.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json",
                        "application/x-msgpack"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<V1ExchangerateAssetIdBaseGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExchangerateAssetIdBaseGetApiResponse>();

                        V1ExchangerateAssetIdBaseGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchangerate/{asset_id_base}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterV1ExchangerateAssetIdBaseGetDefaultImplementation(apiResponseLocalVar, assetIdBase, filterAssetId, invert);

                        Events.ExecuteOnV1ExchangerateAssetIdBaseGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExchangerateAssetIdBaseGetDefaultImplementation(e, "/v1/exchangerate/{asset_id_base}", uriBuilderLocalVar.Path, assetIdBase, filterAssetId, invert);
                Events.ExecuteOnErrorV1ExchangerateAssetIdBaseGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExchangerateAssetIdBaseGetApiResponse"/>
        /// </summary>
        public partial class V1ExchangerateAssetIdBaseGetApiResponse : APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Client.ApiResponse, IV1ExchangerateAssetIdBaseGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExchangerateAssetIdBaseGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExchangerateAssetIdBaseGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangerateAssetIdBaseGetApiResponse(ILogger<V1ExchangerateAssetIdBaseGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Model.V1ExchangeRates? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Model.V1ExchangeRates>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out APIBricks.CoinAPI.ExchangeRatesAPI.Realtime.REST.V1.Model.V1ExchangeRates? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
