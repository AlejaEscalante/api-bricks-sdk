{-
   EMS - Managed Cloud REST API

   This section will provide necessary information about the `CoinAPI EMS Managed Cloud REST API` protocol.  <br/><br/> This API is used to manage the overall deployment of **Execution Management System API** (`EMS API`) software,  which means that in this API, you define the accounts, credentials, and configurations for the order destinations or identify the CoinAPI endpoints where you need to connect to access the `EMS API`.  <br/><br/> Implemented Standards:   * [HTTP1.0](https://datatracker.ietf.org/doc/html/rfc1945)  * [HTTP1.1](https://datatracker.ietf.org/doc/html/rfc2616)  * [HTTP2.0](https://datatracker.ietf.org/doc/html/rfc7540)   ### Endpoints <table>   <thead>     <tr>       <th>Environment</th>       <th>Url</th>     </tr>   </thead>   <tbody>     <tr>       <td>Production</td>       <td><code>https://ems-mgmt.coinapi.io/</code></td>     </tr>     <tr>       <td>Sandbox</td>       <td><code>https://ems-mgmt-sandbox.coinapi.io/</code></td>     </tr>   </tbody> </table>  ### Authentication  To use resources that require authorized access, you will need to provide an API key to us when making HTTP requests.  There are 2 methods for passing the API key to us, you only need to use one:   1. Custom authorization header named `X-CoinAPI-Key`  2. Query string parameter named `apikey`  #### Custom authorization header  You can authorize by providing additional custom header named `X-CoinAPI-Key` and API key as its value.  Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY`, then the authorization header you should send to us will look like: <br/><br/> `X-CoinAPI-Key: 73034021-THIS-IS-SAMPLE-KEY`  <aside class=\"success\">This method is recommended by us and you should use it in production environments.</aside>  #### Query string authorization parameter  You can authorize by providing an additional parameter named `apikey` with a value equal to your API key in the query string of your HTTP request.  Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY` and that you want to request all accounts, then your query string should look like this:  <br/><br/> `GET /v1/accounts?apikey=73034021-THIS-IS-SAMPLE-KEY`  <aside class=\"notice\"> Query string method may be more practical for development activities. </aside> 

   OpenAPI Version: 3.0.1
   EMS - Managed Cloud REST API API version: v1
   Contact: support@coinapi.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : EMS-ManagedCloudREST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module EMS-ManagedCloudREST.Model where

import EMS-ManagedCloudREST.Core
import EMS-ManagedCloudREST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** ExchangeId
newtype ExchangeId = ExchangeId { unExchangeId :: [Text] } deriving (P.Eq, P.Show)

-- ** FilterExchangeId
newtype FilterExchangeId = FilterExchangeId { unFilterExchangeId :: [Text] } deriving (P.Eq, P.Show)

-- * Models


-- ** AccountData
-- | AccountData
data AccountData = AccountData
  { accountDataExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  &lt;code&gt;BITSTAMP&lt;/code&gt; &lt;code&gt;BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70&#x60;&lt;/code&gt; &lt;code&gt;BITSTAMP/2574&lt;/code&gt; Allowed separators between the exchange identifier and the tag: &lt;code&gt;~/.,:;\\!@#$%^&amp;*-_+&#x3D;.&lt;/code&gt; 
  , accountDataParameters :: !(Maybe [KeyValue]) -- ^ "parameters" - Parameters required to log into the exchange
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountData
instance A.FromJSON AccountData where
  parseJSON = A.withObject "AccountData" $ \o ->
    AccountData
      <$> (o .:? "exchange_id")
      <*> (o .:? "parameters")

-- | ToJSON AccountData
instance A.ToJSON AccountData where
  toJSON AccountData {..} =
   _omitNulls
      [ "exchange_id" .= accountDataExchangeId
      , "parameters" .= accountDataParameters
      ]


-- | Construct a value of type 'AccountData' (by applying it's required fields, if any)
mkAccountData
  :: AccountData
mkAccountData =
  AccountData
  { accountDataExchangeId = Nothing
  , accountDataParameters = Nothing
  }

-- ** AccountEndpoint
-- | AccountEndpoint
data AccountEndpoint = AccountEndpoint
  { accountEndpointExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  &lt;code&gt;BITSTAMP&lt;/code&gt; &lt;code&gt;BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70&#x60;&lt;/code&gt; &lt;code&gt;BITSTAMP/2574&lt;/code&gt; Allowed separators between the exchange identifier and the tag: &lt;code&gt;~/.,:;\\!@#$%^&amp;*-_+&#x3D;.&lt;/code&gt; 
  , accountEndpointLocationId :: !(Maybe Text) -- ^ "location_id" - Location identifier
  , accountEndpointEndpointSchema :: !(Maybe Text) -- ^ "endpoint_schema" - Endpoint schema
  , accountEndpointEndpointHost :: !(Maybe Text) -- ^ "endpoint_host" - Endpoint host
  , accountEndpointEndpointUrl :: !(Maybe Text) -- ^ "endpoint_url" - Endpoint URL
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountEndpoint
instance A.FromJSON AccountEndpoint where
  parseJSON = A.withObject "AccountEndpoint" $ \o ->
    AccountEndpoint
      <$> (o .:? "exchange_id")
      <*> (o .:? "location_id")
      <*> (o .:? "endpoint_schema")
      <*> (o .:? "endpoint_host")
      <*> (o .:? "endpoint_url")

-- | ToJSON AccountEndpoint
instance A.ToJSON AccountEndpoint where
  toJSON AccountEndpoint {..} =
   _omitNulls
      [ "exchange_id" .= accountEndpointExchangeId
      , "location_id" .= accountEndpointLocationId
      , "endpoint_schema" .= accountEndpointEndpointSchema
      , "endpoint_host" .= accountEndpointEndpointHost
      , "endpoint_url" .= accountEndpointEndpointUrl
      ]


-- | Construct a value of type 'AccountEndpoint' (by applying it's required fields, if any)
mkAccountEndpoint
  :: AccountEndpoint
mkAccountEndpoint =
  AccountEndpoint
  { accountEndpointExchangeId = Nothing
  , accountEndpointLocationId = Nothing
  , accountEndpointEndpointSchema = Nothing
  , accountEndpointEndpointHost = Nothing
  , accountEndpointEndpointUrl = Nothing
  }

-- ** AccountInfo
-- | AccountInfo
data AccountInfo = AccountInfo
  { accountInfoExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  &lt;code&gt;BITSTAMP&lt;/code&gt; &lt;code&gt;BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70&#x60;&lt;/code&gt; &lt;code&gt;BITSTAMP/2574&lt;/code&gt; Allowed separators between the exchange identifier and the tag: &lt;code&gt;~/.,:;\\!@#$%^&amp;*-_+&#x3D;.&lt;/code&gt; 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountInfo
instance A.FromJSON AccountInfo where
  parseJSON = A.withObject "AccountInfo" $ \o ->
    AccountInfo
      <$> (o .:? "exchange_id")

-- | ToJSON AccountInfo
instance A.ToJSON AccountInfo where
  toJSON AccountInfo {..} =
   _omitNulls
      [ "exchange_id" .= accountInfoExchangeId
      ]


-- | Construct a value of type 'AccountInfo' (by applying it's required fields, if any)
mkAccountInfo
  :: AccountInfo
mkAccountInfo =
  AccountInfo
  { accountInfoExchangeId = Nothing
  }

-- ** ExchangeLoginRequire
-- | ExchangeLoginRequire
data ExchangeLoginRequire = ExchangeLoginRequire
  { exchangeLoginRequireExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  &lt;code&gt;BITSTAMP&lt;/code&gt; &lt;code&gt;BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70&#x60;&lt;/code&gt; &lt;code&gt;BITSTAMP/2574&lt;/code&gt; Allowed separators between the exchange identifier and the tag: &lt;code&gt;~/.,:;\\!@#$%^&amp;*-_+&#x3D;.&lt;/code&gt; 
  , exchangeLoginRequireLocationId :: !(Maybe Text) -- ^ "location_id" - Location identifier
  , exchangeLoginRequireRequiredParameters :: !(Maybe [Text]) -- ^ "required_parameters" - Parameters required to log into the exchange
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExchangeLoginRequire
instance A.FromJSON ExchangeLoginRequire where
  parseJSON = A.withObject "ExchangeLoginRequire" $ \o ->
    ExchangeLoginRequire
      <$> (o .:? "exchange_id")
      <*> (o .:? "location_id")
      <*> (o .:? "required_parameters")

-- | ToJSON ExchangeLoginRequire
instance A.ToJSON ExchangeLoginRequire where
  toJSON ExchangeLoginRequire {..} =
   _omitNulls
      [ "exchange_id" .= exchangeLoginRequireExchangeId
      , "location_id" .= exchangeLoginRequireLocationId
      , "required_parameters" .= exchangeLoginRequireRequiredParameters
      ]


-- | Construct a value of type 'ExchangeLoginRequire' (by applying it's required fields, if any)
mkExchangeLoginRequire
  :: ExchangeLoginRequire
mkExchangeLoginRequire =
  ExchangeLoginRequire
  { exchangeLoginRequireExchangeId = Nothing
  , exchangeLoginRequireLocationId = Nothing
  , exchangeLoginRequireRequiredParameters = Nothing
  }

-- ** GetAccount
-- | GetAccount
data GetAccount = GetAccount
  { getAccountExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  &lt;code&gt;BITSTAMP&lt;/code&gt; &lt;code&gt;BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70&#x60;&lt;/code&gt; &lt;code&gt;BITSTAMP/2574&lt;/code&gt; Allowed separators between the exchange identifier and the tag: &lt;code&gt;~/.,:;\\!@#$%^&amp;*-_+&#x3D;.&lt;/code&gt; 
  , getAccountParameters :: !(Maybe [KeyValue]) -- ^ "parameters" - Exchange specific configuration parameters
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAccount
instance A.FromJSON GetAccount where
  parseJSON = A.withObject "GetAccount" $ \o ->
    GetAccount
      <$> (o .:? "exchange_id")
      <*> (o .:? "parameters")

-- | ToJSON GetAccount
instance A.ToJSON GetAccount where
  toJSON GetAccount {..} =
   _omitNulls
      [ "exchange_id" .= getAccountExchangeId
      , "parameters" .= getAccountParameters
      ]


-- | Construct a value of type 'GetAccount' (by applying it's required fields, if any)
mkGetAccount
  :: GetAccount
mkGetAccount =
  GetAccount
  { getAccountExchangeId = Nothing
  , getAccountParameters = Nothing
  }

-- ** KeyValue
-- | KeyValue
-- Key Value pair used to configure exchange accounts.
data KeyValue = KeyValue
  { keyValueKey :: !(Maybe Text) -- ^ "key"
  , keyValueValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON KeyValue
instance A.FromJSON KeyValue where
  parseJSON = A.withObject "KeyValue" $ \o ->
    KeyValue
      <$> (o .:? "key")
      <*> (o .:? "value")

-- | ToJSON KeyValue
instance A.ToJSON KeyValue where
  toJSON KeyValue {..} =
   _omitNulls
      [ "key" .= keyValueKey
      , "value" .= keyValueValue
      ]


-- | Construct a value of type 'KeyValue' (by applying it's required fields, if any)
mkKeyValue
  :: KeyValue
mkKeyValue =
  KeyValue
  { keyValueKey = Nothing
  , keyValueValue = Nothing
  }

-- ** Locations
-- | Locations
data Locations = Locations
  { locationsLocationId :: !(Maybe Text) -- ^ "location_id" - CoinAPI location identifier
  , locationsRegionName :: !(Maybe Text) -- ^ "region_name" - Identifier of the region by the location provider
  , locationsProviderName :: !(Maybe Text) -- ^ "provider_name" - Identifier of the location provider
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Locations
instance A.FromJSON Locations where
  parseJSON = A.withObject "Locations" $ \o ->
    Locations
      <$> (o .:? "location_id")
      <*> (o .:? "region_name")
      <*> (o .:? "provider_name")

-- | ToJSON Locations
instance A.ToJSON Locations where
  toJSON Locations {..} =
   _omitNulls
      [ "location_id" .= locationsLocationId
      , "region_name" .= locationsRegionName
      , "provider_name" .= locationsProviderName
      ]


-- | Construct a value of type 'Locations' (by applying it's required fields, if any)
mkLocations
  :: Locations
mkLocations =
  Locations
  { locationsLocationId = Nothing
  , locationsRegionName = Nothing
  , locationsProviderName = Nothing
  }

-- ** UpdateAccount
-- | UpdateAccount
data UpdateAccount = UpdateAccount
  { updateAccountExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  &lt;code&gt;BITSTAMP&lt;/code&gt; &lt;code&gt;BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70&#x60;&lt;/code&gt; &lt;code&gt;BITSTAMP/2574&lt;/code&gt; Allowed separators between the exchange identifier and the tag: &lt;code&gt;~/.,:;\\!@#$%^&amp;*-_+&#x3D;.&lt;/code&gt; 
  , updateAccountParameters :: !(Maybe [KeyValue]) -- ^ "parameters" - Parameters required to log into the exchange
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateAccount
instance A.FromJSON UpdateAccount where
  parseJSON = A.withObject "UpdateAccount" $ \o ->
    UpdateAccount
      <$> (o .:? "exchange_id")
      <*> (o .:? "parameters")

-- | ToJSON UpdateAccount
instance A.ToJSON UpdateAccount where
  toJSON UpdateAccount {..} =
   _omitNulls
      [ "exchange_id" .= updateAccountExchangeId
      , "parameters" .= updateAccountParameters
      ]


-- | Construct a value of type 'UpdateAccount' (by applying it's required fields, if any)
mkUpdateAccount
  :: UpdateAccount
mkUpdateAccount =
  UpdateAccount
  { updateAccountExchangeId = Nothing
  , updateAccountParameters = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyAPIKeyHeader
data AuthApiKeyAPIKeyHeader =
  AuthApiKeyAPIKeyHeader Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyAPIKeyHeader where
  applyAuthMethod _ a@(AuthApiKeyAPIKeyHeader secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-CoinAPI-Key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyAPIKeyQueryParam
data AuthApiKeyAPIKeyQueryParam =
  AuthApiKeyAPIKeyQueryParam Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyAPIKeyQueryParam where
  applyAuthMethod _ a@(AuthApiKeyAPIKeyQueryParam secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("apikey", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


