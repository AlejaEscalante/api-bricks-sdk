// @flow
/* eslint-disable no-use-before-define */
/**
 * EMS - Managed Cloud REST API
 * This section will provide necessary information about the `CoinAPI EMS Managed Cloud REST API` protocol.  <br/><br/> This API is used to manage the overall deployment of **Execution Management System API** (`EMS API`) software,  which means that in this API, you define the accounts, credentials, and configurations for the order destinations or identify the CoinAPI endpoints where you need to connect to access the `EMS API`.  <br/><br/> Implemented Standards:   * [HTTP1.0](https://datatracker.ietf.org/doc/html/rfc1945)  * [HTTP1.1](https://datatracker.ietf.org/doc/html/rfc2616)  * [HTTP2.0](https://datatracker.ietf.org/doc/html/rfc7540)   ### Endpoints <table>   <thead>     <tr>       <th>Environment</th>       <th>Url</th>     </tr>   </thead>   <tbody>     <tr>       <td>Production</td>       <td><code>https://ems-mgmt.coinapi.io/</code></td>     </tr>     <tr>       <td>Sandbox</td>       <td><code>https://ems-mgmt-sandbox.coinapi.io/</code></td>     </tr>   </tbody> </table>  ### Authentication  To use resources that require authorized access, you will need to provide an API key to us when making HTTP requests.  There are 2 methods for passing the API key to us, you only need to use one:   1. Custom authorization header named `X-CoinAPI-Key`  2. Query string parameter named `apikey`  #### Custom authorization header  You can authorize by providing additional custom header named `X-CoinAPI-Key` and API key as its value.  Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY`, then the authorization header you should send to us will look like: <br/><br/> `X-CoinAPI-Key: 73034021-THIS-IS-SAMPLE-KEY`  <aside class=\"success\">This method is recommended by us and you should use it in production environments.</aside>  #### Query string authorization parameter  You can authorize by providing an additional parameter named `apikey` with a value equal to your API key in the query string of your HTTP request.  Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY` and that you want to request all accounts, then your query string should look like this:  <br/><br/> `GET /v1/accounts?apikey=73034021-THIS-IS-SAMPLE-KEY`  <aside class=\"notice\"> Query string method may be more practical for development activities. </aside> 
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://ems-mgmt-sandbox.coinapi.io".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type AccountData = {
    /**
     * Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  <code>BITSTAMP</code> <code>BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70`</code> <code>BITSTAMP/2574</code> Allowed separators between the exchange identifier and the tag: <code>~/.,:;\\!@#$%^&*-_+=.</code> 
     * @type {string}
     * @memberof AccountData
     */
    exchange_id?: string;
    /**
     * Parameters required to log into the exchange
     * @type {Array<KeyValue>}
     * @memberof AccountData
     */
    parameters?: Array<KeyValue>;
}

/**
 * 
 * @export
 */
export type AccountEndpoint = {
    /**
     * Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  <code>BITSTAMP</code> <code>BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70`</code> <code>BITSTAMP/2574</code> Allowed separators between the exchange identifier and the tag: <code>~/.,:;\\!@#$%^&*-_+=.</code> 
     * @type {string}
     * @memberof AccountEndpoint
     */
    exchange_id?: string;
    /**
     * Location identifier
     * @type {string}
     * @memberof AccountEndpoint
     */
    location_id?: string;
    /**
     * Endpoint schema
     * @type {string}
     * @memberof AccountEndpoint
     */
    endpoint_schema?: string;
    /**
     * Endpoint host
     * @type {string}
     * @memberof AccountEndpoint
     */
    endpoint_host?: string;
    /**
     * Endpoint URL
     * @type {string}
     * @memberof AccountEndpoint
     */
    endpoint_url?: string;
}

/**
 * 
 * @export
 */
export type AccountInfo = {
    /**
     * Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  <code>BITSTAMP</code> <code>BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70`</code> <code>BITSTAMP/2574</code> Allowed separators between the exchange identifier and the tag: <code>~/.,:;\\!@#$%^&*-_+=.</code> 
     * @type {string}
     * @memberof AccountInfo
     */
    exchange_id?: string;
}

/**
 * 
 * @export
 */
export type ExchangeLoginRequire = {
    /**
     * Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  <code>BITSTAMP</code> <code>BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70`</code> <code>BITSTAMP/2574</code> Allowed separators between the exchange identifier and the tag: <code>~/.,:;\\!@#$%^&*-_+=.</code> 
     * @type {string}
     * @memberof ExchangeLoginRequire
     */
    exchange_id?: string;
    /**
     * Location identifier
     * @type {string}
     * @memberof ExchangeLoginRequire
     */
    location_id?: string;
    /**
     * Parameters required to log into the exchange
     * @type {Array<string>}
     * @memberof ExchangeLoginRequire
     */
    required_parameters?: Array<string>;
}

/**
 * 
 * @export
 */
export type GetAccount = {
    /**
     * Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  <code>BITSTAMP</code> <code>BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70`</code> <code>BITSTAMP/2574</code> Allowed separators between the exchange identifier and the tag: <code>~/.,:;\\!@#$%^&*-_+=.</code> 
     * @type {string}
     * @memberof GetAccount
     */
    exchange_id?: string;
    /**
     * Exchange specific configuration parameters
     * @type {Array<KeyValue>}
     * @memberof GetAccount
     */
    parameters?: Array<KeyValue>;
}

/**
 * Key Value pair used to configure exchange accounts.
 * @export
 */
export type KeyValue = {
    /**
     * 
     * @type {string}
     * @memberof KeyValue
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof KeyValue
     */
    value?: string;
}

/**
 * 
 * @export
 */
export type Locations = {
    /**
     * CoinAPI location identifier
     * @type {string}
     * @memberof Locations
     */
    location_id?: string;
    /**
     * Identifier of the region by the location provider
     * @type {string}
     * @memberof Locations
     */
    region_name?: string;
    /**
     * Identifier of the location provider
     * @type {string}
     * @memberof Locations
     */
    provider_name?: string;
}

/**
 * 
 * @export
 */
export type UpdateAccount = {
    /**
     * Exchange identifier and optional tag identifying specific account configured when the software will be managing multiple accounts on the same exchange; for eg:  <code>BITSTAMP</code> <code>BITSTAMP/7c177641-74bd-4dbe-9b01-2497c12a5f70`</code> <code>BITSTAMP/2574</code> Allowed separators between the exchange identifier and the tag: <code>~/.,:;\\!@#$%^&*-_+=.</code> 
     * @type {string}
     * @memberof UpdateAccount
     */
    exchange_id?: string;
    /**
     * Parameters required to log into the exchange
     * @type {Array<KeyValue>}
     * @memberof UpdateAccount
     */
    parameters?: Array<KeyValue>;
}



/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete specific exchange account maintained by the EMS API for your subscription.
         * @summary Delete account
         * @throws {RequiredError}
         */
        deleteAccount(exchangeId: Array<string>, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling deleteAccount.');
            }
            const localVarPath = `/v1/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            // authentication APIKeyQueryParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("apikey")
                    : configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            if (exchangeId) {
                localVarQueryParameter['exchange_id'] = exchangeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all exchange accounts maintained by the EMS API for your subscription.
         * @summary Delete all accounts
         * @throws {RequiredError}
         */
        deleteAccountAll(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/accounts/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            // authentication APIKeyQueryParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("apikey")
                    : configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all accounts maintained for your subscription in the EMS API.
         * @summary Get accounts
         * @throws {RequiredError}
         */
        getAccount(filterExchangeId?: Array<string>, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            // authentication APIKeyQueryParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("apikey")
                    : configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            if (filterExchangeId) {
                localVarQueryParameter['filter_exchange_id'] = filterExchangeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add new or update existing exchange account for your subscription in the EMS API.
         * @summary Add or update account
         * @throws {RequiredError}
         */
        persistAccount(body: AccountData, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling persistAccount.');
            }
            const localVarPath = `/v1/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            // authentication APIKeyQueryParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("apikey")
                    : configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AccountApiType = { 
    deleteAccount(exchangeId: Array<string>, options?: RequestOptions): Promise<Response>,

    deleteAccountAll(options?: RequestOptions): Promise<Response>,

    getAccount(filterExchangeId?: Array<string>, options?: RequestOptions): Promise<Array<GetAccount>>,

    persistAccount(body: AccountData, options?: RequestOptions): Promise<Response>,
}

/**
 * AccountApi - factory function to inject configuration 
 * @export
 */
export const AccountApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AccountApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Delete specific exchange account maintained by the EMS API for your subscription.
         * @summary Delete account
         * @throws {RequiredError}
         */
        deleteAccount(exchangeId: Array<string>, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).deleteAccount(exchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Delete all exchange accounts maintained by the EMS API for your subscription.
         * @summary Delete all accounts
         * @throws {RequiredError}
         */
        deleteAccountAll(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).deleteAccountAll(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all accounts maintained for your subscription in the EMS API.
         * @summary Get accounts
         * @throws {RequiredError}
         */
        getAccount(filterExchangeId?: Array<string>, options?: RequestOptions = {}): Promise<Array<GetAccount>> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccount(filterExchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Add new or update existing exchange account for your subscription in the EMS API.
         * @summary Add or update account
         * @throws {RequiredError}
         */
        persistAccount(body: AccountData, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).persistAccount(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CertificateApi - fetch parameter creator
 * @export
 */
export const CertificateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Providing PEM file with the Private Key, Public Key and the Certificate to authenticate to the EMS API.
         * @summary Get authentication certificate
         * @throws {RequiredError}
         */
        certificate(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/certificate/pem`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            // authentication APIKeyQueryParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("apikey")
                    : configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CertificateApiType = { 
    certificate(options?: RequestOptions): Promise<string>,
}

/**
 * CertificateApi - factory function to inject configuration 
 * @export
 */
export const CertificateApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CertificateApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Providing PEM file with the Private Key, Public Key and the Certificate to authenticate to the EMS API.
         * @summary Get authentication certificate
         * @throws {RequiredError}
         */
        certificate(options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CertificateApiFetchParamCreator(configuration).certificate(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * EndpointsApi - fetch parameter creator
 * @export
 */
export const EndpointsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all API endpoints that the EMS API expose for your subscription.
         * @summary Get API endpoints
         * @throws {RequiredError}
         */
        endpoints(filterExchangeId?: Array<string>, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/endpoints`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            // authentication APIKeyQueryParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("apikey")
                    : configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            if (filterExchangeId) {
                localVarQueryParameter['filter_exchange_id'] = filterExchangeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type EndpointsApiType = { 
    endpoints(filterExchangeId?: Array<string>, options?: RequestOptions): Promise<Array<AccountEndpoint>>,
}

/**
 * EndpointsApi - factory function to inject configuration 
 * @export
 */
export const EndpointsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): EndpointsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get all API endpoints that the EMS API expose for your subscription.
         * @summary Get API endpoints
         * @throws {RequiredError}
         */
        endpoints(filterExchangeId?: Array<string>, options?: RequestOptions = {}): Promise<Array<AccountEndpoint>> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpoints(filterExchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ExchangeApi - fetch parameter creator
 * @export
 */
export const ExchangeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information about the required parameters or server site location of the exchanges supported in the EMS API.
         * @summary Get exchange configuration
         * @throws {RequiredError}
         */
        exchangeLoginRequire(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/exchanges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            // authentication APIKeyQueryParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("apikey")
                    : configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ExchangeApiType = { 
    exchangeLoginRequire(options?: RequestOptions): Promise<Array<ExchangeLoginRequire>>,
}

/**
 * ExchangeApi - factory function to inject configuration 
 * @export
 */
export const ExchangeApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ExchangeApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get information about the required parameters or server site location of the exchanges supported in the EMS API.
         * @summary Get exchange configuration
         * @throws {RequiredError}
         */
        exchangeLoginRequire(options?: RequestOptions = {}): Promise<Array<ExchangeLoginRequire>> {
            const localVarFetchArgs = ExchangeApiFetchParamCreator(configuration).exchangeLoginRequire(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * LocationApi - fetch parameter creator
 * @export
 */
export const LocationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint providing information about the server site locations supported in the EMS API.
         * @summary Get site locations
         * @throws {RequiredError}
         */
        locations(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/locations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            // authentication APIKeyQueryParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("apikey")
                    : configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type LocationApiType = { 
    locations(options?: RequestOptions): Promise<Array<Locations>>,
}

/**
 * LocationApi - factory function to inject configuration 
 * @export
 */
export const LocationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): LocationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * This endpoint providing information about the server site locations supported in the EMS API.
         * @summary Get site locations
         * @throws {RequiredError}
         */
        locations(options?: RequestOptions = {}): Promise<Array<Locations>> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).locations(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    AccountApi: AccountApiType,

    CertificateApi: CertificateApiType,

    EndpointsApi: EndpointsApiType,

    ExchangeApi: ExchangeApiType,

    LocationApi: LocationApiType,
 }
