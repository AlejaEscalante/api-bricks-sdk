{-
   EMS - Managed Cloud REST API
   This section will provide necessary information about the `CoinAPI EMS Managed Cloud REST API` protocol.  <br/><br/> This API is used to manage the overall deployment of **Execution Management System API** (`EMS API`) software,  which means that in this API, you define the accounts, credentials, and configurations for the order destinations or identify the CoinAPI endpoints where you need to connect to access the `EMS API`.  <br/><br/> Implemented Standards:   * [HTTP1.0](https://datatracker.ietf.org/doc/html/rfc1945)  * [HTTP1.1](https://datatracker.ietf.org/doc/html/rfc2616)  * [HTTP2.0](https://datatracker.ietf.org/doc/html/rfc7540)   ### Endpoints <table>   <thead>     <tr>       <th>Environment</th>       <th>Url</th>     </tr>   </thead>   <tbody>     <tr>       <td>Production</td>       <td><code>https://ems-mgmt.coinapi.io/</code></td>     </tr>     <tr>       <td>Sandbox</td>       <td><code>https://ems-mgmt-sandbox.coinapi.io/</code></td>     </tr>   </tbody> </table>  ### Authentication  To use resources that require authorized access, you will need to provide an API key to us when making HTTP requests.  There are 2 methods for passing the API key to us, you only need to use one:   1. Custom authorization header named `X-CoinAPI-Key`  2. Query string parameter named `apikey`  #### Custom authorization header  You can authorize by providing additional custom header named `X-CoinAPI-Key` and API key as its value.  Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY`, then the authorization header you should send to us will look like: <br/><br/> `X-CoinAPI-Key: 73034021-THIS-IS-SAMPLE-KEY`  <aside class=\"success\">This method is recommended by us and you should use it in production environments.</aside>  #### Query string authorization parameter  You can authorize by providing an additional parameter named `apikey` with a value equal to your API key in the query string of your HTTP request.  Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY` and that you want to request all accounts, then your query string should look like this:  <br/><br/> `GET /v1/accounts?apikey=73034021-THIS-IS-SAMPLE-KEY`  <aside class=\"notice\"> Query string method may be more practical for development activities. </aside> 

   The version of the OpenAPI document: v1
   Contact: support@coinapi.io

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git

   DO NOT EDIT THIS FILE MANUALLY.

   For more info on generating Elm code, see https://eriktim.github.io/openapi-elm/
-}


module Api.Data exposing
    ( AccountData
    , AccountEndpoint
    , AccountInfo
    , ExchangeLoginRequire
    , GetAccount
    , KeyValue
    , Locations
    , UpdateAccount
    , encodeAccountData
    , encodeAccountEndpoint
    , encodeAccountInfo
    , encodeExchangeLoginRequire
    , encodeGetAccount
    , encodeKeyValue
    , encodeLocations
    , encodeUpdateAccount
    , accountDataDecoder
    , accountEndpointDecoder
    , accountInfoDecoder
    , exchangeLoginRequireDecoder
    , getAccountDecoder
    , keyValueDecoder
    , locationsDecoder
    , updateAccountDecoder
    )

import Api
import Dict
import Json.Decode
import Json.Encode


-- MODEL


type alias AccountData =
    { exchangeId : Maybe String
    , parameters : Maybe (List (KeyValue))
    }


type alias AccountEndpoint =
    { exchangeId : Maybe String
    , locationId : Maybe String
    , endpointSchema : Maybe String
    , endpointHost : Maybe String
    , endpointUrl : Maybe String
    }


type alias AccountInfo =
    { exchangeId : Maybe String
    }


type alias ExchangeLoginRequire =
    { exchangeId : Maybe String
    , locationId : Maybe String
    , requiredParameters : Maybe (List (String))
    }


type alias GetAccount =
    { exchangeId : Maybe String
    , parameters : Maybe (List (KeyValue))
    }


{-| Key Value pair used to configure exchange accounts.
-}
type alias KeyValue =
    { key : Maybe String
    , value : Maybe String
    }


type alias Locations =
    { locationId : Maybe String
    , regionName : Maybe String
    , providerName : Maybe String
    }


type alias UpdateAccount =
    { exchangeId : Maybe String
    , parameters : Maybe (List (KeyValue))
    }


-- ENCODER


encodeAccountData : AccountData -> Json.Encode.Value
encodeAccountData =
    encodeObject << encodeAccountDataPairs


encodeAccountDataWithTag : ( String, String ) -> AccountData -> Json.Encode.Value
encodeAccountDataWithTag (tagField, tag) model =
    encodeObject (encodeAccountDataPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAccountDataPairs : AccountData -> List EncodedField
encodeAccountDataPairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "parameters" (Json.Encode.list encodeKeyValue) model.parameters
            ]
    in
    pairs


encodeAccountEndpoint : AccountEndpoint -> Json.Encode.Value
encodeAccountEndpoint =
    encodeObject << encodeAccountEndpointPairs


encodeAccountEndpointWithTag : ( String, String ) -> AccountEndpoint -> Json.Encode.Value
encodeAccountEndpointWithTag (tagField, tag) model =
    encodeObject (encodeAccountEndpointPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAccountEndpointPairs : AccountEndpoint -> List EncodedField
encodeAccountEndpointPairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "location_id" Json.Encode.string model.locationId
            , maybeEncode "endpoint_schema" Json.Encode.string model.endpointSchema
            , maybeEncode "endpoint_host" Json.Encode.string model.endpointHost
            , maybeEncode "endpoint_url" Json.Encode.string model.endpointUrl
            ]
    in
    pairs


encodeAccountInfo : AccountInfo -> Json.Encode.Value
encodeAccountInfo =
    encodeObject << encodeAccountInfoPairs


encodeAccountInfoWithTag : ( String, String ) -> AccountInfo -> Json.Encode.Value
encodeAccountInfoWithTag (tagField, tag) model =
    encodeObject (encodeAccountInfoPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAccountInfoPairs : AccountInfo -> List EncodedField
encodeAccountInfoPairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            ]
    in
    pairs


encodeExchangeLoginRequire : ExchangeLoginRequire -> Json.Encode.Value
encodeExchangeLoginRequire =
    encodeObject << encodeExchangeLoginRequirePairs


encodeExchangeLoginRequireWithTag : ( String, String ) -> ExchangeLoginRequire -> Json.Encode.Value
encodeExchangeLoginRequireWithTag (tagField, tag) model =
    encodeObject (encodeExchangeLoginRequirePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeExchangeLoginRequirePairs : ExchangeLoginRequire -> List EncodedField
encodeExchangeLoginRequirePairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "location_id" Json.Encode.string model.locationId
            , maybeEncode "required_parameters" (Json.Encode.list Json.Encode.string) model.requiredParameters
            ]
    in
    pairs


encodeGetAccount : GetAccount -> Json.Encode.Value
encodeGetAccount =
    encodeObject << encodeGetAccountPairs


encodeGetAccountWithTag : ( String, String ) -> GetAccount -> Json.Encode.Value
encodeGetAccountWithTag (tagField, tag) model =
    encodeObject (encodeGetAccountPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeGetAccountPairs : GetAccount -> List EncodedField
encodeGetAccountPairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "parameters" (Json.Encode.list encodeKeyValue) model.parameters
            ]
    in
    pairs


encodeKeyValue : KeyValue -> Json.Encode.Value
encodeKeyValue =
    encodeObject << encodeKeyValuePairs


encodeKeyValueWithTag : ( String, String ) -> KeyValue -> Json.Encode.Value
encodeKeyValueWithTag (tagField, tag) model =
    encodeObject (encodeKeyValuePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeKeyValuePairs : KeyValue -> List EncodedField
encodeKeyValuePairs model =
    let
        pairs =
            [ maybeEncode "key" Json.Encode.string model.key
            , maybeEncode "value" Json.Encode.string model.value
            ]
    in
    pairs


encodeLocations : Locations -> Json.Encode.Value
encodeLocations =
    encodeObject << encodeLocationsPairs


encodeLocationsWithTag : ( String, String ) -> Locations -> Json.Encode.Value
encodeLocationsWithTag (tagField, tag) model =
    encodeObject (encodeLocationsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeLocationsPairs : Locations -> List EncodedField
encodeLocationsPairs model =
    let
        pairs =
            [ maybeEncode "location_id" Json.Encode.string model.locationId
            , maybeEncode "region_name" Json.Encode.string model.regionName
            , maybeEncode "provider_name" Json.Encode.string model.providerName
            ]
    in
    pairs


encodeUpdateAccount : UpdateAccount -> Json.Encode.Value
encodeUpdateAccount =
    encodeObject << encodeUpdateAccountPairs


encodeUpdateAccountWithTag : ( String, String ) -> UpdateAccount -> Json.Encode.Value
encodeUpdateAccountWithTag (tagField, tag) model =
    encodeObject (encodeUpdateAccountPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeUpdateAccountPairs : UpdateAccount -> List EncodedField
encodeUpdateAccountPairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "parameters" (Json.Encode.list encodeKeyValue) model.parameters
            ]
    in
    pairs


-- DECODER


accountDataDecoder : Json.Decode.Decoder AccountData
accountDataDecoder =
    Json.Decode.succeed AccountData
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "parameters" (Json.Decode.list keyValueDecoder) Nothing


accountEndpointDecoder : Json.Decode.Decoder AccountEndpoint
accountEndpointDecoder =
    Json.Decode.succeed AccountEndpoint
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "location_id" Json.Decode.string Nothing
        |> maybeDecode "endpoint_schema" Json.Decode.string Nothing
        |> maybeDecode "endpoint_host" Json.Decode.string Nothing
        |> maybeDecode "endpoint_url" Json.Decode.string Nothing


accountInfoDecoder : Json.Decode.Decoder AccountInfo
accountInfoDecoder =
    Json.Decode.succeed AccountInfo
        |> maybeDecode "exchange_id" Json.Decode.string Nothing


exchangeLoginRequireDecoder : Json.Decode.Decoder ExchangeLoginRequire
exchangeLoginRequireDecoder =
    Json.Decode.succeed ExchangeLoginRequire
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "location_id" Json.Decode.string Nothing
        |> maybeDecode "required_parameters" (Json.Decode.list Json.Decode.string) Nothing


getAccountDecoder : Json.Decode.Decoder GetAccount
getAccountDecoder =
    Json.Decode.succeed GetAccount
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "parameters" (Json.Decode.list keyValueDecoder) Nothing


keyValueDecoder : Json.Decode.Decoder KeyValue
keyValueDecoder =
    Json.Decode.succeed KeyValue
        |> maybeDecode "key" Json.Decode.string Nothing
        |> maybeDecode "value" Json.Decode.string Nothing


locationsDecoder : Json.Decode.Decoder Locations
locationsDecoder =
    Json.Decode.succeed Locations
        |> maybeDecode "location_id" Json.Decode.string Nothing
        |> maybeDecode "region_name" Json.Decode.string Nothing
        |> maybeDecode "provider_name" Json.Decode.string Nothing


updateAccountDecoder : Json.Decode.Decoder UpdateAccount
updateAccountDecoder =
    Json.Decode.succeed UpdateAccount
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "parameters" (Json.Decode.list keyValueDecoder) Nothing




-- HELPER


type alias EncodedField =
    Maybe ( String, Json.Encode.Value )


encodeObject : List EncodedField -> Json.Encode.Value
encodeObject =
    Json.Encode.object << List.filterMap identity


encode : String -> (a -> Json.Encode.Value) -> a -> EncodedField
encode key encoder value =
    Just ( key, encoder value )


encodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
encodeNullable key encoder value =
    Just ( key, Maybe.withDefault Json.Encode.null (Maybe.map encoder value) )


maybeEncode : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncode key encoder =
    Maybe.map (Tuple.pair key << encoder)


maybeEncodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncodeNullable =
    encodeNullable


decode : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decode key decoder =
    decodeChain (Json.Decode.field key decoder)


decodeLazy : (a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeLazy f key decoder =
    decodeChainLazy f (Json.Decode.field key decoder)


decodeNullable : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
decodeNullable key decoder =
    decodeChain (maybeField key decoder Nothing)


decodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeNullableLazy f key decoder =
    decodeChainLazy f (maybeField key decoder Nothing)


maybeDecode : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecode key decoder fallback =
    -- let's be kind to null-values as well
    decodeChain (maybeField key decoder fallback)


maybeDecodeLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeLazy f key decoder fallback =
    -- let's be kind to null-values as well
    decodeChainLazy f (maybeField key decoder fallback)


maybeDecodeNullable : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecodeNullable key decoder fallback =
    decodeChain (maybeField key decoder fallback)


maybeDecodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeNullableLazy f key decoder fallback =
    decodeChainLazy f (maybeField key decoder fallback)


maybeField : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a)
maybeField key decoder fallback =
    let
        fieldDecoder =
            Json.Decode.field key Json.Decode.value

        valueDecoder =
            Json.Decode.oneOf [ Json.Decode.map Just decoder, Json.Decode.null fallback ]

        decodeObject rawObject =
            case Json.Decode.decodeValue fieldDecoder rawObject of
                Ok rawValue ->
                    case Json.Decode.decodeValue valueDecoder rawValue of
                        Ok value ->
                            Json.Decode.succeed value

                        Err error ->
                            Json.Decode.fail (Json.Decode.errorToString error)

                Err _ ->
                    Json.Decode.succeed fallback
    in
    Json.Decode.value
        |> Json.Decode.andThen decodeObject


decodeChain : Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decodeChain =
    Json.Decode.map2 (|>)


decodeChainLazy : (a -> c) -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeChainLazy f =
    decodeChain << Json.Decode.map f