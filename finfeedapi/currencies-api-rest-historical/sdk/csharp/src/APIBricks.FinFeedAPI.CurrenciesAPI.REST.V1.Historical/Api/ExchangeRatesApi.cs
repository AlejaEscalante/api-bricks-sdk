// <auto-generated>
/*
 * FX Historical REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Client;
using APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Model;
using System.Diagnostics.CodeAnalysis;

namespace APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IExchangeRatesApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ExchangeRatesApiEvents Events { get; }

        /// <summary>
        /// Get specific rate
        /// </summary>
        /// <remarks>
        /// Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="time">Time at which exchange rate is calculated (optional, if not supplied then current rate is returned) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSpecificRateApiResponse"/>&gt;</returns>
        Task<IGetSpecificRateApiResponse> GetSpecificRateAsync(string assetIdBase, string assetIdQuote, Option<string> time = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get specific rate
        /// </summary>
        /// <remarks>
        /// Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
        /// </remarks>
        /// <param name="assetIdBase">Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="time">Time at which exchange rate is calculated (optional, if not supplied then current rate is returned) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSpecificRateApiResponse"/>?&gt;</returns>
        Task<IGetSpecificRateApiResponse?> GetSpecificRateOrDefaultAsync(string assetIdBase, string assetIdQuote, Option<string> time = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Timeseries data
        /// </summary>
        /// <remarks>
        /// Get the historical exchange rates between two assets in the form of the timeseries.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="periodId">Identifier of requested timeseries period (required, e.g. &#x60;5SEC&#x60; or &#x60;1HRS&#x60;) (optional)</param>
        /// <param name="timeStart">Timeseries starting time in ISO 8601 (required) (optional)</param>
        /// <param name="timeEnd">Timeseries ending time in ISO 8601 (required) (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse"/>&gt;</returns>
        Task<IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse> V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetAsync(string assetIdBase, string assetIdQuote, Option<string> periodId = default, Option<string> timeStart = default, Option<string> timeEnd = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Timeseries data
        /// </summary>
        /// <remarks>
        /// Get the historical exchange rates between two assets in the form of the timeseries.
        /// </remarks>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="periodId">Identifier of requested timeseries period (required, e.g. &#x60;5SEC&#x60; or &#x60;1HRS&#x60;) (optional)</param>
        /// <param name="timeStart">Timeseries starting time in ISO 8601 (required) (optional)</param>
        /// <param name="timeEnd">Timeseries ending time in ISO 8601 (required) (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse"/>?&gt;</returns>
        Task<IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse?> V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetOrDefaultAsync(string assetIdBase, string assetIdQuote, Option<string> periodId = default, Option<string> timeStart = default, Option<string> timeEnd = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all current rates
        /// </summary>
        /// <remarks>
        /// Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response (optional) (optional)</param>
        /// <param name="invert">True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;) (optional, default to false)</param>
        /// <param name="time">Time for historical rates (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>&gt;</returns>
        Task<IV1ExchangerateAssetIdBaseGetApiResponse> V1ExchangerateAssetIdBaseGetAsync(string assetIdBase, Option<string> filterAssetId = default, Option<bool> invert = default, Option<string> time = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all current rates
        /// </summary>
        /// <remarks>
        /// Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
        /// </remarks>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response (optional) (optional)</param>
        /// <param name="invert">True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;) (optional, default to false)</param>
        /// <param name="time">Time for historical rates (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>?&gt;</returns>
        Task<IV1ExchangerateAssetIdBaseGetApiResponse?> V1ExchangerateAssetIdBaseGetOrDefaultAsync(string assetIdBase, Option<string> filterAssetId = default, Option<bool> invert = default, Option<string> time = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Timeseries periods
        /// </summary>
        /// <remarks>
        /// You can also obtain historical exchange rates of any asset pair, grouped into time periods. Get full list of supported time periods available for requesting exchange rates historical timeseries data.              ## Timeseries periods Time unit | Period identifiers - -- | - -- Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateHistoryPeriodsGetApiResponse"/>&gt;</returns>
        Task<IV1ExchangerateHistoryPeriodsGetApiResponse> V1ExchangerateHistoryPeriodsGetAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Timeseries periods
        /// </summary>
        /// <remarks>
        /// You can also obtain historical exchange rates of any asset pair, grouped into time periods. Get full list of supported time periods available for requesting exchange rates historical timeseries data.              ## Timeseries periods Time unit | Period identifiers - -- | - -- Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateHistoryPeriodsGetApiResponse"/>?&gt;</returns>
        Task<IV1ExchangerateHistoryPeriodsGetApiResponse?> V1ExchangerateHistoryPeriodsGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetSpecificRateApiResponse"/>
    /// </summary>
    public interface IGetSpecificRateApiResponse : APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Client.IApiResponse, IOk<APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Model.V1ExchangeRate?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse"/>
    /// </summary>
    public interface IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse : APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Client.IApiResponse, IOk<List<V1ExchangeRatesTimeseriesItem>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>
    /// </summary>
    public interface IV1ExchangerateAssetIdBaseGetApiResponse : APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Client.IApiResponse, IOk<APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Model.V1ExchangeRates?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IV1ExchangerateHistoryPeriodsGetApiResponse"/>
    /// </summary>
    public interface IV1ExchangerateHistoryPeriodsGetApiResponse : APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Client.IApiResponse, IOk<List<V1TimeseriesPeriod>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ExchangeRatesApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSpecificRate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSpecificRate;

        internal void ExecuteOnGetSpecificRate(ExchangeRatesApi.GetSpecificRateApiResponse apiResponse)
        {
            OnGetSpecificRate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSpecificRate(Exception exception)
        {
            OnErrorGetSpecificRate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet;

        internal void ExecuteOnV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(ExchangeRatesApi.V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse apiResponse)
        {
            OnV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(Exception exception)
        {
            OnErrorV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExchangerateAssetIdBaseGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExchangerateAssetIdBaseGet;

        internal void ExecuteOnV1ExchangerateAssetIdBaseGet(ExchangeRatesApi.V1ExchangerateAssetIdBaseGetApiResponse apiResponse)
        {
            OnV1ExchangerateAssetIdBaseGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExchangerateAssetIdBaseGet(Exception exception)
        {
            OnErrorV1ExchangerateAssetIdBaseGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnV1ExchangerateHistoryPeriodsGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorV1ExchangerateHistoryPeriodsGet;

        internal void ExecuteOnV1ExchangerateHistoryPeriodsGet(ExchangeRatesApi.V1ExchangerateHistoryPeriodsGetApiResponse apiResponse)
        {
            OnV1ExchangerateHistoryPeriodsGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorV1ExchangerateHistoryPeriodsGet(Exception exception)
        {
            OnErrorV1ExchangerateHistoryPeriodsGet?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ExchangeRatesApi : IExchangeRatesApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ExchangeRatesApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ExchangeRatesApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExchangeRatesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ExchangeRatesApi(ILogger<ExchangeRatesApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ExchangeRatesApiEvents exchangeRatesApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ExchangeRatesApi>();
            HttpClient = httpClient;
            Events = exchangeRatesApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatGetSpecificRate(ref string assetIdBase, ref string assetIdQuote, ref Option<string> time);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="time"></param>
        /// <returns></returns>
        private void ValidateGetSpecificRate(string assetIdBase, string assetIdQuote, Option<string> time)
        {
            if (assetIdBase == null)
                throw new ArgumentNullException(nameof(assetIdBase));

            if (assetIdQuote == null)
                throw new ArgumentNullException(nameof(assetIdQuote));

            if (time.IsSet && time.Value == null)
                throw new ArgumentNullException(nameof(time));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="time"></param>
        private void AfterGetSpecificRateDefaultImplementation(IGetSpecificRateApiResponse apiResponseLocalVar, string assetIdBase, string assetIdQuote, Option<string> time)
        {
            bool suppressDefaultLog = false;
            AfterGetSpecificRate(ref suppressDefaultLog, apiResponseLocalVar, assetIdBase, assetIdQuote, time);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="time"></param>
        partial void AfterGetSpecificRate(ref bool suppressDefaultLog, IGetSpecificRateApiResponse apiResponseLocalVar, string assetIdBase, string assetIdQuote, Option<string> time);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="time"></param>
        private void OnErrorGetSpecificRateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, string assetIdQuote, Option<string> time)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSpecificRate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assetIdBase, assetIdQuote, time);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="time"></param>
        partial void OnErrorGetSpecificRate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, string assetIdQuote, Option<string> time);

        /// <summary>
        /// Get specific rate Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
        /// </summary>
        /// <param name="assetIdBase">Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="time">Time at which exchange rate is calculated (optional, if not supplied then current rate is returned) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSpecificRateApiResponse"/>&gt;</returns>
        public async Task<IGetSpecificRateApiResponse?> GetSpecificRateOrDefaultAsync(string assetIdBase, string assetIdQuote, Option<string> time = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSpecificRateAsync(assetIdBase, assetIdQuote, time, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get specific rate Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="time">Time at which exchange rate is calculated (optional, if not supplied then current rate is returned) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSpecificRateApiResponse"/>&gt;</returns>
        public async Task<IGetSpecificRateApiResponse> GetSpecificRateAsync(string assetIdBase, string assetIdQuote, Option<string> time = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSpecificRate(assetIdBase, assetIdQuote, time);

                FormatGetSpecificRate(ref assetIdBase, ref assetIdQuote, ref time);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchangerate/{asset_id_base}/{asset_id_quote}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchangerate/{asset_id_base}/{asset_id_quote}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id_base%7D", Uri.EscapeDataString(assetIdBase.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id_quote%7D", Uri.EscapeDataString(assetIdQuote.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (time.IsSet)
                        parseQueryStringLocalVar["time"] = ClientUtils.ParameterToString(time.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetSpecificRateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSpecificRateApiResponse>();
                        GetSpecificRateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchangerate/{asset_id_base}/{asset_id_quote}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetSpecificRateDefaultImplementation(apiResponseLocalVar, assetIdBase, assetIdQuote, time);

                        Events.ExecuteOnGetSpecificRate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSpecificRateDefaultImplementation(e, "/v1/exchangerate/{asset_id_base}/{asset_id_quote}", uriBuilderLocalVar.Path, assetIdBase, assetIdQuote, time);
                Events.ExecuteOnErrorGetSpecificRate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSpecificRateApiResponse"/>
        /// </summary>
        public partial class GetSpecificRateApiResponse : APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Client.ApiResponse, IGetSpecificRateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSpecificRateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSpecificRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSpecificRateApiResponse(ILogger<GetSpecificRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetSpecificRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSpecificRateApiResponse(ILogger<GetSpecificRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Model.V1ExchangeRate? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Model.V1ExchangeRate>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Model.V1ExchangeRate? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(ref string assetIdBase, ref string assetIdQuote, ref Option<string> periodId, ref Option<string> timeStart, ref Option<string> timeEnd, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="periodId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <returns></returns>
        private void ValidateV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(string assetIdBase, string assetIdQuote, Option<string> periodId, Option<string> timeStart, Option<string> timeEnd)
        {
            if (assetIdBase == null)
                throw new ArgumentNullException(nameof(assetIdBase));

            if (assetIdQuote == null)
                throw new ArgumentNullException(nameof(assetIdQuote));

            if (periodId.IsSet && periodId.Value == null)
                throw new ArgumentNullException(nameof(periodId));

            if (timeStart.IsSet && timeStart.Value == null)
                throw new ArgumentNullException(nameof(timeStart));

            if (timeEnd.IsSet && timeEnd.Value == null)
                throw new ArgumentNullException(nameof(timeEnd));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="periodId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="limit"></param>
        private void AfterV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetDefaultImplementation(IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse apiResponseLocalVar, string assetIdBase, string assetIdQuote, Option<string> periodId, Option<string> timeStart, Option<string> timeEnd, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(ref suppressDefaultLog, apiResponseLocalVar, assetIdBase, assetIdQuote, periodId, timeStart, timeEnd, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="periodId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="limit"></param>
        partial void AfterV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(ref bool suppressDefaultLog, IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse apiResponseLocalVar, string assetIdBase, string assetIdQuote, Option<string> periodId, Option<string> timeStart, Option<string> timeEnd, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="periodId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="limit"></param>
        private void OnErrorV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, string assetIdQuote, Option<string> periodId, Option<string> timeStart, Option<string> timeEnd, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assetIdBase, assetIdQuote, periodId, timeStart, timeEnd, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="assetIdQuote"></param>
        /// <param name="periodId"></param>
        /// <param name="timeStart"></param>
        /// <param name="timeEnd"></param>
        /// <param name="limit"></param>
        partial void OnErrorV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, string assetIdQuote, Option<string> periodId, Option<string> timeStart, Option<string> timeEnd, Option<int> limit);

        /// <summary>
        /// Timeseries data Get the historical exchange rates between two assets in the form of the timeseries.
        /// </summary>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="periodId">Identifier of requested timeseries period (required, e.g. &#x60;5SEC&#x60; or &#x60;1HRS&#x60;) (optional)</param>
        /// <param name="timeStart">Timeseries starting time in ISO 8601 (required) (optional)</param>
        /// <param name="timeEnd">Timeseries ending time in ISO 8601 (required) (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse?> V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetOrDefaultAsync(string assetIdBase, string assetIdQuote, Option<string> periodId = default, Option<string> timeStart = default, Option<string> timeEnd = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetAsync(assetIdBase, assetIdQuote, periodId, timeStart, timeEnd, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Timeseries data Get the historical exchange rates between two assets in the form of the timeseries.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="assetIdQuote">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="periodId">Identifier of requested timeseries period (required, e.g. &#x60;5SEC&#x60; or &#x60;1HRS&#x60;) (optional)</param>
        /// <param name="timeStart">Timeseries starting time in ISO 8601 (required) (optional)</param>
        /// <param name="timeEnd">Timeseries ending time in ISO 8601 (required) (optional)</param>
        /// <param name="limit">Amount of items to return (optional, mininum is 1, maximum is 100000, default value is 100, if the parameter is used then every 100 output items are counted as one request) (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse> V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetAsync(string assetIdBase, string assetIdQuote, Option<string> periodId = default, Option<string> timeStart = default, Option<string> timeEnd = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(assetIdBase, assetIdQuote, periodId, timeStart, timeEnd);

                FormatV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(ref assetIdBase, ref assetIdQuote, ref periodId, ref timeStart, ref timeEnd, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchangerate/{asset_id_base}/{asset_id_quote}/history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchangerate/{asset_id_base}/{asset_id_quote}/history");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id_base%7D", Uri.EscapeDataString(assetIdBase.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id_quote%7D", Uri.EscapeDataString(assetIdQuote.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (periodId.IsSet)
                        parseQueryStringLocalVar["period_id"] = ClientUtils.ParameterToString(periodId.Value);

                    if (timeStart.IsSet)
                        parseQueryStringLocalVar["time_start"] = ClientUtils.ParameterToString(timeStart.Value);

                    if (timeEnd.IsSet)
                        parseQueryStringLocalVar["time_end"] = ClientUtils.ParameterToString(timeEnd.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse>();
                        V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchangerate/{asset_id_base}/{asset_id_quote}/history", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetDefaultImplementation(apiResponseLocalVar, assetIdBase, assetIdQuote, periodId, timeStart, timeEnd, limit);

                        Events.ExecuteOnV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetDefaultImplementation(e, "/v1/exchangerate/{asset_id_base}/{asset_id_quote}/history", uriBuilderLocalVar.Path, assetIdBase, assetIdQuote, periodId, timeStart, timeEnd, limit);
                Events.ExecuteOnErrorV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse"/>
        /// </summary>
        public partial class V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse : APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Client.ApiResponse, IV1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse(ILogger<V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse(ILogger<V1ExchangerateAssetIdBaseAssetIdQuoteHistoryGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1ExchangeRatesTimeseriesItem>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1ExchangeRatesTimeseriesItem>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1ExchangeRatesTimeseriesItem>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatV1ExchangerateAssetIdBaseGet(ref string assetIdBase, ref Option<string> filterAssetId, ref Option<bool> invert, ref Option<string> time);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <param name="time"></param>
        /// <returns></returns>
        private void ValidateV1ExchangerateAssetIdBaseGet(string assetIdBase, Option<string> filterAssetId, Option<string> time)
        {
            if (assetIdBase == null)
                throw new ArgumentNullException(nameof(assetIdBase));

            if (filterAssetId.IsSet && filterAssetId.Value == null)
                throw new ArgumentNullException(nameof(filterAssetId));

            if (time.IsSet && time.Value == null)
                throw new ArgumentNullException(nameof(time));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <param name="invert"></param>
        /// <param name="time"></param>
        private void AfterV1ExchangerateAssetIdBaseGetDefaultImplementation(IV1ExchangerateAssetIdBaseGetApiResponse apiResponseLocalVar, string assetIdBase, Option<string> filterAssetId, Option<bool> invert, Option<string> time)
        {
            bool suppressDefaultLog = false;
            AfterV1ExchangerateAssetIdBaseGet(ref suppressDefaultLog, apiResponseLocalVar, assetIdBase, filterAssetId, invert, time);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <param name="invert"></param>
        /// <param name="time"></param>
        partial void AfterV1ExchangerateAssetIdBaseGet(ref bool suppressDefaultLog, IV1ExchangerateAssetIdBaseGetApiResponse apiResponseLocalVar, string assetIdBase, Option<string> filterAssetId, Option<bool> invert, Option<string> time);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <param name="invert"></param>
        /// <param name="time"></param>
        private void OnErrorV1ExchangerateAssetIdBaseGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, Option<string> filterAssetId, Option<bool> invert, Option<string> time)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExchangerateAssetIdBaseGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assetIdBase, filterAssetId, invert, time);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assetIdBase"></param>
        /// <param name="filterAssetId"></param>
        /// <param name="invert"></param>
        /// <param name="time"></param>
        partial void OnErrorV1ExchangerateAssetIdBaseGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assetIdBase, Option<string> filterAssetId, Option<bool> invert, Option<string> time);

        /// <summary>
        /// Get all current rates Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
        /// </summary>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response (optional) (optional)</param>
        /// <param name="invert">True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;) (optional, default to false)</param>
        /// <param name="time">Time for historical rates (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangerateAssetIdBaseGetApiResponse?> V1ExchangerateAssetIdBaseGetOrDefaultAsync(string assetIdBase, Option<string> filterAssetId = default, Option<bool> invert = default, Option<string> time = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExchangerateAssetIdBaseGetAsync(assetIdBase, filterAssetId, invert, time, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all current rates Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetIdBase">Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)</param>
        /// <param name="filterAssetId">Comma or semicolon delimited asset identifiers used to filter response (optional) (optional)</param>
        /// <param name="invert">True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;) (optional, default to false)</param>
        /// <param name="time">Time for historical rates (optional) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateAssetIdBaseGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangerateAssetIdBaseGetApiResponse> V1ExchangerateAssetIdBaseGetAsync(string assetIdBase, Option<string> filterAssetId = default, Option<bool> invert = default, Option<string> time = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateV1ExchangerateAssetIdBaseGet(assetIdBase, filterAssetId, time);

                FormatV1ExchangerateAssetIdBaseGet(ref assetIdBase, ref filterAssetId, ref invert, ref time);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchangerate/{asset_id_base}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchangerate/{asset_id_base}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Basset_id_base%7D", Uri.EscapeDataString(assetIdBase.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (filterAssetId.IsSet)
                        parseQueryStringLocalVar["filter_asset_id"] = ClientUtils.ParameterToString(filterAssetId.Value);

                    if (invert.IsSet)
                        parseQueryStringLocalVar["invert"] = ClientUtils.ParameterToString(invert.Value);

                    if (time.IsSet)
                        parseQueryStringLocalVar["time"] = ClientUtils.ParameterToString(time.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<V1ExchangerateAssetIdBaseGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExchangerateAssetIdBaseGetApiResponse>();
                        V1ExchangerateAssetIdBaseGetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchangerate/{asset_id_base}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterV1ExchangerateAssetIdBaseGetDefaultImplementation(apiResponseLocalVar, assetIdBase, filterAssetId, invert, time);

                        Events.ExecuteOnV1ExchangerateAssetIdBaseGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExchangerateAssetIdBaseGetDefaultImplementation(e, "/v1/exchangerate/{asset_id_base}", uriBuilderLocalVar.Path, assetIdBase, filterAssetId, invert, time);
                Events.ExecuteOnErrorV1ExchangerateAssetIdBaseGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExchangerateAssetIdBaseGetApiResponse"/>
        /// </summary>
        public partial class V1ExchangerateAssetIdBaseGetApiResponse : APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Client.ApiResponse, IV1ExchangerateAssetIdBaseGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExchangerateAssetIdBaseGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExchangerateAssetIdBaseGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangerateAssetIdBaseGetApiResponse(ILogger<V1ExchangerateAssetIdBaseGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="V1ExchangerateAssetIdBaseGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangerateAssetIdBaseGetApiResponse(ILogger<V1ExchangerateAssetIdBaseGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Model.V1ExchangeRates? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Model.V1ExchangeRates>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Model.V1ExchangeRates? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterV1ExchangerateHistoryPeriodsGetDefaultImplementation(IV1ExchangerateHistoryPeriodsGetApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterV1ExchangerateHistoryPeriodsGet(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterV1ExchangerateHistoryPeriodsGet(ref bool suppressDefaultLog, IV1ExchangerateHistoryPeriodsGetApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorV1ExchangerateHistoryPeriodsGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorV1ExchangerateHistoryPeriodsGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorV1ExchangerateHistoryPeriodsGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Timeseries periods You can also obtain historical exchange rates of any asset pair, grouped into time periods. Get full list of supported time periods available for requesting exchange rates historical timeseries data.              ## Timeseries periods Time unit | Period identifiers - -- | - -- Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateHistoryPeriodsGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangerateHistoryPeriodsGetApiResponse?> V1ExchangerateHistoryPeriodsGetOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await V1ExchangerateHistoryPeriodsGetAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Timeseries periods You can also obtain historical exchange rates of any asset pair, grouped into time periods. Get full list of supported time periods available for requesting exchange rates historical timeseries data.              ## Timeseries periods Time unit | Period identifiers - -- | - -- Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IV1ExchangerateHistoryPeriodsGetApiResponse"/>&gt;</returns>
        public async Task<IV1ExchangerateHistoryPeriodsGetApiResponse> V1ExchangerateHistoryPeriodsGetAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchangerate/history/periods"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchangerate/history/periods");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-CoinAPI-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "application/json",
                        "text/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<V1ExchangerateHistoryPeriodsGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<V1ExchangerateHistoryPeriodsGetApiResponse>();
                        V1ExchangerateHistoryPeriodsGetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchangerate/history/periods", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterV1ExchangerateHistoryPeriodsGetDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnV1ExchangerateHistoryPeriodsGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorV1ExchangerateHistoryPeriodsGetDefaultImplementation(e, "/v1/exchangerate/history/periods", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorV1ExchangerateHistoryPeriodsGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="V1ExchangerateHistoryPeriodsGetApiResponse"/>
        /// </summary>
        public partial class V1ExchangerateHistoryPeriodsGetApiResponse : APIBricks.FinFeedAPI.CurrenciesAPI.REST.V1.Historical.Client.ApiResponse, IV1ExchangerateHistoryPeriodsGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<V1ExchangerateHistoryPeriodsGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="V1ExchangerateHistoryPeriodsGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangerateHistoryPeriodsGetApiResponse(ILogger<V1ExchangerateHistoryPeriodsGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="V1ExchangerateHistoryPeriodsGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public V1ExchangerateHistoryPeriodsGetApiResponse(ILogger<V1ExchangerateHistoryPeriodsGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<V1TimeseriesPeriod>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<V1TimeseriesPeriod>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<V1TimeseriesPeriod>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
