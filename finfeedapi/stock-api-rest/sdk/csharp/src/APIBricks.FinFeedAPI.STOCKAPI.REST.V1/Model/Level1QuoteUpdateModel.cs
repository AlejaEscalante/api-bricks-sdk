// <auto-generated>
/*
 * FinFeedAPI Stock REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using OpenAPIClientUtils = APIBricks.FinFeedAPI.STOCKAPI.REST.V1.Client.ClientUtils;
using APIBricks.FinFeedAPI.STOCKAPI.REST.V1.Client;

namespace APIBricks.FinFeedAPI.STOCKAPI.REST.V1.Model
{
    /// <summary>
    /// Represents the response DTO for quote update information
    /// </summary>
    public partial class Level1QuoteUpdateModel : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Level1QuoteUpdateModel" /> class.
        /// </summary>
        /// <param name="symbol">The stock symbol</param>
        /// <param name="timestampNanos">Original timestamp in nanoseconds since epoch</param>
        /// <param name="timestamp">Time when the quote update was recorded as DateTime</param>
        /// <param name="isSymbolAvailable">Gets whether the symbol is available for trading True if active, False if halted, paused, or otherwise not available</param>
        /// <param name="isPrePostMarketSession">Gets whether the market session is regular or pre/post-market True if pre/post-market session, False if regular market session</param>
        /// <param name="askSize">Ask size in number of shares</param>
        /// <param name="askPrice">Ask price as decimal</param>
        /// <param name="bidPrice">Bid price as decimal</param>
        /// <param name="bidSize">Bid size in number of shares</param>
        [JsonConstructor]
        public Level1QuoteUpdateModel(Option<string?> symbol = default, Option<long?> timestampNanos = default, Option<DateTime?> timestamp = default, Option<bool?> isSymbolAvailable = default, Option<bool?> isPrePostMarketSession = default, Option<int?> askSize = default, Option<double?> askPrice = default, Option<double?> bidPrice = default, Option<int?> bidSize = default)
        {
            SymbolOption = symbol;
            TimestampNanosOption = timestampNanos;
            TimestampOption = timestamp;
            IsSymbolAvailableOption = isSymbolAvailable;
            IsPrePostMarketSessionOption = isPrePostMarketSession;
            AskSizeOption = askSize;
            AskPriceOption = askPrice;
            BidPriceOption = bidPrice;
            BidSizeOption = bidSize;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of Symbol
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> SymbolOption { get; private set; }

        /// <summary>
        /// The stock symbol
        /// </summary>
        /// <value>The stock symbol</value>
        [JsonPropertyName("symbol")]
        public string? Symbol { get { return this.SymbolOption; } set { this.SymbolOption = new(value); } }

        /// <summary>
        /// Used to track the state of TimestampNanos
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> TimestampNanosOption { get; private set; }

        /// <summary>
        /// Original timestamp in nanoseconds since epoch
        /// </summary>
        /// <value>Original timestamp in nanoseconds since epoch</value>
        [JsonPropertyName("timestamp_nanos")]
        public long? TimestampNanos { get { return this.TimestampNanosOption; } set { this.TimestampNanosOption = new(value); } }

        /// <summary>
        /// Used to track the state of Timestamp
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> TimestampOption { get; private set; }

        /// <summary>
        /// Time when the quote update was recorded as DateTime
        /// </summary>
        /// <value>Time when the quote update was recorded as DateTime</value>
        [JsonPropertyName("timestamp")]
        public DateTime? Timestamp { get { return this.TimestampOption; } set { this.TimestampOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsSymbolAvailable
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsSymbolAvailableOption { get; private set; }

        /// <summary>
        /// Gets whether the symbol is available for trading True if active, False if halted, paused, or otherwise not available
        /// </summary>
        /// <value>Gets whether the symbol is available for trading True if active, False if halted, paused, or otherwise not available</value>
        [JsonPropertyName("is_symbol_available")]
        public bool? IsSymbolAvailable { get { return this.IsSymbolAvailableOption; } set { this.IsSymbolAvailableOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsPrePostMarketSession
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsPrePostMarketSessionOption { get; private set; }

        /// <summary>
        /// Gets whether the market session is regular or pre/post-market True if pre/post-market session, False if regular market session
        /// </summary>
        /// <value>Gets whether the market session is regular or pre/post-market True if pre/post-market session, False if regular market session</value>
        [JsonPropertyName("is_pre_post_market_session")]
        public bool? IsPrePostMarketSession { get { return this.IsPrePostMarketSessionOption; } set { this.IsPrePostMarketSessionOption = new(value); } }

        /// <summary>
        /// Used to track the state of AskSize
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> AskSizeOption { get; private set; }

        /// <summary>
        /// Ask size in number of shares
        /// </summary>
        /// <value>Ask size in number of shares</value>
        [JsonPropertyName("ask_size")]
        public int? AskSize { get { return this.AskSizeOption; } set { this.AskSizeOption = new(value); } }

        /// <summary>
        /// Used to track the state of AskPrice
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> AskPriceOption { get; private set; }

        /// <summary>
        /// Ask price as decimal
        /// </summary>
        /// <value>Ask price as decimal</value>
        [JsonPropertyName("ask_price")]
        public double? AskPrice { get { return this.AskPriceOption; } set { this.AskPriceOption = new(value); } }

        /// <summary>
        /// Used to track the state of BidPrice
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> BidPriceOption { get; private set; }

        /// <summary>
        /// Bid price as decimal
        /// </summary>
        /// <value>Bid price as decimal</value>
        [JsonPropertyName("bid_price")]
        public double? BidPrice { get { return this.BidPriceOption; } set { this.BidPriceOption = new(value); } }

        /// <summary>
        /// Used to track the state of BidSize
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> BidSizeOption { get; private set; }

        /// <summary>
        /// Bid size in number of shares
        /// </summary>
        /// <value>Bid size in number of shares</value>
        [JsonPropertyName("bid_size")]
        public int? BidSize { get { return this.BidSizeOption; } set { this.BidSizeOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Level1QuoteUpdateModel {\n");
            sb.Append("  Symbol: ").Append(Symbol).Append("\n");
            sb.Append("  TimestampNanos: ").Append(TimestampNanos).Append("\n");
            sb.Append("  Timestamp: ").Append(Timestamp).Append("\n");
            sb.Append("  IsSymbolAvailable: ").Append(IsSymbolAvailable).Append("\n");
            sb.Append("  IsPrePostMarketSession: ").Append(IsPrePostMarketSession).Append("\n");
            sb.Append("  AskSize: ").Append(AskSize).Append("\n");
            sb.Append("  AskPrice: ").Append(AskPrice).Append("\n");
            sb.Append("  BidPrice: ").Append(BidPrice).Append("\n");
            sb.Append("  BidSize: ").Append(BidSize).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Level1QuoteUpdateModel" />
    /// </summary>
    public class Level1QuoteUpdateModelJsonConverter : JsonConverter<Level1QuoteUpdateModel>
    {
        /// <summary>
        /// The format to use to serialize Timestamp
        /// </summary>
        public static string TimestampFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="Level1QuoteUpdateModel" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Level1QuoteUpdateModel Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> symbol = default;
            Option<long?> timestampNanos = default;
            Option<DateTime?> timestamp = default;
            Option<bool?> isSymbolAvailable = default;
            Option<bool?> isPrePostMarketSession = default;
            Option<int?> askSize = default;
            Option<double?> askPrice = default;
            Option<double?> bidPrice = default;
            Option<int?> bidSize = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "symbol":
                            symbol = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "timestamp_nanos":
                            timestampNanos = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "timestamp":
                            timestamp = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "is_symbol_available":
                            isSymbolAvailable = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "is_pre_post_market_session":
                            isPrePostMarketSession = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "ask_size":
                            askSize = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "ask_price":
                            askPrice = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "bid_price":
                            bidPrice = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "bid_size":
                            bidSize = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (timestampNanos.IsSet && timestampNanos.Value == null)
                throw new ArgumentNullException(nameof(timestampNanos), "Property is not nullable for class Level1QuoteUpdateModel.");

            if (timestamp.IsSet && timestamp.Value == null)
                throw new ArgumentNullException(nameof(timestamp), "Property is not nullable for class Level1QuoteUpdateModel.");

            if (isSymbolAvailable.IsSet && isSymbolAvailable.Value == null)
                throw new ArgumentNullException(nameof(isSymbolAvailable), "Property is not nullable for class Level1QuoteUpdateModel.");

            if (isPrePostMarketSession.IsSet && isPrePostMarketSession.Value == null)
                throw new ArgumentNullException(nameof(isPrePostMarketSession), "Property is not nullable for class Level1QuoteUpdateModel.");

            if (askSize.IsSet && askSize.Value == null)
                throw new ArgumentNullException(nameof(askSize), "Property is not nullable for class Level1QuoteUpdateModel.");

            if (askPrice.IsSet && askPrice.Value == null)
                throw new ArgumentNullException(nameof(askPrice), "Property is not nullable for class Level1QuoteUpdateModel.");

            if (bidPrice.IsSet && bidPrice.Value == null)
                throw new ArgumentNullException(nameof(bidPrice), "Property is not nullable for class Level1QuoteUpdateModel.");

            if (bidSize.IsSet && bidSize.Value == null)
                throw new ArgumentNullException(nameof(bidSize), "Property is not nullable for class Level1QuoteUpdateModel.");

            return new Level1QuoteUpdateModel(symbol, timestampNanos, timestamp, isSymbolAvailable, isPrePostMarketSession, askSize, askPrice, bidPrice, bidSize);
        }

        /// <summary>
        /// Serializes a <see cref="Level1QuoteUpdateModel" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="level1QuoteUpdateModel"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Level1QuoteUpdateModel level1QuoteUpdateModel, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, level1QuoteUpdateModel, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Level1QuoteUpdateModel" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="level1QuoteUpdateModel"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Level1QuoteUpdateModel level1QuoteUpdateModel, JsonSerializerOptions jsonSerializerOptions)
        {
            if (level1QuoteUpdateModel.SymbolOption.IsSet)
                if (level1QuoteUpdateModel.SymbolOption.Value != null)
                    writer.WriteString("symbol", level1QuoteUpdateModel.Symbol);
                else
                    writer.WriteNull("symbol");

            if (level1QuoteUpdateModel.TimestampNanosOption.IsSet)
                writer.WriteNumber("timestamp_nanos", level1QuoteUpdateModel.TimestampNanosOption.Value!.Value);

            if (level1QuoteUpdateModel.TimestampOption.IsSet)
                writer.WriteString("timestamp", level1QuoteUpdateModel.TimestampOption.Value!.Value.ToString(TimestampFormat));

            if (level1QuoteUpdateModel.IsSymbolAvailableOption.IsSet)
                writer.WriteBoolean("is_symbol_available", level1QuoteUpdateModel.IsSymbolAvailableOption.Value!.Value);

            if (level1QuoteUpdateModel.IsPrePostMarketSessionOption.IsSet)
                writer.WriteBoolean("is_pre_post_market_session", level1QuoteUpdateModel.IsPrePostMarketSessionOption.Value!.Value);

            if (level1QuoteUpdateModel.AskSizeOption.IsSet)
                writer.WriteNumber("ask_size", level1QuoteUpdateModel.AskSizeOption.Value!.Value);

            if (level1QuoteUpdateModel.AskPriceOption.IsSet)
                writer.WriteNumber("ask_price", level1QuoteUpdateModel.AskPriceOption.Value!.Value);

            if (level1QuoteUpdateModel.BidPriceOption.IsSet)
                writer.WriteNumber("bid_price", level1QuoteUpdateModel.BidPriceOption.Value!.Value);

            if (level1QuoteUpdateModel.BidSizeOption.IsSet)
                writer.WriteNumber("bid_size", level1QuoteUpdateModel.BidSizeOption.Value!.Value);
        }
    }
}
