// @flow
/* eslint-disable no-use-before-define */
/**
 * FinFeedAPI Stock REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://api-historical.stock.finfeedapi.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Represents the response DTO for IEX admin information, combining all symbol-based admin message types
 * @export
 */
export type AdminAdminMessageModel = {
    /**
     * 
     * @type {AdminTradingStatusModel}
     * @memberof AdminAdminMessageModel
     */
    trading_status?: AdminTradingStatusModel;
    /**
     * 
     * @type {AdminOfficialPriceModel}
     * @memberof AdminAdminMessageModel
     */
    official_price?: AdminOfficialPriceModel;
    /**
     * 
     * @type {AdminSecurityEventModel}
     * @memberof AdminAdminMessageModel
     */
    security_event?: AdminSecurityEventModel;
    /**
     * 
     * @type {AdminAuctionInformationModel}
     * @memberof AdminAdminMessageModel
     */
    auction_information?: AdminAuctionInformationModel;
    /**
     * 
     * @type {AdminShortSalePriceTestStatusModel}
     * @memberof AdminAdminMessageModel
     */
    short_sale_price_test?: AdminShortSalePriceTestStatusModel;
    /**
     * 
     * @type {AdminOperationalHaltStatusModel}
     * @memberof AdminAdminMessageModel
     */
    operational_halt_status?: AdminOperationalHaltStatusModel;
    /**
     * 
     * @type {AdminRetailLiquidityIndicatorModel}
     * @memberof AdminAdminMessageModel
     */
    retail_liquidity_indicator?: AdminRetailLiquidityIndicatorModel;
    /**
     * 
     * @type {AdminSystemEventModel}
     * @memberof AdminAdminMessageModel
     */
    system_event?: AdminSystemEventModel;
    /**
     * 
     * @type {AdminSecurityDirectoryModel}
     * @memberof AdminAdminMessageModel
     */
    security_directory?: AdminSecurityDirectoryModel;
}

/**
 * Represents the response DTO for auction information
 * @export
 */
export type AdminAuctionInformationModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof AdminAuctionInformationModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the auction data was recorded as DateTime
     * @type {Date}
     * @memberof AdminAuctionInformationModel
     */
    timestamp?: Date;
    /**
     * Type of auction as byte value
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    auction_type?: number;
    /**
     * Type of auction as character string
     * @type {string}
     * @memberof AdminAuctionInformationModel
     */
    auction_type_code?: string;
    /**
     * Human-readable description of the auction type
     * @type {string}
     * @memberof AdminAuctionInformationModel
     */
    auction_type_text?: string;
    /**
     * Indicates if the auction type is \'Opening Auction\' (\'O\'/0x4f).
     * @type {boolean}
     * @memberof AdminAuctionInformationModel
     */
    is_auction_type_opening?: boolean;
    /**
     * Indicates if the auction type is \'Closing Auction\' (\'C\'/0x43).
     * @type {boolean}
     * @memberof AdminAuctionInformationModel
     */
    is_auction_type_closing?: boolean;
    /**
     * Indicates if the auction type is \'IPO Auction\' (\'I\'/0x49).
     * @type {boolean}
     * @memberof AdminAuctionInformationModel
     */
    is_auction_type_ipo?: boolean;
    /**
     * Indicates if the auction type is \'Halt Auction\' (\'H\'/0x48).
     * @type {boolean}
     * @memberof AdminAuctionInformationModel
     */
    is_auction_type_halt?: boolean;
    /**
     * Indicates if the auction type is \'Volatility Auction\' (\'V\'/0x56).
     * @type {boolean}
     * @memberof AdminAuctionInformationModel
     */
    is_auction_type_volatility?: boolean;
    /**
     * Number of shares paired at the Reference Price
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    paired_shares?: number;
    /**
     * Reference price as decimal
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    reference_price?: number;
    /**
     * Indicative clearing price as decimal
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    indicative_clearing_price?: number;
    /**
     * Number of unpaired shares at the Reference Price
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    imbalance_shares?: number;
    /**
     * Side of the imbalance as byte value
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    imbalance_side?: number;
    /**
     * Side of the imbalance as character string
     * @type {string}
     * @memberof AdminAuctionInformationModel
     */
    imbalance_side_code?: string;
    /**
     * Human-readable description of the imbalance side
     * @type {string}
     * @memberof AdminAuctionInformationModel
     */
    imbalance_side_text?: string;
    /**
     * Indicates if there is a buy-side imbalance (\'B\'/0x42).
     * @type {boolean}
     * @memberof AdminAuctionInformationModel
     */
    is_imbalance_side_buy?: boolean;
    /**
     * Indicates if there is a sell-side imbalance (\'S\'/0x53).
     * @type {boolean}
     * @memberof AdminAuctionInformationModel
     */
    is_imbalance_side_sell?: boolean;
    /**
     * Indicates if there is no imbalance (\'N\'/0x4e).
     * @type {boolean}
     * @memberof AdminAuctionInformationModel
     */
    is_imbalance_side_none?: boolean;
    /**
     * Number of extensions to the auction
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    extension_number?: number;
    /**
     * Scheduled auction time in seconds since epoch
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    scheduled_auction_time_seconds?: number;
    /**
     * Scheduled time for the auction as DateTime
     * @type {Date}
     * @memberof AdminAuctionInformationModel
     */
    scheduled_auction_time?: Date;
    /**
     * Auction book clearing price as decimal
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    auction_book_clearing_price?: number;
    /**
     * Collar reference price as decimal
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    collar_reference_price?: number;
    /**
     * Lower auction collar as decimal
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    lower_auction_collar?: number;
    /**
     * Upper auction collar as decimal
     * @type {number}
     * @memberof AdminAuctionInformationModel
     */
    upper_auction_collar?: number;
}

/**
 * Represents the response DTO for official price information
 * @export
 */
export type AdminOfficialPriceModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof AdminOfficialPriceModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof AdminOfficialPriceModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the official price was recorded as DateTime
     * @type {Date}
     * @memberof AdminOfficialPriceModel
     */
    timestamp?: Date;
    /**
     * Type of price as byte value
     * @type {number}
     * @memberof AdminOfficialPriceModel
     */
    price_type?: number;
    /**
     * Type of price as character string
     * @type {string}
     * @memberof AdminOfficialPriceModel
     */
    price_type_code?: string;
    /**
     * Human-readable description of the price type
     * @type {string}
     * @memberof AdminOfficialPriceModel
     */
    price_type_text?: string;
    /**
     * Indicates if the price type is \'IEX Official Opening Price\' (\'Q\'/0x51).
     * @type {boolean}
     * @memberof AdminOfficialPriceModel
     */
    is_price_type_opening?: boolean;
    /**
     * Indicates if the price type is \'IEX Official Closing Price\' (\'M\'/0x4d).
     * @type {boolean}
     * @memberof AdminOfficialPriceModel
     */
    is_price_type_closing?: boolean;
    /**
     * Official price as decimal
     * @type {number}
     * @memberof AdminOfficialPriceModel
     */
    official_price?: number;
}

/**
 * Represents the response DTO for operational halt status information
 * @export
 */
export type AdminOperationalHaltStatusModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof AdminOperationalHaltStatusModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof AdminOperationalHaltStatusModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the operational halt status was recorded as DateTime
     * @type {Date}
     * @memberof AdminOperationalHaltStatusModel
     */
    timestamp?: Date;
    /**
     * Operational halt status as byte value
     * @type {number}
     * @memberof AdminOperationalHaltStatusModel
     */
    operational_halt_status?: number;
    /**
     * Operational halt status as character string
     * @type {string}
     * @memberof AdminOperationalHaltStatusModel
     */
    operational_halt_status_code?: string;
    /**
     * Human-readable description of the operational halt status
     * @type {string}
     * @memberof AdminOperationalHaltStatusModel
     */
    operational_halt_status_text?: string;
    /**
     * Indicates if the status is \'IEX specific operational trading halt\' (\'O\'/0x4f).
     * @type {boolean}
     * @memberof AdminOperationalHaltStatusModel
     */
    is_operationally_halted?: boolean;
    /**
     * Indicates if the status is \'Not operationally halted on IEX\' (\'N\'/0x4e).
     * @type {boolean}
     * @memberof AdminOperationalHaltStatusModel
     */
    is_not_operationally_halted?: boolean;
}

/**
 * Represents the response DTO for retail liquidity indicator information
 * @export
 */
export type AdminRetailLiquidityIndicatorModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the retail liquidity indicator was recorded as DateTime
     * @type {Date}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    timestamp?: Date;
    /**
     * Retail liquidity indicator as byte value
     * @type {number}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    retail_liquidity_indicator?: number;
    /**
     * Retail liquidity indicator as character string
     * @type {string}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    retail_liquidity_indicator_code?: string;
    /**
     * Human-readable description of the retail liquidity indicator
     * @type {string}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    retail_liquidity_indicator_text?: string;
    /**
     * Indicates if the indicator is \'Not Applicable\' (\' \'/0x20).
     * @type {boolean}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    is_retail_indicator_not_applicable?: boolean;
    /**
     * Indicates if there is \'Buy interest for Retail\' (\'A\'/0x41).
     * @type {boolean}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    is_retail_indicator_buy_interest?: boolean;
    /**
     * Indicates if there is \'Sell interest for Retail\' (\'B\'/0x42).
     * @type {boolean}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    is_retail_indicator_sell_interest?: boolean;
    /**
     * Indicates if there is \'Buy and sell interest for Retail\' (\'C\'/0x43).
     * @type {boolean}
     * @memberof AdminRetailLiquidityIndicatorModel
     */
    is_retail_indicator_buy_and_sell_interest?: boolean;
}

/**
 * Represents the response DTO for security directory information
 * @export
 */
export type AdminSecurityDirectoryModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof AdminSecurityDirectoryModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof AdminSecurityDirectoryModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the security directory information was recorded as DateTime
     * @type {Date}
     * @memberof AdminSecurityDirectoryModel
     */
    timestamp?: Date;
    /**
     * Flags for the security
     * @type {number}
     * @memberof AdminSecurityDirectoryModel
     */
    flags?: number;
    /**
     * Number of shares that represent a round lot
     * @type {number}
     * @memberof AdminSecurityDirectoryModel
     */
    round_lot_size?: number;
    /**
     * Adjusted previous official closing price as decimal
     * @type {number}
     * @memberof AdminSecurityDirectoryModel
     */
    adjusted_poc_price?: number;
    /**
     * LULD tier as byte value
     * @type {number}
     * @memberof AdminSecurityDirectoryModel
     */
    luld_tier?: number;
    /**
     * LULD tier as numeric string
     * @type {string}
     * @memberof AdminSecurityDirectoryModel
     */
    luld_tier_code?: string;
    /**
     * Human-readable description of the LULD tier
     * @type {string}
     * @memberof AdminSecurityDirectoryModel
     */
    luld_tier_text?: string;
    /**
     * Indicates if LULD Tier is \'Not applicable\' (0x0).
     * @type {boolean}
     * @memberof AdminSecurityDirectoryModel
     */
    is_luld_tier_not_applicable?: boolean;
    /**
     * Indicates if LULD Tier is \'Tier 1 NMS Stock\' (0x1).
     * @type {boolean}
     * @memberof AdminSecurityDirectoryModel
     */
    is_luld_tier1?: boolean;
    /**
     * Indicates if LULD Tier is \'Tier 2 NMS Stock\' (0x2).
     * @type {boolean}
     * @memberof AdminSecurityDirectoryModel
     */
    is_luld_tier2?: boolean;
}

/**
 * Represents the response DTO for security event information
 * @export
 */
export type AdminSecurityEventModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof AdminSecurityEventModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof AdminSecurityEventModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the security event was recorded as DateTime
     * @type {Date}
     * @memberof AdminSecurityEventModel
     */
    timestamp?: Date;
    /**
     * Security event as byte value
     * @type {number}
     * @memberof AdminSecurityEventModel
     */
    security_event?: number;
    /**
     * Security event as character string (\'O\' or \'C\')
     * @type {string}
     * @memberof AdminSecurityEventModel
     */
    security_event_code?: string;
    /**
     * Human-readable description of the security event
     * @type {string}
     * @memberof AdminSecurityEventModel
     */
    security_event_text?: string;
    /**
     * Indicates if the security event is \'Opening Process Complete\' (\'O\'/0x4f).
     * @type {boolean}
     * @memberof AdminSecurityEventModel
     */
    is_opening_process_complete?: boolean;
    /**
     * Indicates if the security event is \'Closing Process Complete\' (\'C\'/0x43).
     * @type {boolean}
     * @memberof AdminSecurityEventModel
     */
    is_closing_process_complete?: boolean;
}

/**
 * Represents the response DTO for short sale price test status information
 * @export
 */
export type AdminShortSalePriceTestStatusModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the short sale price test status was recorded as DateTime
     * @type {Date}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    timestamp?: Date;
    /**
     * Short sale price test status as byte value
     * @type {number}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    short_sale_price_test_status?: number;
    /**
     * Short sale price test status as hex string
     * @type {string}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    short_sale_price_test_status_code?: string;
    /**
     * Human-readable description of the short sale price test status
     * @type {string}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    short_sale_price_test_status_text?: string;
    /**
     * Indicates if the short sale price test is not in effect
     * @type {boolean}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    is_short_sale_price_test_not_in_effect?: boolean;
    /**
     * Indicates if the short sale price test is in effect
     * @type {boolean}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    is_short_sale_price_test_in_effect?: boolean;
    /**
     * Detail of the short sale price test as byte value
     * @type {number}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    detail?: number;
    /**
     * Detail of the short sale price test as character string
     * @type {string}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    detail_code?: string;
    /**
     * Human-readable description of the short sale price test detail
     * @type {string}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    detail_text?: string;
    /**
     * Indicates if there is no price test in place
     * @type {boolean}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    is_detail_no_price_test?: boolean;
    /**
     * Indicates if the short sale price test restriction is in effect due to an intraday price drop
     * @type {boolean}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    is_detail_activated?: boolean;
    /**
     * Indicates if the short sale price test restriction remains in effect from prior day
     * @type {boolean}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    is_detail_continued?: boolean;
    /**
     * Indicates if the short sale price test restriction is deactivated
     * @type {boolean}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    is_detail_deactivated?: boolean;
    /**
     * Indicates if the detail is not available
     * @type {boolean}
     * @memberof AdminShortSalePriceTestStatusModel
     */
    is_detail_not_available?: boolean;
}

/**
 * Represents the response DTO for system event information
 * @export
 */
export type AdminSystemEventModel = {
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof AdminSystemEventModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the system event was recorded as DateTime
     * @type {Date}
     * @memberof AdminSystemEventModel
     */
    timestamp?: Date;
    /**
     * System event as byte value
     * @type {number}
     * @memberof AdminSystemEventModel
     */
    system_event?: number;
    /**
     * System event as string
     * @type {string}
     * @memberof AdminSystemEventModel
     */
    system_event_code?: string;
    /**
     * Human-readable description of the system event
     * @type {string}
     * @memberof AdminSystemEventModel
     */
    system_event_text?: string;
    /**
     * Indicates if the system event is \'Start of Messages\' (O). Outside of heartbeat messages on the lower level protocol,  the start of day message is the first message sent in any trading session.
     * @type {boolean}
     * @memberof AdminSystemEventModel
     */
    is_system_event_start_of_messages?: boolean;
    /**
     * Indicates if the system event is \'Start of System Hours\' (S). This message indicates that IEX is open and ready to start accepting orders.
     * @type {boolean}
     * @memberof AdminSystemEventModel
     */
    is_system_event_start_of_system_hours?: boolean;
    /**
     * Indicates if the system event is \'Start of Regular Market Hours\' (R). This message indicates that DAY and GTX orders, as well as market orders and pegged orders,  are available for execution on IEX.
     * @type {boolean}
     * @memberof AdminSystemEventModel
     */
    is_system_event_start_of_regular_market_hours?: boolean;
    /**
     * Indicates if the system event is \'End of Regular Market Hours\' (M). This message indicates that DAY orders, market orders, and pegged orders  are no longer accepted by IEX.
     * @type {boolean}
     * @memberof AdminSystemEventModel
     */
    is_system_event_end_of_regular_market_hours?: boolean;
    /**
     * Indicates if the system event is \'End of System Hours\' (E). This message indicates that IEX is now closed and will not accept  any new orders during this trading session. It is still possible  to receive messages after the end of day.
     * @type {boolean}
     * @memberof AdminSystemEventModel
     */
    is_system_event_end_of_system_hours?: boolean;
    /**
     * Indicates if the system event is \'End of Messages\' (C). This is always the last message sent in any trading session.
     * @type {boolean}
     * @memberof AdminSystemEventModel
     */
    is_system_event_end_of_messages?: boolean;
}

/**
 * Represents the response DTO for trading status information
 * @export
 */
export type AdminTradingStatusModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof AdminTradingStatusModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof AdminTradingStatusModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the trading status was recorded as DateTime
     * @type {Date}
     * @memberof AdminTradingStatusModel
     */
    timestamp?: Date;
    /**
     * Gets whether the security is currently trading on IEX
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_trading_live?: boolean;
    /**
     * Gets whether the security is halted across all US equity markets
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_trading_halted?: boolean;
    /**
     * Gets whether the security is in Order Acceptance Period on IEX
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_trading_in_order_acceptance_period?: boolean;
    /**
     * Gets whether the security is paused and in Order Acceptance Period on IEX
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_trading_paused?: boolean;
    /**
     * Gets whether the halt reason is News Pending
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_halt_news_pending?: boolean;
    /**
     * Gets whether the halt reason is IPO Not Yet Trading
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_ipo_not_yet_trading?: boolean;
    /**
     * Gets whether the halt reason is IPO Deferred
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_ipo_deferred?: boolean;
    /**
     * Gets whether the order acceptance period reason is Halt News Dissemination
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_halt_news_dissemination?: boolean;
    /**
     * Gets whether the order acceptance period reason is IPO Order Acceptance Period
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_ipo_order_acceptance_period?: boolean;
    /**
     * Gets whether the order acceptance period reason is IPO Pre-Launch Period
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_ipo_pre_launch_period?: boolean;
    /**
     * Gets whether the order acceptance period reason is Market-Wide Circuit Breaker Level 1 – Breached
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_market_wide_circuit_breaker_level1?: boolean;
    /**
     * Gets whether the order acceptance period reason is Market-Wide Circuit Breaker Level 2 – Breached
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_market_wide_circuit_breaker_level2?: boolean;
    /**
     * Gets whether the halt reason is Market-Wide Circuit Breaker Level 3 – Breached
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_market_wide_circuit_breaker_level3?: boolean;
    /**
     * Gets whether the reason is Not Applicable
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_not_applicable?: boolean;
    /**
     * Gets whether the halt reason is Not Available
     * @type {boolean}
     * @memberof AdminTradingStatusModel
     */
    is_reason_not_available?: boolean;
}

/**
 * 
 * @export
 */
export type FinFeedAPIExchangeModel = {
    [key: string]: AnyType | any;

    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    exchange_id?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    last_datapoint_date?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    mic?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    operating_mic?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    oprt_sgmt?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    market_name_institution_description?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    legal_entity_name?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    lei?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    market_category_code?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    acronym?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    iso_country_code?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof FinFeedAPIExchangeModel
     */
    creation_date?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FinFeedAPIExchangeModel
     */
    last_update_date?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FinFeedAPIExchangeModel
     */
    last_validation_date?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FinFeedAPIExchangeModel
     */
    expiry_date?: Date;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPIExchangeModel
     */
    comments?: string;
}

/**
 * 
 * @export
 */
export type FinFeedAPISymbolModel = {
    [key: string]: AnyType | any;

    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    symbol_id?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    exchange_id?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    security_category?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    _date?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    asset_class?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    cfi_code?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    cfi_category?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    cfi_group?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    cfi_attribute1?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    cfi_attribute2?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    cfi_attribute3?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    cfi_attribute4?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    cfi_category_desc?: string;
    /**
     * 
     * @type {string}
     * @memberof FinFeedAPISymbolModel
     */
    cfi_group_desc?: string;
}

/**
 * Represents the response DTO for quote update information
 * @export
 */
export type Level1QuoteUpdateModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof Level1QuoteUpdateModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof Level1QuoteUpdateModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the quote update was recorded as DateTime
     * @type {Date}
     * @memberof Level1QuoteUpdateModel
     */
    timestamp?: Date;
    /**
     * Gets whether the symbol is available for trading True if active, False if halted, paused, or otherwise not available
     * @type {boolean}
     * @memberof Level1QuoteUpdateModel
     */
    is_symbol_available?: boolean;
    /**
     * Gets whether the market session is regular or pre/post-market True if pre/post-market session, False if regular market session
     * @type {boolean}
     * @memberof Level1QuoteUpdateModel
     */
    is_pre_post_market_session?: boolean;
    /**
     * Ask size in number of shares
     * @type {number}
     * @memberof Level1QuoteUpdateModel
     */
    ask_size?: number;
    /**
     * Ask price as decimal
     * @type {number}
     * @memberof Level1QuoteUpdateModel
     */
    ask_price?: number;
    /**
     * Bid price as decimal
     * @type {number}
     * @memberof Level1QuoteUpdateModel
     */
    bid_price?: number;
    /**
     * Bid size in number of shares
     * @type {number}
     * @memberof Level1QuoteUpdateModel
     */
    bid_size?: number;
}

/**
 * Represents the response DTO for price level update information
 * @export
 */
export type Level2PriceLevelUpdateModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof Level2PriceLevelUpdateModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof Level2PriceLevelUpdateModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the price level update was recorded as DateTime
     * @type {Date}
     * @memberof Level2PriceLevelUpdateModel
     */
    timestamp?: Date;
    /**
     * Indicates if this is a price level update for the Buy Side.
     * @type {boolean}
     * @memberof Level2PriceLevelUpdateModel
     */
    is_side_buy?: boolean;
    /**
     * Indicates if event processing is complete.
     * @type {boolean}
     * @memberof Level2PriceLevelUpdateModel
     */
    is_event_processing_complete?: boolean;
    /**
     * Aggregate quoted size at the price level
     * @type {number}
     * @memberof Level2PriceLevelUpdateModel
     */
    size?: number;
    /**
     * Price level as decimal
     * @type {number}
     * @memberof Level2PriceLevelUpdateModel
     */
    price?: number;
}

/**
 * Represents the response DTO for add order information
 * @export
 */
export type Level3AddOrderModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof Level3AddOrderModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof Level3AddOrderModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the order was added as DateTime (UTC)
     * @type {Date}
     * @memberof Level3AddOrderModel
     */
    timestamp?: Date;
    /**
     * Indicates if this is a Buy order (\'8\'/0x38).
     * @type {boolean}
     * @memberof Level3AddOrderModel
     */
    is_side_buy?: boolean;
    /**
     * Quoted size in number of shares
     * @type {number}
     * @memberof Level3AddOrderModel
     */
    size?: number;
    /**
     * Price as decimal
     * @type {number}
     * @memberof Level3AddOrderModel
     */
    price?: number;
    /**
     * Order identifier
     * @type {number}
     * @memberof Level3AddOrderModel
     */
    order_id?: number;
}

/**
 * Represents the response DTO for clear book information
 * @export
 */
export type Level3ClearBookModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof Level3ClearBookModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof Level3ClearBookModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the book was cleared as DateTime
     * @type {Date}
     * @memberof Level3ClearBookModel
     */
    timestamp?: Date;
}

/**
 * Represents the response DTO for order delete information
 * @export
 */
export type Level3DeleteOrderModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof Level3DeleteOrderModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof Level3DeleteOrderModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the order was deleted as DateTime
     * @type {Date}
     * @memberof Level3DeleteOrderModel
     */
    timestamp?: Date;
    /**
     * Order identifier reference
     * @type {number}
     * @memberof Level3DeleteOrderModel
     */
    order_id_reference?: number;
}

/**
 * Represents the response DTO for order executed information
 * @export
 */
export type Level3ExecutedOrderModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof Level3ExecutedOrderModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof Level3ExecutedOrderModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the order was executed as DateTime
     * @type {Date}
     * @memberof Level3ExecutedOrderModel
     */
    timestamp?: Date;
    /**
     * Order identifier reference
     * @type {number}
     * @memberof Level3ExecutedOrderModel
     */
    order_id_reference?: number;
    /**
     * Sale condition flags for the execution as byte value
     * @type {number}
     * @memberof Level3ExecutedOrderModel
     */
    sale_condition_flags?: number;
    /**
     * Bit 7 (Mask 0x80): Intermarket Sweep Flag True: Intermarket Sweep Order (\"ISO\") False: Non-Intermarket Sweep Order
     * @type {boolean}
     * @memberof Level3ExecutedOrderModel
     */
    is_intermarket_sweep?: boolean;
    /**
     * Bit 6 (Mask 0x40): Extended Hours Flag True: Extended Hours Trade (i.e., Form T sale condition) False: Regular Market Session Trade
     * @type {boolean}
     * @memberof Level3ExecutedOrderModel
     */
    is_extended_hours_trade?: boolean;
    /**
     * Bit 5 (Mask 0x20): Odd Lot Flag True: Odd Lot Trade False: Round or Mixed Lot Trade
     * @type {boolean}
     * @memberof Level3ExecutedOrderModel
     */
    is_odd_lot_trade?: boolean;
    /**
     * Bit 4 (Mask 0x10): Trade Through Exempt Flag True: Trade is not subject to Rule 611 (Trade Through) of SEC Reg. NMS False: Trade is subject to Rule 611 (Trade Through) of SEC Reg. NMS
     * @type {boolean}
     * @memberof Level3ExecutedOrderModel
     */
    is_trade_through_exempt?: boolean;
    /**
     * Bit 3 (Mask 0x08): Single-price Cross Trade Flag True: Trade resulting from a single-price cross False: Execution during continuous trading
     * @type {boolean}
     * @memberof Level3ExecutedOrderModel
     */
    is_single_price_cross_trade?: boolean;
    /**
     * Trade volume in number of shares
     * @type {number}
     * @memberof Level3ExecutedOrderModel
     */
    size?: number;
    /**
     * Execution price as decimal
     * @type {number}
     * @memberof Level3ExecutedOrderModel
     */
    price?: number;
    /**
     * IEX trade identifier
     * @type {number}
     * @memberof Level3ExecutedOrderModel
     */
    trade_id?: number;
}

/**
 * Represents the response DTO for order modify information
 * @export
 */
export type Level3ModifyOrderModel = {
    /**
     * The stock symbol
     * @type {string}
     * @memberof Level3ModifyOrderModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch
     * @type {number}
     * @memberof Level3ModifyOrderModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the order was modified as DateTime (UTC)
     * @type {Date}
     * @memberof Level3ModifyOrderModel
     */
    timestamp?: Date;
    /**
     * Order identifier reference
     * @type {number}
     * @memberof Level3ModifyOrderModel
     */
    order_id_reference?: number;
    /**
     * Indicates if priority is reseted
     * @type {boolean}
     * @memberof Level3ModifyOrderModel
     */
    is_priority_reset?: boolean;
    /**
     * New total quoted size in number of shares
     * @type {number}
     * @memberof Level3ModifyOrderModel
     */
    size?: number;
    /**
     * Price as decimal
     * @type {number}
     * @memberof Level3ModifyOrderModel
     */
    price?: number;
}

/**
 * Represents the response DTO for Level-3 order book information
 * @export
 */
export type Level3OrderBookModel = {
    /**
     * 
     * @type {Level3AddOrderModel}
     * @memberof Level3OrderBookModel
     */
    add_order?: Level3AddOrderModel;
    /**
     * 
     * @type {Level3DeleteOrderModel}
     * @memberof Level3OrderBookModel
     */
    delete_order?: Level3DeleteOrderModel;
    /**
     * 
     * @type {Level3ModifyOrderModel}
     * @memberof Level3OrderBookModel
     */
    modify_order?: Level3ModifyOrderModel;
    /**
     * 
     * @type {Level3ExecutedOrderModel}
     * @memberof Level3OrderBookModel
     */
    executed_order?: Level3ExecutedOrderModel;
    /**
     * 
     * @type {Level3ClearBookModel}
     * @memberof Level3OrderBookModel
     */
    clear_book?: Level3ClearBookModel;
}

/**
 * Represents a timeseries item with price and volume information.
 * @export
 */
export type OHLCVExchangeTimeseriesItem = {
    /**
     * Gets or sets the start time of the time period.
     * @type {Date}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    time_period_start?: Date;
    /**
     * Gets or sets the end time of the time period.
     * @type {Date}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    time_period_end?: Date;
    /**
     * Gets or sets the time when the price opened.
     * @type {Date}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    time_open?: Date;
    /**
     * Gets or sets the time when the price closed.
     * @type {Date}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    time_close?: Date;
    /**
     * Gets or sets the opening price.
     * @type {number}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    price_open?: number;
    /**
     * Gets or sets the highest price during the time period.
     * @type {number}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    price_high?: number;
    /**
     * Gets or sets the lowest price during the time period.
     * @type {number}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    price_low?: number;
    /**
     * Gets or sets the closing price.
     * @type {number}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    price_close?: number;
    /**
     * Gets or sets the total volume traded during the time period.
     * @type {number}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    volume_traded?: number;
    /**
     * Gets or sets the number of trades executed during the time period.
     * @type {number}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    trades_count?: number;
    /**
     * 
     * @type {string}
     * @memberof OHLCVExchangeTimeseriesItem
     */
    symbol_id_exchange?: string;
}

/**
 * Represents a timeseries item with price and volume information.
 * @export
 */
export type OHLCVTimeseriesItem = {
    /**
     * Gets or sets the start time of the time period.
     * @type {Date}
     * @memberof OHLCVTimeseriesItem
     */
    time_period_start?: Date;
    /**
     * Gets or sets the end time of the time period.
     * @type {Date}
     * @memberof OHLCVTimeseriesItem
     */
    time_period_end?: Date;
    /**
     * Gets or sets the time when the price opened.
     * @type {Date}
     * @memberof OHLCVTimeseriesItem
     */
    time_open?: Date;
    /**
     * Gets or sets the time when the price closed.
     * @type {Date}
     * @memberof OHLCVTimeseriesItem
     */
    time_close?: Date;
    /**
     * Gets or sets the opening price.
     * @type {number}
     * @memberof OHLCVTimeseriesItem
     */
    price_open?: number;
    /**
     * Gets or sets the highest price during the time period.
     * @type {number}
     * @memberof OHLCVTimeseriesItem
     */
    price_high?: number;
    /**
     * Gets or sets the lowest price during the time period.
     * @type {number}
     * @memberof OHLCVTimeseriesItem
     */
    price_low?: number;
    /**
     * Gets or sets the closing price.
     * @type {number}
     * @memberof OHLCVTimeseriesItem
     */
    price_close?: number;
    /**
     * Gets or sets the total volume traded during the time period.
     * @type {number}
     * @memberof OHLCVTimeseriesItem
     */
    volume_traded?: number;
    /**
     * Gets or sets the number of trades executed during the time period.
     * @type {number}
     * @memberof OHLCVTimeseriesItem
     */
    trades_count?: number;
}

/**
 * Represents a timeseries period used in exchange rate data.
 * @export
 */
export type OHLCVTimeseriesPeriod = {
    /**
     * Gets or sets the period ID.
     * @type {string}
     * @memberof OHLCVTimeseriesPeriod
     */
    period_id?: string;
    /**
     * Gets or sets the length of the period in seconds.
     * @type {number}
     * @memberof OHLCVTimeseriesPeriod
     */
    length_seconds?: number;
    /**
     * Gets or sets the length of the period in months.
     * @type {number}
     * @memberof OHLCVTimeseriesPeriod
     */
    length_months?: number;
    /**
     * Gets or sets the unit count.
     * @type {number}
     * @memberof OHLCVTimeseriesPeriod
     */
    unit_count?: number;
    /**
     * Gets or sets the unit name.
     * @type {string}
     * @memberof OHLCVTimeseriesPeriod
     */
    unit_name?: string;
    /**
     * Gets or sets the display name of the timeseries period.
     * @type {string}
     * @memberof OHLCVTimeseriesPeriod
     */
    display_name?: string;
}

/**
 * Represents the response DTO for a single trade event (report or break).
 * @export
 */
export type TradeTradeModel = {
    /**
     * Indicates if this record represents a trade break (true) or a trade report (false).
     * @type {boolean}
     * @memberof TradeTradeModel
     */
    is_trade_break?: boolean;
    /**
     * The stock symbol.
     * @type {string}
     * @memberof TradeTradeModel
     */
    symbol?: string;
    /**
     * Original timestamp in nanoseconds since epoch.
     * @type {number}
     * @memberof TradeTradeModel
     */
    timestamp_nanos?: number;
    /**
     * Time when the event was recorded as DateTime (UTC).
     * @type {Date}
     * @memberof TradeTradeModel
     */
    timestamp?: Date;
    /**
     * Trade volume (or break volume) in number of shares.
     * @type {number}
     * @memberof TradeTradeModel
     */
    size?: number;
    /**
     * Trade price (or break price) as decimal.
     * @type {number}
     * @memberof TradeTradeModel
     */
    price?: number;
    /**
     * IEX trade identifier (same for report and its corresponding break).
     * @type {number}
     * @memberof TradeTradeModel
     */
    trade_id?: number;
    /**
     * Bit 7 (Mask 0x80): Intermarket Sweep Flag. True: Intermarket Sweep Order (\"ISO\"). False: Non-Intermarket Sweep Order.
     * @type {boolean}
     * @memberof TradeTradeModel
     */
    is_intermarket_sweep?: boolean;
    /**
     * Bit 6 (Mask 0x40): Extended Hours Flag. True: Extended Hours Trade (i.e., Form T sale condition). False: Regular Market Session Trade.
     * @type {boolean}
     * @memberof TradeTradeModel
     */
    is_extended_hours_trade?: boolean;
    /**
     * Bit 5 (Mask 0x20): Odd Lot Flag. True: Odd Lot Trade. False: Round or Mixed Lot Trade.
     * @type {boolean}
     * @memberof TradeTradeModel
     */
    is_odd_lot_trade?: boolean;
    /**
     * Bit 4 (Mask 0x10): Trade Through Exempt Flag. True: Trade is not subject to Rule 611 (Trade Through) of SEC Reg. NMS. False: Trade is subject to Rule 611 (Trade Through) of SEC Reg. NMS. Applied when the taking order was an ISO that traded through a protected quotation, OR the NBBO was crossed at the time of the trade, OR the trade occurred through a self-helped venue\'s quotation, OR the trade was a single-price cross.
     * @type {boolean}
     * @memberof TradeTradeModel
     */
    is_trade_through_exempt?: boolean;
    /**
     * Bit 3 (Mask 0x08): Single-price Cross Trade Flag. True: Trade resulting from a single-price cross. False: Execution during continuous trading.
     * @type {boolean}
     * @memberof TradeTradeModel
     */
    is_single_price_cross_trade?: boolean;
}



/**
 * MetadataApi - fetch parameter creator
 * @export
 */
export const MetadataApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List of exchanges
         * @throws {RequiredError}
         */
        v1ExchangesGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/exchanges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of symbols for the exchange
         * @throws {RequiredError}
         */
        v1SymbolsExchangeIdGet(exchangeId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1SymbolsExchangeIdGet.');
            }
            const localVarPath = `/v1/symbols/{exchange_id}`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MetadataApiType = { 
    v1ExchangesGet(options?: RequestOptions): Promise<Array<FinFeedAPIExchangeModel>>,

    v1SymbolsExchangeIdGet(exchangeId: string, options?: RequestOptions): Promise<Array<FinFeedAPISymbolModel>>,
}

/**
 * MetadataApi - factory function to inject configuration 
 * @export
 */
export const MetadataApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MetadataApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List of exchanges
         * @throws {RequiredError}
         */
        v1ExchangesGet(options?: RequestOptions = {}): Promise<Array<FinFeedAPIExchangeModel>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1ExchangesGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List of symbols for the exchange
         * @throws {RequiredError}
         */
        v1SymbolsExchangeIdGet(exchangeId: string, options?: RequestOptions = {}): Promise<Array<FinFeedAPISymbolModel>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1SymbolsExchangeIdGet(exchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * NativeIEXApi - fetch parameter creator
 * @export
 */
export const NativeIEXApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Admin Messages
         * @throws {RequiredError}
         */
        v1NativeIexAdminMessagesSymbolGet(symbol: string, _date: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling v1NativeIexAdminMessagesSymbolGet.');
            }
            // verify required parameter '_date' is not null or undefined
            if (_date === null || _date === undefined) {
                throw new RequiredError('_date','Required parameter _date was null or undefined when calling v1NativeIexAdminMessagesSymbolGet.');
            }
            const localVarPath = `/v1/native/iex/admin/messages/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get System Events
         * @throws {RequiredError}
         */
        v1NativeIexAdminSystemEventGet(_date: Date, options: RequestOptions): FetchArgs {
            // verify required parameter '_date' is not null or undefined
            if (_date === null || _date === undefined) {
                throw new RequiredError('_date','Required parameter _date was null or undefined when calling v1NativeIexAdminSystemEventGet.');
            }
            const localVarPath = `/v1/native/iex/admin/system-event`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Level-1 Quotes
         * @throws {RequiredError}
         */
        v1NativeIexLevel1QuoteSymbolGet(symbol: string, _date: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling v1NativeIexLevel1QuoteSymbolGet.');
            }
            // verify required parameter '_date' is not null or undefined
            if (_date === null || _date === undefined) {
                throw new RequiredError('_date','Required parameter _date was null or undefined when calling v1NativeIexLevel1QuoteSymbolGet.');
            }
            const localVarPath = `/v1/native/iex/level1-quote/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Level-2 Price Level Book
         * @throws {RequiredError}
         */
        v1NativeIexLevel2PriceLevelUpdateSymbolGet(symbol: string, _date: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling v1NativeIexLevel2PriceLevelUpdateSymbolGet.');
            }
            // verify required parameter '_date' is not null or undefined
            if (_date === null || _date === undefined) {
                throw new RequiredError('_date','Required parameter _date was null or undefined when calling v1NativeIexLevel2PriceLevelUpdateSymbolGet.');
            }
            const localVarPath = `/v1/native/iex/level2-price-level-update/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Level-3 Order Book
         * @throws {RequiredError}
         */
        v1NativeIexLevel3OrderBookSymbolGet(symbol: string, _date: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling v1NativeIexLevel3OrderBookSymbolGet.');
            }
            // verify required parameter '_date' is not null or undefined
            if (_date === null || _date === undefined) {
                throw new RequiredError('_date','Required parameter _date was null or undefined when calling v1NativeIexLevel3OrderBookSymbolGet.');
            }
            const localVarPath = `/v1/native/iex/level3-order-book/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Trades
         * @throws {RequiredError}
         */
        v1NativeIexTradeSymbolGet(symbol: string, _date: Date, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling v1NativeIexTradeSymbolGet.');
            }
            // verify required parameter '_date' is not null or undefined
            if (_date === null || _date === undefined) {
                throw new RequiredError('_date','Required parameter _date was null or undefined when calling v1NativeIexTradeSymbolGet.');
            }
            const localVarPath = `/v1/native/iex/trade/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type NativeIEXApiType = { 
    v1NativeIexAdminMessagesSymbolGet(symbol: string, _date: Date, options?: RequestOptions): Promise<Array<AdminAdminMessageModel>>,

    v1NativeIexAdminSystemEventGet(_date: Date, options?: RequestOptions): Promise<Array<AdminSystemEventModel>>,

    v1NativeIexLevel1QuoteSymbolGet(symbol: string, _date: Date, options?: RequestOptions): Promise<Array<Level1QuoteUpdateModel>>,

    v1NativeIexLevel2PriceLevelUpdateSymbolGet(symbol: string, _date: Date, options?: RequestOptions): Promise<Array<Level2PriceLevelUpdateModel>>,

    v1NativeIexLevel3OrderBookSymbolGet(symbol: string, _date: Date, options?: RequestOptions): Promise<Array<Level3OrderBookModel>>,

    v1NativeIexTradeSymbolGet(symbol: string, _date: Date, options?: RequestOptions): Promise<Array<TradeTradeModel>>,
}

/**
 * NativeIEXApi - factory function to inject configuration 
 * @export
 */
export const NativeIEXApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): NativeIEXApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Get Admin Messages
         * @throws {RequiredError}
         */
        v1NativeIexAdminMessagesSymbolGet(symbol: string, _date: Date, options?: RequestOptions = {}): Promise<Array<AdminAdminMessageModel>> {
            const localVarFetchArgs = NativeIEXApiFetchParamCreator(configuration).v1NativeIexAdminMessagesSymbolGet(symbol, _date, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get System Events
         * @throws {RequiredError}
         */
        v1NativeIexAdminSystemEventGet(_date: Date, options?: RequestOptions = {}): Promise<Array<AdminSystemEventModel>> {
            const localVarFetchArgs = NativeIEXApiFetchParamCreator(configuration).v1NativeIexAdminSystemEventGet(_date, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get Level-1 Quotes
         * @throws {RequiredError}
         */
        v1NativeIexLevel1QuoteSymbolGet(symbol: string, _date: Date, options?: RequestOptions = {}): Promise<Array<Level1QuoteUpdateModel>> {
            const localVarFetchArgs = NativeIEXApiFetchParamCreator(configuration).v1NativeIexLevel1QuoteSymbolGet(symbol, _date, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get Level-2 Price Level Book
         * @throws {RequiredError}
         */
        v1NativeIexLevel2PriceLevelUpdateSymbolGet(symbol: string, _date: Date, options?: RequestOptions = {}): Promise<Array<Level2PriceLevelUpdateModel>> {
            const localVarFetchArgs = NativeIEXApiFetchParamCreator(configuration).v1NativeIexLevel2PriceLevelUpdateSymbolGet(symbol, _date, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get Level-3 Order Book
         * @throws {RequiredError}
         */
        v1NativeIexLevel3OrderBookSymbolGet(symbol: string, _date: Date, options?: RequestOptions = {}): Promise<Array<Level3OrderBookModel>> {
            const localVarFetchArgs = NativeIEXApiFetchParamCreator(configuration).v1NativeIexLevel3OrderBookSymbolGet(symbol, _date, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get Trades
         * @throws {RequiredError}
         */
        v1NativeIexTradeSymbolGet(symbol: string, _date: Date, options?: RequestOptions = {}): Promise<Array<TradeTradeModel>> {
            const localVarFetchArgs = NativeIEXApiFetchParamCreator(configuration).v1NativeIexTradeSymbolGet(symbol, _date, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OhlcvApi - fetch parameter creator
 * @export
 */
export const OhlcvApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get OHLCV timeseries data returned in time ascending order. Data can be requested by the period and for the specific exchange.
         * @summary Historical data by exchange
         * @throws {RequiredError}
         */
        v1OhlcvExchangeExchangeIdHistoryGet(exchangeId: string, periodId: string, timeStart: string, timeEnd: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1OhlcvExchangeExchangeIdHistoryGet.');
            }
            // verify required parameter 'periodId' is not null or undefined
            if (periodId === null || periodId === undefined) {
                throw new RequiredError('periodId','Required parameter periodId was null or undefined when calling v1OhlcvExchangeExchangeIdHistoryGet.');
            }
            // verify required parameter 'timeStart' is not null or undefined
            if (timeStart === null || timeStart === undefined) {
                throw new RequiredError('timeStart','Required parameter timeStart was null or undefined when calling v1OhlcvExchangeExchangeIdHistoryGet.');
            }
            // verify required parameter 'timeEnd' is not null or undefined
            if (timeEnd === null || timeEnd === undefined) {
                throw new RequiredError('timeEnd','Required parameter timeEnd was null or undefined when calling v1OhlcvExchangeExchangeIdHistoryGet.');
            }
            const localVarPath = `/v1/ohlcv/exchange/{exchange_id}/history`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):string);
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OHLCV timeseries data returned in time ascending order.
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1OhlcvExchangeSymbolExchangeIdSymbolIdHistoryGet(exchangeId: string, symbolId: string, periodId: string, timeStart?: string, timeEnd?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1OhlcvExchangeSymbolExchangeIdSymbolIdHistoryGet.');
            }
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1OhlcvExchangeSymbolExchangeIdSymbolIdHistoryGet.');
            }
            // verify required parameter 'periodId' is not null or undefined
            if (periodId === null || periodId === undefined) {
                throw new RequiredError('periodId','Required parameter periodId was null or undefined when calling v1OhlcvExchangeSymbolExchangeIdSymbolIdHistoryGet.');
            }
            const localVarPath = `/v1/ohlcv/exchange-symbol/{exchange_id}/{symbol_id}/history`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)))
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):string);
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OHLCV latest timeseries data returned in time descending order. Data can be requested by the period and for the specific symbol eg `BITSTAMP_SPOT_BTC_USD`, if you need to query timeseries by asset pairs eg. `BTC/USD`, then please reffer to the Exchange Rates Timeseries data              :::info OHLCV Latest endpoint is just the shortcut to the OHLCV Historical endpoint with substituted `time_start` and `time_end` parameters.  The OHLCV Historical endpoint data can be delayed a few seconds. Use OHLCV real-time data stream to get data without delay. :::
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1OhlcvExchangeSymbolExchangeIdSymbolIdLatestGet(exchangeId: string, symbolId: string, periodId: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1OhlcvExchangeSymbolExchangeIdSymbolIdLatestGet.');
            }
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1OhlcvExchangeSymbolExchangeIdSymbolIdLatestGet.');
            }
            // verify required parameter 'periodId' is not null or undefined
            if (periodId === null || periodId === undefined) {
                throw new RequiredError('periodId','Required parameter periodId was null or undefined when calling v1OhlcvExchangeSymbolExchangeIdSymbolIdLatestGet.');
            }
            const localVarPath = `/v1/ohlcv/exchange-symbol/{exchange_id}/{symbol_id}/latest`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)))
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get full list of supported time periods available for requesting OHLCV timeseries data.              ### Available periods              Time unit | Period identifiers --------- | ----------- Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY Month | 1MTH, 2MTH, 3MTH, 4MTH, 6MTH Year | 1YRS, 2YRS, 3YRS, 4YRS, 5YRS              :::tip You can assume that we will not remove any periods from this response, however, we may add new ones. :::
         * @summary List all periods
         * @throws {RequiredError}
         */
        v1OhlcvPeriodsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/ohlcv/periods`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication JWT required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OhlcvApiType = { 
    v1OhlcvExchangeExchangeIdHistoryGet(exchangeId: string, periodId: string, timeStart: string, timeEnd: string, options?: RequestOptions): Promise<Array<OHLCVExchangeTimeseriesItem>>,

    v1OhlcvExchangeSymbolExchangeIdSymbolIdHistoryGet(exchangeId: string, symbolId: string, periodId: string, timeStart?: string, timeEnd?: string, limit?: number, options?: RequestOptions): Promise<Array<OHLCVTimeseriesItem>>,

    v1OhlcvExchangeSymbolExchangeIdSymbolIdLatestGet(exchangeId: string, symbolId: string, periodId: string, limit?: number, options?: RequestOptions): Promise<Array<OHLCVTimeseriesItem>>,

    v1OhlcvPeriodsGet(options?: RequestOptions): Promise<Array<OHLCVTimeseriesPeriod>>,
}

/**
 * OhlcvApi - factory function to inject configuration 
 * @export
 */
export const OhlcvApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OhlcvApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get OHLCV timeseries data returned in time ascending order. Data can be requested by the period and for the specific exchange.
         * @summary Historical data by exchange
         * @throws {RequiredError}
         */
        v1OhlcvExchangeExchangeIdHistoryGet(exchangeId: string, periodId: string, timeStart: string, timeEnd: string, options?: RequestOptions = {}): Promise<Array<OHLCVExchangeTimeseriesItem>> {
            const localVarFetchArgs = OhlcvApiFetchParamCreator(configuration).v1OhlcvExchangeExchangeIdHistoryGet(exchangeId, periodId, timeStart, timeEnd, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get OHLCV timeseries data returned in time ascending order.
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1OhlcvExchangeSymbolExchangeIdSymbolIdHistoryGet(exchangeId: string, symbolId: string, periodId: string, timeStart?: string, timeEnd?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<OHLCVTimeseriesItem>> {
            const localVarFetchArgs = OhlcvApiFetchParamCreator(configuration).v1OhlcvExchangeSymbolExchangeIdSymbolIdHistoryGet(exchangeId, symbolId, periodId, timeStart, timeEnd, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get OHLCV latest timeseries data returned in time descending order. Data can be requested by the period and for the specific symbol eg `BITSTAMP_SPOT_BTC_USD`, if you need to query timeseries by asset pairs eg. `BTC/USD`, then please reffer to the Exchange Rates Timeseries data              :::info OHLCV Latest endpoint is just the shortcut to the OHLCV Historical endpoint with substituted `time_start` and `time_end` parameters.  The OHLCV Historical endpoint data can be delayed a few seconds. Use OHLCV real-time data stream to get data without delay. :::
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1OhlcvExchangeSymbolExchangeIdSymbolIdLatestGet(exchangeId: string, symbolId: string, periodId: string, limit?: number, options?: RequestOptions = {}): Promise<Array<OHLCVTimeseriesItem>> {
            const localVarFetchArgs = OhlcvApiFetchParamCreator(configuration).v1OhlcvExchangeSymbolExchangeIdSymbolIdLatestGet(exchangeId, symbolId, periodId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get full list of supported time periods available for requesting OHLCV timeseries data.              ### Available periods              Time unit | Period identifiers --------- | ----------- Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY Month | 1MTH, 2MTH, 3MTH, 4MTH, 6MTH Year | 1YRS, 2YRS, 3YRS, 4YRS, 5YRS              :::tip You can assume that we will not remove any periods from this response, however, we may add new ones. :::
         * @summary List all periods
         * @throws {RequiredError}
         */
        v1OhlcvPeriodsGet(options?: RequestOptions = {}): Promise<Array<OHLCVTimeseriesPeriod>> {
            const localVarFetchArgs = OhlcvApiFetchParamCreator(configuration).v1OhlcvPeriodsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    MetadataApi: MetadataApiType,

    NativeIEXApi: NativeIEXApiType,

    OhlcvApi: OhlcvApiType,
 }
