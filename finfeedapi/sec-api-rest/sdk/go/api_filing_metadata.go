/*
REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: support@apibricks.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// FilingMetadataAPIService FilingMetadataAPI service
type FilingMetadataAPIService service

type ApiV1FilingsGetRequest struct {
	ctx context.Context
	ApiService *FilingMetadataAPIService
	cik *int64
	formType *string
	fillingDateStart *string
	fillingDateEnd *string
	reportDateStart *string
	reportDateEnd *string
	itemsContain *string
	pageSize *int32
	pageNumber *int32
	sortBy *DTOFilingSortBy
	sortOrder *string
}

// Filter by Central Index Key (CIK)
func (r ApiV1FilingsGetRequest) Cik(cik int64) ApiV1FilingsGetRequest {
	r.cik = &cik
	return r
}

// Filter by form type(s) (e.g., \&quot;10-K\&quot;, \&quot;8-K\&quot;). Multiple values can be comma-separated
func (r ApiV1FilingsGetRequest) FormType(formType string) ApiV1FilingsGetRequest {
	r.formType = &formType
	return r
}

// Filter by filling date start (inclusive), format YYYY-MM-DD
func (r ApiV1FilingsGetRequest) FillingDateStart(fillingDateStart string) ApiV1FilingsGetRequest {
	r.fillingDateStart = &fillingDateStart
	return r
}

// Filter by filling date end (inclusive), format YYYY-MM-DD
func (r ApiV1FilingsGetRequest) FillingDateEnd(fillingDateEnd string) ApiV1FilingsGetRequest {
	r.fillingDateEnd = &fillingDateEnd
	return r
}

// Filter by report date start (inclusive), format YYYY-MM-DD
func (r ApiV1FilingsGetRequest) ReportDateStart(reportDateStart string) ApiV1FilingsGetRequest {
	r.reportDateStart = &reportDateStart
	return r
}

// Filter by report date end (inclusive), format YYYY-MM-DD
func (r ApiV1FilingsGetRequest) ReportDateEnd(reportDateEnd string) ApiV1FilingsGetRequest {
	r.reportDateEnd = &reportDateEnd
	return r
}

// Filter filings where the &#39;Items&#39; field contains the specified text
func (r ApiV1FilingsGetRequest) ItemsContain(itemsContain string) ApiV1FilingsGetRequest {
	r.itemsContain = &itemsContain
	return r
}

// Number of results per page (default: 50, max: 200)
func (r ApiV1FilingsGetRequest) PageSize(pageSize int32) ApiV1FilingsGetRequest {
	r.pageSize = &pageSize
	return r
}

// Page number to retrieve (default: 1)
func (r ApiV1FilingsGetRequest) PageNumber(pageNumber int32) ApiV1FilingsGetRequest {
	r.pageNumber = &pageNumber
	return r
}

// Field to sort results by (default: AccessionNumber)
func (r ApiV1FilingsGetRequest) SortBy(sortBy DTOFilingSortBy) ApiV1FilingsGetRequest {
	r.sortBy = &sortBy
	return r
}

// Sort order (asc or desc, default: desc)
func (r ApiV1FilingsGetRequest) SortOrder(sortOrder string) ApiV1FilingsGetRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiV1FilingsGetRequest) Execute() ([]DTOFilingMetadataDto, *http.Response, error) {
	return r.ApiService.V1FilingsGetExecute(r)
}

/*
V1FilingsGet Query SEC filing metadata

Retrieves metadata for SEC filings based on various filter criteria with pagination and sorting support.

### Available Sort Fields

Field Name | Description
-----------|-------------
AccessionNumber | SEC filing accession number
FilingDate | Date when filing was submitted
AcceptanceDateTime | Date and time of filing acceptance
ReportDate | Date of the report
Size | Size of the filing document

### Date Format
All dates must be provided in YYYY-MM-DD format

### Form Types
Form types can be provided as comma-separated values, e.g.: "10-K,8-K,10-Q"

:::tip
For optimal performance, use date ranges and form types to narrow down your search
:::

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1FilingsGetRequest
*/
func (a *FilingMetadataAPIService) V1FilingsGet(ctx context.Context) ApiV1FilingsGetRequest {
	return ApiV1FilingsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DTOFilingMetadataDto
func (a *FilingMetadataAPIService) V1FilingsGetExecute(r ApiV1FilingsGetRequest) ([]DTOFilingMetadataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DTOFilingMetadataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilingMetadataAPIService.V1FilingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/filings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cik != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cik", r.cik, "form", "")
	}
	if r.formType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "form_type", r.formType, "form", "")
	}
	if r.fillingDateStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filling_date_start", r.fillingDateStart, "form", "")
	}
	if r.fillingDateEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filling_date_end", r.fillingDateEnd, "form", "")
	}
	if r.reportDateStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "report_date_start", r.reportDateStart, "form", "")
	}
	if r.reportDateEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "report_date_end", r.reportDateEnd, "form", "")
	}
	if r.itemsContain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "items_contain", r.itemsContain, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_number", r.pageNumber, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortOrder = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MvcValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
