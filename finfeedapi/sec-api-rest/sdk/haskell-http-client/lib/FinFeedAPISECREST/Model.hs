{-
   FinFeedAPI SEC REST API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.4
   FinFeedAPI SEC REST API API version: v1
   Contact: support@apibricks.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : FinFeedAPISECREST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module FinFeedAPISECREST.Model where

import FinFeedAPISECREST.Core
import FinFeedAPISECREST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AccessionNo
newtype AccessionNo = AccessionNo { unAccessionNo :: Text } deriving (P.Eq, P.Show)

-- ** AccessionNumber
newtype AccessionNumber = AccessionNumber { unAccessionNumber :: Text } deriving (P.Eq, P.Show)

-- ** Cik
newtype Cik = Cik { unCik :: Integer } deriving (P.Eq, P.Show)

-- ** FileName
newtype FileName = FileName { unFileName :: Text } deriving (P.Eq, P.Show)

-- ** FillingDateEnd
newtype FillingDateEnd = FillingDateEnd { unFillingDateEnd :: Text } deriving (P.Eq, P.Show)

-- ** FillingDateStart
newtype FillingDateStart = FillingDateStart { unFillingDateStart :: Text } deriving (P.Eq, P.Show)

-- ** FormType
newtype FormType = FormType { unFormType :: Text } deriving (P.Eq, P.Show)

-- ** HtmUrl
newtype HtmUrl = HtmUrl { unHtmUrl :: Text } deriving (P.Eq, P.Show)

-- ** ItemNumber
newtype ItemNumber = ItemNumber { unItemNumber :: Text } deriving (P.Eq, P.Show)

-- ** ItemsContain
newtype ItemsContain = ItemsContain { unItemsContain :: Text } deriving (P.Eq, P.Show)

-- ** PageNumber
newtype PageNumber = PageNumber { unPageNumber :: Int } deriving (P.Eq, P.Show)

-- ** PageSize
newtype PageSize = PageSize { unPageSize :: Int } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: DTOExtractorType } deriving (P.Eq, P.Show)

-- ** ReportDateEnd
newtype ReportDateEnd = ReportDateEnd { unReportDateEnd :: Text } deriving (P.Eq, P.Show)

-- ** ReportDateStart
newtype ReportDateStart = ReportDateStart { unReportDateStart :: Text } deriving (P.Eq, P.Show)

-- ** SortBy
newtype SortBy = SortBy { unSortBy :: DTOFilingSortBy } deriving (P.Eq, P.Show)

-- ** SortByText
newtype SortByText = SortByText { unSortByText :: Text } deriving (P.Eq, P.Show)

-- ** SortOrder
newtype SortOrder = SortOrder { unSortOrder :: Text } deriving (P.Eq, P.Show)

-- ** TextContains
newtype TextContains = TextContains { unTextContains :: Text } deriving (P.Eq, P.Show)

-- ** TextNotContain
newtype TextNotContain = TextNotContain { unTextNotContain :: Text } deriving (P.Eq, P.Show)

-- ** Ticker
newtype Ticker = Ticker { unTicker :: Text } deriving (P.Eq, P.Show)

-- ** XbrlUrl
newtype XbrlUrl = XbrlUrl { unXbrlUrl :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** DTOFilingMetadataDto
-- | DTOFilingMetadataDto
-- Represents the response for a single SEC filing metadata record. Maps fields from the edgar_submissions table.
data DTOFilingMetadataDto = DTOFilingMetadataDto
  { dTOFilingMetadataDtoCik :: !(Maybe Integer) -- ^ "cik"
  , dTOFilingMetadataDtoAccessionNumber :: !(Maybe Text) -- ^ "accession_number"
  , dTOFilingMetadataDtoFilingDate :: !(Maybe Date) -- ^ "filing_date"
  , dTOFilingMetadataDtoReportDate :: !(Maybe Date) -- ^ "report_date"
  , dTOFilingMetadataDtoAcceptanceDateTime :: !(Maybe DateTime) -- ^ "acceptance_date_time"
  , dTOFilingMetadataDtoAct :: !(Maybe Text) -- ^ "act"
  , dTOFilingMetadataDtoForm :: !(Maybe Text) -- ^ "form"
  , dTOFilingMetadataDtoFileNumber :: !(Maybe Text) -- ^ "file_number"
  , dTOFilingMetadataDtoFilmNumber :: !(Maybe Text) -- ^ "film_number"
  , dTOFilingMetadataDtoItems :: !(Maybe Text) -- ^ "items"
  , dTOFilingMetadataDtoCoreType :: !(Maybe Text) -- ^ "core_type"
  , dTOFilingMetadataDtoSize :: !(Maybe Int) -- ^ "size"
  , dTOFilingMetadataDtoIsXbrl :: !(Maybe Bool) -- ^ "is_xbrl"
  , dTOFilingMetadataDtoIsInlineXbrl :: !(Maybe Bool) -- ^ "is_inline_xbrl"
  , dTOFilingMetadataDtoPrimaryDocument :: !(Maybe Text) -- ^ "primary_document"
  , dTOFilingMetadataDtoPrimaryDocDescription :: !(Maybe Text) -- ^ "primary_doc_description"
  , dTOFilingMetadataDtoSourceFile :: !(Maybe Text) -- ^ "source_file"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DTOFilingMetadataDto
instance A.FromJSON DTOFilingMetadataDto where
  parseJSON = A.withObject "DTOFilingMetadataDto" $ \o ->
    DTOFilingMetadataDto
      <$> (o .:? "cik")
      <*> (o .:? "accession_number")
      <*> (o .:? "filing_date")
      <*> (o .:? "report_date")
      <*> (o .:? "acceptance_date_time")
      <*> (o .:? "act")
      <*> (o .:? "form")
      <*> (o .:? "file_number")
      <*> (o .:? "film_number")
      <*> (o .:? "items")
      <*> (o .:? "core_type")
      <*> (o .:? "size")
      <*> (o .:? "is_xbrl")
      <*> (o .:? "is_inline_xbrl")
      <*> (o .:? "primary_document")
      <*> (o .:? "primary_doc_description")
      <*> (o .:? "source_file")

-- | ToJSON DTOFilingMetadataDto
instance A.ToJSON DTOFilingMetadataDto where
  toJSON DTOFilingMetadataDto {..} =
   _omitNulls
      [ "cik" .= dTOFilingMetadataDtoCik
      , "accession_number" .= dTOFilingMetadataDtoAccessionNumber
      , "filing_date" .= dTOFilingMetadataDtoFilingDate
      , "report_date" .= dTOFilingMetadataDtoReportDate
      , "acceptance_date_time" .= dTOFilingMetadataDtoAcceptanceDateTime
      , "act" .= dTOFilingMetadataDtoAct
      , "form" .= dTOFilingMetadataDtoForm
      , "file_number" .= dTOFilingMetadataDtoFileNumber
      , "film_number" .= dTOFilingMetadataDtoFilmNumber
      , "items" .= dTOFilingMetadataDtoItems
      , "core_type" .= dTOFilingMetadataDtoCoreType
      , "size" .= dTOFilingMetadataDtoSize
      , "is_xbrl" .= dTOFilingMetadataDtoIsXbrl
      , "is_inline_xbrl" .= dTOFilingMetadataDtoIsInlineXbrl
      , "primary_document" .= dTOFilingMetadataDtoPrimaryDocument
      , "primary_doc_description" .= dTOFilingMetadataDtoPrimaryDocDescription
      , "source_file" .= dTOFilingMetadataDtoSourceFile
      ]


-- | Construct a value of type 'DTOFilingMetadataDto' (by applying it's required fields, if any)
mkDTOFilingMetadataDto
  :: DTOFilingMetadataDto
mkDTOFilingMetadataDto =
  DTOFilingMetadataDto
  { dTOFilingMetadataDtoCik = Nothing
  , dTOFilingMetadataDtoAccessionNumber = Nothing
  , dTOFilingMetadataDtoFilingDate = Nothing
  , dTOFilingMetadataDtoReportDate = Nothing
  , dTOFilingMetadataDtoAcceptanceDateTime = Nothing
  , dTOFilingMetadataDtoAct = Nothing
  , dTOFilingMetadataDtoForm = Nothing
  , dTOFilingMetadataDtoFileNumber = Nothing
  , dTOFilingMetadataDtoFilmNumber = Nothing
  , dTOFilingMetadataDtoItems = Nothing
  , dTOFilingMetadataDtoCoreType = Nothing
  , dTOFilingMetadataDtoSize = Nothing
  , dTOFilingMetadataDtoIsXbrl = Nothing
  , dTOFilingMetadataDtoIsInlineXbrl = Nothing
  , dTOFilingMetadataDtoPrimaryDocument = Nothing
  , dTOFilingMetadataDtoPrimaryDocDescription = Nothing
  , dTOFilingMetadataDtoSourceFile = Nothing
  }

-- ** DTOSecFilingResultDto
-- | DTOSecFilingResultDto
data DTOSecFilingResultDto = DTOSecFilingResultDto
  { dTOSecFilingResultDtoAccessionNumber :: !(Maybe Text) -- ^ "accession_number"
  , dTOSecFilingResultDtoFormType :: !(Maybe Text) -- ^ "form_type"
  , dTOSecFilingResultDtoFilingDate :: !(Maybe Date) -- ^ "filing_date"
  , dTOSecFilingResultDtoCompanyName :: !(Maybe Text) -- ^ "company_name"
  , dTOSecFilingResultDtoCik :: !(Maybe Integer) -- ^ "cik"
  , dTOSecFilingResultDtoDocumentFilename :: !(Maybe Text) -- ^ "document_filename"
  , dTOSecFilingResultDtoDocumentDescription :: !(Maybe Text) -- ^ "document_description"
  , dTOSecFilingResultDtoSourceFile :: !(Maybe Text) -- ^ "source_file"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DTOSecFilingResultDto
instance A.FromJSON DTOSecFilingResultDto where
  parseJSON = A.withObject "DTOSecFilingResultDto" $ \o ->
    DTOSecFilingResultDto
      <$> (o .:? "accession_number")
      <*> (o .:? "form_type")
      <*> (o .:? "filing_date")
      <*> (o .:? "company_name")
      <*> (o .:? "cik")
      <*> (o .:? "document_filename")
      <*> (o .:? "document_description")
      <*> (o .:? "source_file")

-- | ToJSON DTOSecFilingResultDto
instance A.ToJSON DTOSecFilingResultDto where
  toJSON DTOSecFilingResultDto {..} =
   _omitNulls
      [ "accession_number" .= dTOSecFilingResultDtoAccessionNumber
      , "form_type" .= dTOSecFilingResultDtoFormType
      , "filing_date" .= dTOSecFilingResultDtoFilingDate
      , "company_name" .= dTOSecFilingResultDtoCompanyName
      , "cik" .= dTOSecFilingResultDtoCik
      , "document_filename" .= dTOSecFilingResultDtoDocumentFilename
      , "document_description" .= dTOSecFilingResultDtoDocumentDescription
      , "source_file" .= dTOSecFilingResultDtoSourceFile
      ]


-- | Construct a value of type 'DTOSecFilingResultDto' (by applying it's required fields, if any)
mkDTOSecFilingResultDto
  :: DTOSecFilingResultDto
mkDTOSecFilingResultDto =
  DTOSecFilingResultDto
  { dTOSecFilingResultDtoAccessionNumber = Nothing
  , dTOSecFilingResultDtoFormType = Nothing
  , dTOSecFilingResultDtoFilingDate = Nothing
  , dTOSecFilingResultDtoCompanyName = Nothing
  , dTOSecFilingResultDtoCik = Nothing
  , dTOSecFilingResultDtoDocumentFilename = Nothing
  , dTOSecFilingResultDtoDocumentDescription = Nothing
  , dTOSecFilingResultDtoSourceFile = Nothing
  }

-- ** MvcProblemDetails
-- | MvcProblemDetails
data MvcProblemDetails = MvcProblemDetails
  { mvcProblemDetailsType :: !(Maybe Text) -- ^ "type"
  , mvcProblemDetailsTitle :: !(Maybe Text) -- ^ "title"
  , mvcProblemDetailsStatus :: !(Maybe Int) -- ^ "status"
  , mvcProblemDetailsDetail :: !(Maybe Text) -- ^ "detail"
  , mvcProblemDetailsInstance :: !(Maybe Text) -- ^ "instance"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MvcProblemDetails
instance A.FromJSON MvcProblemDetails where
  parseJSON = A.withObject "MvcProblemDetails" $ \o ->
    MvcProblemDetails
      <$> (o .:? "type")
      <*> (o .:? "title")
      <*> (o .:? "status")
      <*> (o .:? "detail")
      <*> (o .:? "instance")

-- | ToJSON MvcProblemDetails
instance A.ToJSON MvcProblemDetails where
  toJSON MvcProblemDetails {..} =
   _omitNulls
      [ "type" .= mvcProblemDetailsType
      , "title" .= mvcProblemDetailsTitle
      , "status" .= mvcProblemDetailsStatus
      , "detail" .= mvcProblemDetailsDetail
      , "instance" .= mvcProblemDetailsInstance
      ]


-- | Construct a value of type 'MvcProblemDetails' (by applying it's required fields, if any)
mkMvcProblemDetails
  :: MvcProblemDetails
mkMvcProblemDetails =
  MvcProblemDetails
  { mvcProblemDetailsType = Nothing
  , mvcProblemDetailsTitle = Nothing
  , mvcProblemDetailsStatus = Nothing
  , mvcProblemDetailsDetail = Nothing
  , mvcProblemDetailsInstance = Nothing
  }

-- ** MvcValidationProblemDetails
-- | MvcValidationProblemDetails
data MvcValidationProblemDetails = MvcValidationProblemDetails
  { mvcValidationProblemDetailsType :: !(Maybe Text) -- ^ "type"
  , mvcValidationProblemDetailsTitle :: !(Maybe Text) -- ^ "title"
  , mvcValidationProblemDetailsStatus :: !(Maybe Int) -- ^ "status"
  , mvcValidationProblemDetailsDetail :: !(Maybe Text) -- ^ "detail"
  , mvcValidationProblemDetailsInstance :: !(Maybe Text) -- ^ "instance"
  , mvcValidationProblemDetailsErrors :: !(Maybe (Map.Map String [Text])) -- ^ "errors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MvcValidationProblemDetails
instance A.FromJSON MvcValidationProblemDetails where
  parseJSON = A.withObject "MvcValidationProblemDetails" $ \o ->
    MvcValidationProblemDetails
      <$> (o .:? "type")
      <*> (o .:? "title")
      <*> (o .:? "status")
      <*> (o .:? "detail")
      <*> (o .:? "instance")
      <*> (o .:? "errors")

-- | ToJSON MvcValidationProblemDetails
instance A.ToJSON MvcValidationProblemDetails where
  toJSON MvcValidationProblemDetails {..} =
   _omitNulls
      [ "type" .= mvcValidationProblemDetailsType
      , "title" .= mvcValidationProblemDetailsTitle
      , "status" .= mvcValidationProblemDetailsStatus
      , "detail" .= mvcValidationProblemDetailsDetail
      , "instance" .= mvcValidationProblemDetailsInstance
      , "errors" .= mvcValidationProblemDetailsErrors
      ]


-- | Construct a value of type 'MvcValidationProblemDetails' (by applying it's required fields, if any)
mkMvcValidationProblemDetails
  :: MvcValidationProblemDetails
mkMvcValidationProblemDetails =
  MvcValidationProblemDetails
  { mvcValidationProblemDetailsType = Nothing
  , mvcValidationProblemDetailsTitle = Nothing
  , mvcValidationProblemDetailsStatus = Nothing
  , mvcValidationProblemDetailsDetail = Nothing
  , mvcValidationProblemDetailsInstance = Nothing
  , mvcValidationProblemDetailsErrors = Nothing
  }


-- * Enums


-- ** DTOExtractorType

-- | Enum of 'Text'
data DTOExtractorType
  = DTOExtractorType'Text -- ^ @"text"@
  | DTOExtractorType'Html -- ^ @"html"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON DTOExtractorType where toJSON = A.toJSON . fromDTOExtractorType
instance A.FromJSON DTOExtractorType where parseJSON o = P.either P.fail (pure . P.id) . toDTOExtractorType =<< A.parseJSON o
instance WH.ToHttpApiData DTOExtractorType where toQueryParam = WH.toQueryParam . fromDTOExtractorType
instance WH.FromHttpApiData DTOExtractorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toDTOExtractorType
instance MimeRender MimeMultipartFormData DTOExtractorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'DTOExtractorType' enum
fromDTOExtractorType :: DTOExtractorType -> Text
fromDTOExtractorType = \case
  DTOExtractorType'Text -> "text"
  DTOExtractorType'Html -> "html"

-- | parse 'DTOExtractorType' enum
toDTOExtractorType :: Text -> P.Either String DTOExtractorType
toDTOExtractorType = \case
  "text" -> P.Right DTOExtractorType'Text
  "html" -> P.Right DTOExtractorType'Html
  s -> P.Left $ "toDTOExtractorType: enum parse failure: " P.++ P.show s


-- ** DTOFilingSortBy

-- | Enum of 'Text' .
-- Defines sorting options for the filing query.
data DTOFilingSortBy
  = DTOFilingSortBy'AccessionNumber -- ^ @"AccessionNumber"@
  | DTOFilingSortBy'FilingDate -- ^ @"FilingDate"@
  | DTOFilingSortBy'ReportDate -- ^ @"ReportDate"@
  | DTOFilingSortBy'AcceptanceDateTime -- ^ @"AcceptanceDateTime"@
  | DTOFilingSortBy'Size -- ^ @"Size"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON DTOFilingSortBy where toJSON = A.toJSON . fromDTOFilingSortBy
instance A.FromJSON DTOFilingSortBy where parseJSON o = P.either P.fail (pure . P.id) . toDTOFilingSortBy =<< A.parseJSON o
instance WH.ToHttpApiData DTOFilingSortBy where toQueryParam = WH.toQueryParam . fromDTOFilingSortBy
instance WH.FromHttpApiData DTOFilingSortBy where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toDTOFilingSortBy
instance MimeRender MimeMultipartFormData DTOFilingSortBy where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'DTOFilingSortBy' enum
fromDTOFilingSortBy :: DTOFilingSortBy -> Text
fromDTOFilingSortBy = \case
  DTOFilingSortBy'AccessionNumber -> "AccessionNumber"
  DTOFilingSortBy'FilingDate -> "FilingDate"
  DTOFilingSortBy'ReportDate -> "ReportDate"
  DTOFilingSortBy'AcceptanceDateTime -> "AcceptanceDateTime"
  DTOFilingSortBy'Size -> "Size"

-- | parse 'DTOFilingSortBy' enum
toDTOFilingSortBy :: Text -> P.Either String DTOFilingSortBy
toDTOFilingSortBy = \case
  "AccessionNumber" -> P.Right DTOFilingSortBy'AccessionNumber
  "FilingDate" -> P.Right DTOFilingSortBy'FilingDate
  "ReportDate" -> P.Right DTOFilingSortBy'ReportDate
  "AcceptanceDateTime" -> P.Right DTOFilingSortBy'AcceptanceDateTime
  "Size" -> P.Right DTOFilingSortBy'Size
  s -> P.Left $ "toDTOFilingSortBy: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyAPIKey
data AuthApiKeyAPIKey =
  AuthApiKeyAPIKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyAPIKey where
  applyAuthMethod _ a@(AuthApiKeyAPIKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


